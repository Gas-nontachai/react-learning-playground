"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/\nclass NodeProp {\n    /**\n    Create a new node prop type.\n    */\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n        this.combine = config.combine || null;\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/\nNodeProp.isolate = new NodeProp({ deserialize: value => {\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\")\n            throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    } });\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/\nNodeProp.mounted = new NodeProp({ perNode: true });\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/\nclass MountedTree {\n    constructor(\n    /**\n    The inner tree.\n    */\n    tree, \n    /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */\n    overlay, \n    /**\n    The parser used to create this subtree.\n    */\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */\n    static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */\n    name, \n    /**\n    @internal\n    */\n    props, \n    /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */\n    id, \n    /**\n    @internal\n    */\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */\n    prop(prop) { return this.props[prop.id]; }\n    /**\n    True when this is the top node of a grammar.\n    */\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /**\n    True when this node is produced by a skip rule.\n    */\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /**\n    Indicates whether this is an error node.\n    */\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/\nclass NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */\n    constructor(\n    /**\n    The node types in this set, by id.\n    */\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    let value = add[1], prop = add[0];\n                    if (prop.combine && prop.id in newProps)\n                        value = prop.combine(newProps[prop.id], value);\n                    newProps[prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/\nvar IterMode;\n(function (IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/\nclass Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */\n    constructor(\n    /**\n    The type of the top node.\n    */\n    type, \n    /**\n    This node's child nodes.\n    */\n    children, \n    /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */\n    positions, \n    /**\n    The total length of this tree\n    */\n    length, \n    /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */\n    resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && (anon || !c.type.isAnonymous))\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */\n    static build(data) { return buildTree(data); }\n}\n/**\nThe empty tree\n*/\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/\nclass TreeBuffer {\n    /**\n    Create a tree buffer.\n    */\n    constructor(\n    /**\n    The buffer's content.\n    */\n    buffer, \n    /**\n    The total length of the group of nodes in the buffer.\n    */\n    length, \n    /**\n    The node set used in this buffer.\n    */\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */\n    get type() { return NodeType.none; }\n    /**\n    @internal\n    */\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this.parent, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while (scan) {\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to)\n                break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            }\n            else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() { return this; }\n    get next() { return this.parent; }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    /**\n    @internal\n    */\n    toString() { return this._tree.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        for (let found = false; !found;) {\n            found = cur.type.is(before);\n            if (!cur.nextSibling())\n                return result;\n        }\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */\n    toString() { return this.context.buffer.childString(this.index); }\n}\nfunction iterStack(heads) {\n    if (!heads.length)\n        return null;\n    let pick = 0, picked = heads[0];\n    for (let i = 1; i < heads.length; i++) {\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next)\n        newHeads[pick] = next;\n    else\n        newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node) {\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() { return iterStack(this.heads); }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {\n        if (scan.index < 0) { // This is an overlay root\n            let parent = scan.parent;\n            (layers || (layers = [inner])).push(parent.resolve(pos, side));\n            scan = parent;\n        }\n        else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/\nclass TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */\n    get name() { return this.type.name; }\n    /**\n    @internal\n    */\n    constructor(node, \n    /**\n    @internal\n    */\n    mode = 0) {\n        this.mode = mode;\n        /**\n        @internal\n        */\n        this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to this node's last child.\n    */\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /**\n    Move to the last child that starts before `pos`.\n    */\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */\n    nextSibling() { return this.sibling(1); }\n    /**\n    Move to this node's previous sibling, if any.\n    */\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */\n    next(enter = true) { return this.move(1, enter); }\n    /**\n    Move to the next node in a last-to-first pre-order traversal. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */\n    prev(enter = true) { return this.move(-1, enter); }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (!depth)\n                    return;\n                if (this.nextSibling())\n                    break;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node.parent, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this._tree, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;\n        if (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else if (depth > 2500 /* CutOff.Depth */) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type, contextAtStart);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while (cursor.pos > minPos) {\n            let { id, start, end, size } = cursor;\n            if (size > 4) { // Not a leaf\n                cursor.next();\n            }\n            else if (stopAt > -1 && start < stopAt) {\n                break;\n            }\n            else {\n                if (stopAt < 0)\n                    stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type, contextHash) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead, contextHash);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/\nclass TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */\n    constructor(\n    /**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */\n    from, \n    /**\n    The end of the unchanged range.\n    */\n    to, \n    /**\n    The tree that this fragment is based on.\n    */\n    tree, \n    /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/\nclass Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some(r => r.from >= r.to))\n        throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered;;) {\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            }\n            else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&\n                (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) {\n                    materialize(cursor);\n                    // materialize create one more level of nesting\n                    // we need to add depth to active overlay for going backwards\n                    if (overlay)\n                        overlay.depth++;\n                    if (covered)\n                        covered.depth++;\n                }\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay ||\n                        (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));\n                    if (ranges.length)\n                        checkRanges(ranges);\n                    if (ranges.length || !nest.overlay)\n                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)\n                            : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) {\n                    let last = overlay.ranges.length - 1;\n                    if (last >= 0 && overlay.ranges[last].to == range.from)\n                        overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };\n                    else\n                        overlay.ranges.push(range);\n                }\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [i];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos\n            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)\n            : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack) {\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxrQ0FBa0M7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1sZWFybmluZy1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0BsZXplci9jb21tb24vZGlzdC9pbmRleC5qcz9mYTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbiovXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuLyoqXG5FYWNoIFtub2RlIHR5cGVdKCNjb21tb24uTm9kZVR5cGUpIG9yIFtpbmRpdmlkdWFsIHRyZWVdKCNjb21tb24uVHJlZSlcbmNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBpdCBpbiBwcm9wcy4gSW5zdGFuY2VzIG9mIHRoaXNcbmNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuKi9cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLnBlck5vZGUgPSAhIWNvbmZpZy5wZXJOb2RlO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gY29uZmlnLmRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29uZmlnLmNvbWJpbmUgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGhcbiAgICBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5QYXJzZXJDb25maWcucHJvcHMpIHRvIGNvbXB1dGVcbiAgICBwcm9wIHZhbHVlcyBmb3IgZWFjaCBub2RlIHR5cGUgaW4gdGhlIHNldC4gVGFrZXMgYSBbbWF0Y2hcbiAgICBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICBpZiB0aGUgbm9kZSB0eXBlIGRvZXNuJ3QgZ2V0IHRoaXMgcHJvcCwgYW5kIHRoZSBwcm9wJ3MgdmFsdWUgaWZcbiAgICBpdCBkb2VzLlxuICAgICovXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcblByb3AgdGhhdCBpcyB1c2VkIHRvIGRlc2NyaWJlIG1hdGNoaW5nIGRlbGltaXRlcnMuIEZvciBvcGVuaW5nXG5kZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuZm9yIHRoZSBub2RlIHR5cGVzIG9mIGNsb3NpbmcgZGVsaW1pdGVycyB0aGF0IG1hdGNoIGl0LlxuKi9cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5UaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbmF0dGFjaGVkIHRvIGNsb3NpbmcgZGVsaW1pdGVycywgaG9sZGluZyBhbiBhcnJheSBvZiBub2RlIG5hbWVzXG5vZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG4qL1xuTm9kZVByb3Aub3BlbmVkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcblVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbnR5cGVzIHRoYXQgcmVwcmVzZW50IGFuIGV4cHJlc3Npb24gY291bGQgYmUgdGFnZ2VkIHdpdGggYW5cbmBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuKi9cbk5vZGVQcm9wLmdyb3VwID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5BdHRhY2hlZCB0byBub2RlcyB0byBpbmRpY2F0ZSB0aGVzZSBzaG91bGQgYmVcbltkaXNwbGF5ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpXG5pbiBhIGJpZGlyZWN0aW9uYWwgdGV4dCBpc29sYXRlLCBzbyB0aGF0IGRpcmVjdGlvbi1uZXV0cmFsXG5jaGFyYWN0ZXJzIG9uIHRoZWlyIHNpZGVzIGRvbid0IGluY29ycmVjdGx5IGdldCBhc3NvY2lhdGVkIHdpdGhcbnN1cnJvdW5kaW5nIHRleHQuIFlvdSdsbCBnZW5lcmFsbHkgd2FudCB0byBzZXQgdGhpcyBmb3Igbm9kZXNcbnRoYXQgY29udGFpbiBhcmJpdHJhcnkgdGV4dCwgbGlrZSBzdHJpbmdzIGFuZCBjb21tZW50cywgYW5kIGZvclxubm9kZXMgdGhhdCBhcHBlYXIgX2luc2lkZV8gYXJiaXRyYXJ5IHRleHQsIGxpa2UgSFRNTCB0YWdzLiBXaGVuXG5ub3QgZ2l2ZW4gYSB2YWx1ZSwgaW4gYSBncmFtbWFyIGRlY2xhcmF0aW9uLCBkZWZhdWx0cyB0b1xuYFwiYXV0b1wiYC5cbiovXG5Ob2RlUHJvcC5pc29sYXRlID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9IFwicnRsXCIgJiYgdmFsdWUgIT0gXCJsdHJcIiAmJiB2YWx1ZSAhPSBcImF1dG9cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgaXNvbGF0ZTogXCIgKyB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBcImF1dG9cIjtcbiAgICB9IH0pO1xuLyoqXG5UaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3RvcilcbnRoYXQgdGhlIG5vZGUgd2FzIHBhcnNlZCBpbiwgaWYgYW55LiBVc2VkIHRvIGxpbWl0IHJldXNlIG9mXG5jb250ZXh0dWFsIG5vZGVzLlxuKi9cbk5vZGVQcm9wLmNvbnRleHRIYXNoID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxubG9va2VkIGFoZWFkIGZvciBhbnkgb2YgdGhlIHRva2VucyBpbnNpZGUgdGhlIG5vZGUuIChUaGUgTFJcbnBhcnNlciBvbmx5IHN0b3JlcyB0aGlzIHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gMjUsIGZvclxuZWZmaWNpZW5jeSByZWFzb25zLilcbiovXG5Ob2RlUHJvcC5sb29rQWhlYWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5UaGlzIHBlci1ub2RlIHByb3AgaXMgdXNlZCB0byByZXBsYWNlIGEgZ2l2ZW4gbm9kZSwgb3IgcGFydCBvZiBhXG5ub2RlLCB3aXRoIGFub3RoZXIgdHJlZS4gVGhpcyBpcyB1c2VmdWwgdG8gaW5jbHVkZSB0cmVlcyBmcm9tXG5kaWZmZXJlbnQgbGFuZ3VhZ2VzIGluIG1peGVkLWxhbmd1YWdlIHBhcnNlcnMuXG4qL1xuTm9kZVByb3AubW91bnRlZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcbkEgbW91bnRlZCB0cmVlLCB3aGljaCBjYW4gYmUgW3N0b3JlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBvblxuYSB0cmVlIG5vZGUgdG8gaW5kaWNhdGUgdGhhdCBwYXJ0cyBvZiBpdHMgY29udGVudCBhcmVcbnJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbiovXG5jbGFzcyBNb3VudGVkVHJlZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGlubmVyIHRyZWUuXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIG51bGwsIHRoaXMgdHJlZSByZXBsYWNlcyB0aGUgZW50aXJlIG5vZGUgKGl0IHdpbGxcbiAgICBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIG5vZGUpLiBJZiBub3QsIG9ubHkgdGhlIGdpdmVuIHJhbmdlcyBhcmUgY29uc2lkZXJlZCB0byBiZVxuICAgIGNvdmVyZWQgYnkgdGhpcyB0cmVlLiBUaGlzIGlzIHVzZWQgZm9yIHRyZWVzIHRoYXQgYXJlIG1peGVkIGluXG4gICAgYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICBvbmx5IGVudGVyZWQgYnkgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKVxuICAgIGFuZCBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS5cbiAgICAqL1xuICAgIG92ZXJsYXksIFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZXIgdXNlZCB0byBjcmVhdGUgdGhpcyBzdWJ0cmVlLlxuICAgICovXG4gICAgcGFyc2VyKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBnZXQodHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZSAmJiB0cmVlLnByb3BzICYmIHRyZWUucHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF07XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIGdyYW1tYXIgd2FzIHdyaXR0ZW4gcHJvcGVybHksIGRpZmZlcmVudCBub2RlIHR5cGVzIHdpdGggdGhlXG4gICAgc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgcm9sZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHJvcHMsIFxuICAgIC8qKlxuICAgIFRoZSBpZCBvZiB0aGlzIG5vZGUgaW4gaXRzIHNldC4gQ29ycmVzcG9uZHMgdG8gdGhlIHRlcm0gaWRzXG4gICAgdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgcHJvcHMgPSBzcGVjLnByb3BzICYmIHNwZWMucHJvcHMubGVuZ3RoID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG5vUHJvcHM7XG4gICAgICAgIGxldCBmbGFncyA9IChzcGVjLnRvcCA/IDEgLyogTm9kZUZsYWcuVG9wICovIDogMCkgfCAoc3BlYy5za2lwcGVkID8gMiAvKiBOb2RlRmxhZy5Ta2lwcGVkICovIDogMCkgfFxuICAgICAgICAgICAgKHNwZWMuZXJyb3IgPyA0IC8qIE5vZGVGbGFnLkVycm9yICovIDogMCkgfCAoc3BlYy5uYW1lID09IG51bGwgPyA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLyA6IDApO1xuICAgICAgICBsZXQgdHlwZSA9IG5ldyBOb2RlVHlwZShzcGVjLm5hbWUgfHwgXCJcIiwgcHJvcHMsIHNwZWMuaWQsIGZsYWdzKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBzcmMgb2Ygc3BlYy5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmModHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjWzBdLnBlck5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IHN0b3JlIGEgcGVyLW5vZGUgcHJvcCBvbiBhIG5vZGUgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbc3JjWzBdLmlkXSA9IHNyY1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5wcm9wc1twcm9wLmlkXTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgKi9cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogTm9kZUZsYWcuVG9wICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIHByb2R1Y2VkIGJ5IGEgc2tpcCBydWxlLlxuICAgICovXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBOb2RlRmxhZy5Ta2lwcGVkICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNFcnJvcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBOb2RlRmxhZy5FcnJvciAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgKi9cbiAgICBnZXQgaXNBbm9ueW1vdXMoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICBbZ3JvdXBzXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpcyhuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gdGhpcy5wcm9wKE5vZGVQcm9wLmdyb3VwKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cCA/IGdyb3VwLmluZGV4T2YobmFtZSkgPiAtMSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlkID09IG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICBbZ3JvdXBdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIG11bHRpcGxlIG5vZGUgbmFtZXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5BbiBlbXB0eSBkdW1teSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gbm8gYWN0dWFsIHR5cGUgaXMgYXZhaWxhYmxlLlxuKi9cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pO1xuLyoqXG5BIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG5jb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbmZ1bGwgcG9pbnRlciB0byB0aGUgdHlwZSBvYmplY3QsIGluIGEgbnVtZXJpYyBhcnJheS4gRWFjaCBwYXJzZXJcbltoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbmJ1ZmZlcnNdKCNjb21tb24uVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbmZyb20gdGhlIHNhbWUgc2V0LiBBIHNldCBjYW4gaGF2ZSBhIG1heGltdW0gb2YgMioqMTYgKDY1NTM2KSBub2RlXG50eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbiovXG5jbGFzcyBOb2RlU2V0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgICovXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXG4gICAgYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIGNhbiBiZSBjcmVhdGVkIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS5cbiAgICAqL1xuICAgIGV4dGVuZCguLi5wcm9wcykge1xuICAgICAgICBsZXQgbmV3VHlwZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBvZiB0aGlzLnR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZCA9IHNvdXJjZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBhZGRbMV0sIHByb3AgPSBhZGRbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLmNvbWJpbmUgJiYgcHJvcC5pZCBpbiBuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcC5jb21iaW5lKG5ld1Byb3BzW3Byb3AuaWRdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW3Byb3AuaWRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbk9wdGlvbnMgdGhhdCBjb250cm9sIGl0ZXJhdGlvbi4gQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGB8YFxub3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG4qL1xudmFyIEl0ZXJNb2RlO1xuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xuICAgIC8qKlxuICAgIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLyoqXG4gICAgRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcbiAgICB0cmVlKS5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLyoqXG4gICAgQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xuICAgIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICBpbnN0ZWFkLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XG4gICAgLyoqXG4gICAgVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoSXRlck1vZGUgfHwgKEl0ZXJNb2RlID0ge30pKTtcbi8qKlxuQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG50cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG5jb252ZW5pZW50IHdheS5cblxuU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG5vYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG5ub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuXG5Ib3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG5yZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG51c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3JcbltgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG5hIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xubW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGNoaWxkcmVuLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgdGhlIGNoaWxkcmVuLlxuICAgICovXG4gICAgcG9zaXRpb25zLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZlxuICAgIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAgICovXG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICAgIFtgbW92ZVRvYF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbykuXG4gICAgKi9cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICB0cmVlLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICBmcm9tIGJvdGggc2lkZXMuXG4gICAgXG4gICAgTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICBbb3ZlcmxheXNdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSksIGFuZCB5b3Ugb2Z0ZW4gd2FudFxuICAgIFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcikgaW5zdGVhZC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICB0aGUgaG9zdCB0cmVlcykuXG4gICAgKi9cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW4gc29tZSBzaXR1YXRpb25zLCBpdCBjYW4gYmUgdXNlZnVsIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGxcbiAgICBub2RlcyBhcm91bmQgYSBwb3NpdGlvbiwgaW5jbHVkaW5nIHRob3NlIGluIG92ZXJsYXlzIHRoYXQgZG9uJ3RcbiAgICBkaXJlY3RseSBjb3ZlciB0aGUgcG9zaXRpb24uIFRoaXMgbWV0aG9kIGdpdmVzIHlvdSBhbiBpdGVyYXRvclxuICAgIHRoYXQgd2lsbCBwcm9kdWNlIGFsbCBub2RlcywgZnJvbSBzbWFsbCB0byBiaWcsIGFyb3VuZCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHJlc29sdmVTdGFjayhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFja0l0ZXJhdG9yKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICBydW5uaW5nIG92ZXIgc3VjaCBhIG5vZGUncyBjaGlsZHJlbiwgYW5kIGBsZWF2ZWAgKGlmIGdpdmVuKSB3aGVuXG4gICAgbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgICovXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGxldCBtb2RlID0gc3BlYy5tb2RlIHx8IDAsIGFub24gPSAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID4gMDtcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKG1vZGUgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKCFhbm9uICYmIGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAoYW5vbiB8fCAhYy50eXBlLmlzQW5vbnltb3VzKSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYyk7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICBub2RlLiBXb3JrcyB3aXRoIGJvdGggcGVyLW5vZGUgYW5kIHBlci10eXBlIHByb3BzLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIGNvbnN0cnVjdG9yLlxuICAgICovXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUsIHByb2R1Y2luZyBhIGNvcHkgb2ZcbiAgICB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICAqL1xuICAgIGJhbGFuY2UoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICAqL1xuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHRyZWVcbiovXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vKipcblRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbm5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG5iZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuY2hpbGRyZW4gYmVsb25nIHRvIGl0KS5cbiovXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmVlIGJ1ZmZlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXQgdXNlZCBpbiB0aGlzIGJ1ZmZlci5cbiAgICAqL1xuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gTm9kZVR5cGUubm9uZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tTaWRlKHNpZGUsIHBvcywgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBvdmVybGF5cyA/IDAgOiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQmFzZU5vZGUge1xuICAgIGN1cnNvcihtb2RlID0gMCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcywgbW9kZSk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLnBhcmVudCwgY29udGV4dCk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykge1xuICAgICAgICBsZXQgc2NhbiA9IHRoaXMuY2hpbGRCZWZvcmUocG9zKSwgbm9kZSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChzY2FuKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFsYXN0IHx8IGxhc3QudG8gIT0gc2Nhbi50bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzY2FuO1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0LnByZXZTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy5wYXJlbnQ7IH1cbn1cbmNsYXNzIFRyZWVOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKF90cmVlLCBmcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IF90cmVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMuX3RyZWUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgcG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Ll90cmVlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVNb3VudHMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KG5leHQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgIGlmICghKG1vZGUgJiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQodGhpcy5fdHJlZSkpICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IHJQb3MgPSBwb3MgLSB0aGlzLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlID4gMCA/IGZyb20gPD0gclBvcyA6IGZyb20gPCByUG9zKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2lkZSA8IDAgPyB0byA+PSByUG9zIDogdG8gPiByUG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgdGhpcy5mcm9tLCAtMSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgc2lkZSwgbW9kZSk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICB0b1RyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3RyZWUudG9TdHJpbmcoKTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICBmb3IgKGxldCBmb3VuZCA9IGZhbHNlOyAhZm91bmQ7KSB7XG4gICAgICAgICAgICBmb3VuZCA9IGN1ci50eXBlLmlzKGJlZm9yZSk7XG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hOb2RlQ29udGV4dChub2RlLCBjb250ZXh0LCBpID0gY29udGV4dC5sZW5ndGggLSAxKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGU7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gcC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyc2FsLiBBXG4gICAgbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgICovXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAgICovXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIGBlbnRlcmAgd2hlbiBlbnRlcmluZyBhIG5vZGUgYW5kIGBsZWF2ZWAsIGlmIGdpdmVuLCB3aGVuIGxlYXZpbmdcbiAgICBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICAqL1xuICAgIGl0ZXJhdGUoZW50ZXIsIGxlYXZlKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKHRoaXMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdGhpcy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcbiAgICBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXG4gICAgKi9cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLnBhcmVudCwgY29udGV4dCk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIHsgdHlwZXMgfSA9IGJ1ZmZlci5zZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5fdHJlZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZCwgY29udGV4dEF0U3RhcnQgPSBjb250ZXh0SGFzaDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPiAyNTAwIC8qIEN1dE9mZi5EZXB0aCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0YWtlRmxhdE5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlLCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRha2VGbGF0Tm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zKSB7XG4gICAgICAgIGxldCBub2RlcyA9IFtdOyAvLyBUZW1wb3JhcnksIGludmVydGVkIGFycmF5IG9mIGxlYWYgbm9kZXMgZm91bmQsIHdpdGggYWJzb2x1dGUgcG9zaXRpb25zXG4gICAgICAgIGxldCBub2RlQ291bnQgPSAwLCBzdG9wQXQgPSAtMTtcbiAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBtaW5Qb3MpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHsgLy8gTm90IGEgbGVhZlxuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdG9wQXQgPiAtMSAmJiBzdGFydCA8IHN0b3BBdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BBdCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCA9IGVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGlkLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBub2RlQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkobm9kZUNvdW50ICogNCk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAzLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDFdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMl0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBUcmVlQnVmZmVyKGJ1ZmZlciwgbm9kZXNbMl0gLSBzdGFydCwgbm9kZVNldCkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bywgY29udGV4dEhhc2gpKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEsIDApO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuLyoqXG5Qcm92aWRlcyBhIHdheSB0byBhc3NvY2lhdGUgdmFsdWVzIHdpdGggcGllY2VzIG9mIHRyZWVzLiBBcyBsb25nXG5hcyB0aGF0IHBhcnQgb2YgdGhlIHRyZWUgaXMgcmV1c2VkLCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgY2FuIGJlXG5yZXRyaWV2ZWQgZnJvbSBhbiB1cGRhdGVkIHRyZWUuXG4qL1xuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChidWZmZXIsIGlubmVyID0gbmV3IE1hcCk7XG4gICAgICAgIGlubmVyLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBzZXQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQobm9kZS50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAqL1xuICAgIGdldChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSA/IHRoaXMuZ2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgpXG4gICAgICAgICAgICA6IG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IHRoaXMubWFwLmdldChub2RlLnRyZWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHMgdG8uXG4gICAgKi9cbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoY3Vyc29yLmJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGN1cnNvci50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzXG4gICAgdG8uXG4gICAgKi9cbiAgICBjdXJzb3JHZXQoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xuICAgIH1cbn1cblxuLyoqXG5UcmVlIGZyYWdtZW50cyBhcmUgdXNlZCBkdXJpbmcgW2luY3JlbWVudGFsXG5wYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbnRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbnRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkIGluIG5ld1xucGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xudXBkYXRlIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbiovXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRyZWUgZnJhZ21lbnQuIFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlXG4gICAgW2BhZGRUcmVlYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYWRkVHJlZSkgYW5kXG4gICAgW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIGluc3RlYWQgb2ZcbiAgICBjYWxsaW5nIHRoaXMgZGlyZWN0bHkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIE9wZW4uU3RhcnQgKi8gOiAwKSB8IChvcGVuRW5kID8gMiAvKiBPcGVuLkVuZCAqLyA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgYmUgc2FmZSB0byByZXVzZSBzb21lIG5vZGVzIGF0IHRoZSBzdGFydCwgZGVwZW5kaW5nIG9uIHRoZVxuICAgIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICAqL1xuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBPcGVuLlN0YXJ0ICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgZnVsbC1kb2N1bWVudCBwYXJzZSwgb3IgdGhlIHN0YXJ0IG9mIGEgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBPcGVuLkVuZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgZnJhZ21lbnQgaGFzIFtgb3BlbkVuZGBdKCNjb21tb24uVHJlZUZyYWdtZW50Lm9wZW5FbmQpIHNldCB0b1xuICAgIHRydWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgZmFsc2UsIHBhcnRpYWwpXTtcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXG4gICAgICAgICAgICBpZiAoZi50byA+IHRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIGFkanVzdGluZyBvZmZzZXRzIGZvciBmcmFnbWVudHMgdGhhdCBtb3ZlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwOzsgY0krKykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0ldIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dEMgPyBuZXh0Qy5mcm9tQSA6IDFlOTtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEYgJiYgbmV4dEYuZnJvbSA8IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1dCA9IG5leHRGO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZGcm9tID0gTWF0aC5tYXgoY3V0LmZyb20sIHBvcykgLSBvZmYsIGZUbyA9IE1hdGgubWluKGN1dC50bywgbmV4dFBvcykgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXQgPSBmRnJvbSA+PSBmVG8gPyBudWxsIDogbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgY0kgPiAwLCAhIW5leHRDKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuQSBzdXBlcmNsYXNzIHRoYXQgcGFyc2VycyBzaG91bGQgZXh0ZW5kLlxuKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxuICAgIG9iamVjdC4gW2BmcmFnbWVudHNgXSgjY29tbW9uLlRyZWVGcmFnbWVudCkgY2FuIGJlIHBhc3NlZCBpbiB0b1xuICAgIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoZSBlbnRpcmUgaW5wdXQgaXMgcGFyc2VkLiBZb3UgY2FuIHBhc3MgYHJhbmdlc2AsXG4gICAgd2hpY2ggc2hvdWxkIGJlIGEgc29ydGVkIGFycmF5IG9mIG5vbi1lbXB0eSwgbm9uLW92ZXJsYXBwaW5nXG4gICAgcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIGNhc2Ugd2lsbCBzdGFydCBhdCBgcmFuZ2VzWzBdLmZyb21gLlxuICAgICovXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByYW5nZXMgPSAhcmFuZ2VzID8gW25ldyBSYW5nZSgwLCBpbnB1dC5sZW5ndGgpXSA6IHJhbmdlcy5sZW5ndGggPyByYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSwgci50bykpIDogW25ldyBSYW5nZSgwLCAwKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMgfHwgW10sIHJhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgKi9cbiAgICBwYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gdGhpcy5zdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gcGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgY2h1bmsoZnJvbSkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSk7IH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgdG8pOyB9XG59XG5cbi8qKlxuQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuc2NhbnMgaXRzIHRyZWUgZm9yIG1peGVkIGxhbmd1YWdlIHJlZ2lvbnMgd2l0aCB0aGUgYG5lc3RgXG5mdW5jdGlvbiwgcnVucyB0aGUgcmVzdWx0aW5nIFtpbm5lciBwYXJzZXNdKCNjb21tb24uTmVzdGVkUGFyc2UpLFxuYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG50cmVlLlxuKi9cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIGZyb20pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tSYW5nZXMocmFuZ2VzKSB7XG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoIHx8IHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID49IHIudG8pKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5uZXIgcGFyc2UgcmFuZ2VzIGdpdmVuOiBcIiArIEpTT04uc3RyaW5naWZ5KHJhbmdlcykpO1xufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBjdXJzb3IuZnJvbSA+PSB0aGlzLnN0b3BwZWRBdCkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpICYmXG4gICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvIHx8ICFuZXN0Lm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRlcmlhbGl6ZSBjcmVhdGUgb25lIG1vcmUgbGV2ZWwgb2YgbmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFkZCBkZXB0aCB0byBhY3RpdmUgb3ZlcmxheSBmb3IgZ29pbmcgYmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBvdmVybGF5LnJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA+PSAwICYmIG92ZXJsYXkucmFuZ2VzW2xhc3RdLnRvID09IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlc1tsYXN0XSA9IHsgZnJvbTogb3ZlcmxheS5yYW5nZXNbbGFzdF0uZnJvbSwgdG86IHJhbmdlLnRvIH07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXNbMF0uZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG92ZXJsYXkucHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZCAmJiAhLS1jb3ZlcmVkLmRlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IGNvdmVyZWQucHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0NvdmVyKGNvdmVyZWQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2YgY292ZXJlZCkge1xuICAgICAgICBpZiAocmFuZ2UuZnJvbSA+PSB0bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocmFuZ2UudG8gPiBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0byA/IDIgLyogQ292ZXIuRnVsbCAqLyA6IDEgLyogQ292ZXIuUGFydGlhbCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogQ292ZXIuTm9uZSAqLztcbn1cbi8vIFRha2UgYSBwaWVjZSBvZiBidWZmZXIgYW5kIGNvbnZlcnQgaXQgaW50byBhIHN0YW5kLWFsb25lXG4vLyBUcmVlQnVmZmVyLlxuZnVuY3Rpb24gc2xpY2VCdWYoYnVmLCBzdGFydEksIGVuZEksIG5vZGVzLCBwb3NpdGlvbnMsIG9mZikge1xuICAgIGlmIChzdGFydEkgPCBlbmRJKSB7XG4gICAgICAgIGxldCBmcm9tID0gYnVmLmJ1ZmZlcltzdGFydEkgKyAxXTtcbiAgICAgICAgbm9kZXMucHVzaChidWYuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBvZmYpO1xuICAgIH1cbn1cbi8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBub2RlIHRoYXQncyBpbiBhIGJ1ZmZlciwgYW5kIGNvbnZlcnRzIGl0LCBhbmRcbi8vIGl0cyBwYXJlbnQgYnVmZmVyIG5vZGVzLCBpbnRvIGEgVHJlZS4gVGhpcyBpcyBhZ2FpbiBhY3Rpbmcgb24gdGhlXG4vLyBhc3N1bXB0aW9uIHRoYXQgdGhlIHRyZWVzIGFuZCBidWZmZXJzIGhhdmUgYmVlbiBjb25zdHJ1Y3RlZCBieSB0aGVcbi8vIHBhcnNlIHRoYXQgd2FzIHJhbiB2aWEgdGhlIG1peCBwYXJzZXIsIGFuZCB0aHVzIGFyZW4ndCBzaGFyZWQgd2l0aFxuLy8gYW55IG90aGVyIGNvZGUsIG1ha2luZyB2aW9sYXRpb25zIG9mIHRoZSBpbW11dGFiaWxpdHkgc2FmZS5cbmZ1bmN0aW9uIG1hdGVyaWFsaXplKGN1cnNvcikge1xuICAgIGxldCB7IG5vZGUgfSA9IGN1cnNvciwgc3RhY2sgPSBbXTtcbiAgICBsZXQgYnVmZmVyID0gbm9kZS5jb250ZXh0LmJ1ZmZlcjtcbiAgICAvLyBTY2FuIHVwIHRvIHRoZSBuZWFyZXN0IHRyZWVcbiAgICBkbyB7XG4gICAgICAgIHN0YWNrLnB1c2goY3Vyc29yLmluZGV4KTtcbiAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgIH0gd2hpbGUgKCFjdXJzb3IudHJlZSk7XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGJ1ZmZlciBpbiB0aGF0IHRyZWVcbiAgICBsZXQgYmFzZSA9IGN1cnNvci50cmVlLCBpID0gYmFzZS5jaGlsZHJlbi5pbmRleE9mKGJ1ZmZlcik7XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyLCBuZXdTdGFjayA9IFtpXTtcbiAgICAvLyBTcGxpdCBhIGxldmVsIGluIHRoZSBidWZmZXIsIHB1dHRpbmcgdGhlIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBzcGxpdChzdGFydEksIGVuZEksIHR5cGUsIGlubmVyT2Zmc2V0LCBsZW5ndGgsIHN0YWNrUG9zKSB7XG4gICAgICAgIGxldCB0YXJnZXRJID0gc3RhY2tbc3RhY2tQb3NdO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCB0YXJnZXRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIGxldCBmcm9tID0gYlt0YXJnZXRJICsgMV0sIHRvID0gYlt0YXJnZXRJICsgMl07XG4gICAgICAgIG5ld1N0YWNrLnB1c2goY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNoaWxkID0gc3RhY2tQb3NcbiAgICAgICAgICAgID8gc3BsaXQodGFyZ2V0SSArIDQsIGJbdGFyZ2V0SSArIDNdLCBidWYuc2V0LnR5cGVzW2JbdGFyZ2V0SV1dLCBmcm9tLCB0byAtIGZyb20sIHN0YWNrUG9zIC0gMSlcbiAgICAgICAgICAgIDogbm9kZS50b1RyZWUoKTtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYlt0YXJnZXRJICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCwgc3RhY2subGVuZ3RoIC0gMSk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgaW5kZXggb2YgbmV3U3RhY2spIHtcbiAgICAgICAgbGV0IHRyZWUgPSBjdXJzb3IudHJlZS5jaGlsZHJlbltpbmRleF0sIHBvcyA9IGN1cnNvci50cmVlLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgIGN1cnNvci55aWVsZChuZXcgVHJlZU5vZGUodHJlZSwgcG9zICsgY3Vyc29yLmZyb20sIGluZGV4LCBjdXJzb3IuX3RyZWUpKTtcbiAgICB9XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMgfCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmQgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmRQb3MgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgSXRlck1vZGUsIE1vdW50ZWRUcmVlLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIE5vZGVXZWFrTWFwLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/css/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@lezer/css/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst descendantOp = 122,\n  Unit = 1,\n  identifier = 123,\n  callee = 124,\n  VariableName = 2,\n  queryIdentifier = 125,\n  queryVariableName = 3,\n  QueryCallee = 4;\n\n/* Hand-written tokenizers for CSS tokens that can't be\n   expressed by Lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,\n               8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];\nconst colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period = 46,\n      hash = 35, percent = 37, ampersand = 38, backslash = 92, newline = 10, asterisk = 42;\n\nfunction isAlpha(ch) { return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161 }\n\nfunction isDigit(ch) { return ch >= 48 && ch <= 57 }\n\nfunction isHex(ch) { return isDigit(ch) || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70 }\n\nconst identifierTokens = (id, varName, callee) => (input, stack) => {\n  for (let inside = false, dashes = 0, i = 0;; i++) {\n    let {next} = input;\n    if (isAlpha(next) || next == dash || next == underscore || (inside && isDigit(next))) {\n      if (!inside && (next != dash || i > 0)) inside = true;\n      if (dashes === i && next == dash) dashes++;\n      input.advance();\n    } else if (next == backslash && input.peek(1) != newline) {\n      input.advance();\n      if (isHex(input.next)) {\n        do { input.advance(); } while (isHex(input.next))\n        if (input.next == 32) input.advance();\n      } else if (input.next > -1) {\n        input.advance();\n      }\n      inside = true;\n    } else {\n      if (inside) input.acceptToken(\n        dashes == 2 && stack.canShift(VariableName) ? varName : next == parenL ? callee : id\n      );\n      break\n    }\n  }\n};\n\nconst identifiers = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(\n  identifierTokens(identifier, VariableName, callee)\n);\nconst queryIdentifiers = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(\n  identifierTokens(queryIdentifier, queryVariableName, QueryCallee)\n);\n\nconst descendant = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  if (space.includes(input.peek(-1))) {\n    let {next} = input;\n    if (isAlpha(next) || next == underscore || next == hash || next == period ||\n        next == asterisk || next == bracketL || next == colon && isAlpha(input.peek(1)) ||\n        next == dash || next == ampersand)\n      input.acceptToken(descendantOp);\n  }\n});\n\nconst unitToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  if (!space.includes(input.peek(-1))) {\n    let {next} = input;\n    if (next == percent) { input.advance(); input.acceptToken(Unit); }\n    if (isAlpha(next)) {\n      do { input.advance(); } while (isAlpha(input.next) || isDigit(input.next))\n      input.acceptToken(Unit);\n    }\n  }\n});\n\nconst cssHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"AtKeyword import charset namespace keyframes media supports\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"from to selector\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  NamespaceName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace,\n  KeyframeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  KeyframeRangeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  ClassName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  PseudoClassName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  IdName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  \"FeatureName PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  NumberLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  KeywordQuery: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  UnaryQueryOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"CallTag ValueName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  Callee: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  Unit: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.unit,\n  \"UniversalSelector NestingSelector\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  \"MatchOp CompareOp\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  \"ChildOp SiblingOp, LogicOp\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BinOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  Important: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  ColorLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.color,\n  \"ParenthesizedContent StringLiteral\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  \":\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"PseudoOp #\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \"; ,\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_callee = {__proto__:null,lang:38, \"nth-child\":38, \"nth-last-child\":38, \"nth-of-type\":38, \"nth-last-of-type\":38, dir:38, \"host-context\":38, if:84, url:124, \"url-prefix\":124, domain:124, regexp:124};\nconst spec_queryIdentifier = {__proto__:null,or:98, and:98, not:106, only:106, layer:170};\nconst spec_QueryCallee = {__proto__:null,selector:112, layer:166};\nconst spec_AtKeyword = {__proto__:null,\"@import\":162, \"@media\":174, \"@charset\":178, \"@namespace\":182, \"@keyframes\":188, \"@supports\":200, \"@scope\":204};\nconst spec_identifier = {__proto__:null,to:207};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a\",\n  stateData: \"Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~\",\n  goto: \"2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P\",\n  nodeNames: \"âš  Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles\",\n  maxTerm: 143,\n  nodeProps: [\n    [\"isolate\", -2,5,36,\"\"],\n    [\"openedBy\", 20,\"(\",28,\"[\",31,\"{\"],\n    [\"closedBy\", 21,\")\",29,\"]\",32,\"}\"]\n  ],\n  propSources: [cssHighlighting],\n  skippedNodes: [0,5,106],\n  repeatNodeCount: 15,\n  tokenData: \"JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q\",\n  tokenizers: [descendant, unitToken, identifiers, queryIdentifiers, 1, 2, 3, 4, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~\", 28, 129)],\n  topRules: {\"StyleSheet\":[0,6],\"Styles\":[1,105]},\n  specialized: [{term: 124, get: (value) => spec_callee[value] || -1},{term: 125, get: (value) => spec_queryIdentifier[value] || -1},{term: 4, get: (value) => spec_QueryCallee[value] || -1},{term: 25, get: (value) => spec_AtKeyword[value] || -1},{term: 123, get: (value) => spec_identifier[value] || -1}],\n  tokenPrec: 1963\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2Nzcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RTtBQUN0Qjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qix1QkFBdUI7O0FBRXZCLHFCQUFxQjs7QUFFckI7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQWlCO0FBQzlDO0FBQ0E7O0FBRUEsdUJBQXVCLHdEQUFpQjtBQUN4QztBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQix3REFBaUI7QUFDdkM7QUFDQSxTQUFTLE1BQU07QUFDZiwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0IsMkRBQVM7QUFDakMsaUVBQWlFLGtEQUFJO0FBQ3JFLHNCQUFzQixrREFBSTtBQUMxQixpQkFBaUIsa0RBQUk7QUFDckIsZ0JBQWdCLGtEQUFJO0FBQ3BCLHFCQUFxQixrREFBSTtBQUN6QixXQUFXLGtEQUFJO0FBQ2YsYUFBYSxrREFBSTtBQUNqQixtQkFBbUIsa0RBQUksVUFBVSxrREFBSTtBQUNyQyxVQUFVLGtEQUFJO0FBQ2QsOEJBQThCLGtEQUFJO0FBQ2xDLGlCQUFpQixrREFBSTtBQUNyQixpQkFBaUIsa0RBQUk7QUFDckIsZ0JBQWdCLGtEQUFJ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LElBQUksYUFBYSxLQUFLLEdBQUcsc0JBQXNCLEtBQUssR0FBRyxzQkFBc0IsS0FBSyxHQUFHLHNCQUFzQixLQUFLLEdBQUcsc0JBQXNCLEtBQUssR0FBRyxtQ0FBbUMsS0FBSyxHQUFHLGFBQWEsRUFBRTtBQUMxK0cscUZBQXFGLHNEQUFlLFdBQVc7QUFDL0csYUFBYSxvQ0FBb0M7QUFDakQsaUJBQWlCLG9EQUFvRCxFQUFFLDZEQUE2RCxFQUFFLHVEQUF1RCxFQUFFLHNEQUFzRCxFQUFFLHdEQUF3RDtBQUMvUztBQUNBLENBQUM7O0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtbGVhcm5pbmctcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY3NzL2Rpc3QvaW5kZXguanM/NmU3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlcm5hbFRva2VuaXplciwgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBkZXNjZW5kYW50T3AgPSAxMjIsXG4gIFVuaXQgPSAxLFxuICBpZGVudGlmaWVyID0gMTIzLFxuICBjYWxsZWUgPSAxMjQsXG4gIFZhcmlhYmxlTmFtZSA9IDIsXG4gIHF1ZXJ5SWRlbnRpZmllciA9IDEyNSxcbiAgcXVlcnlWYXJpYWJsZU5hbWUgPSAzLFxuICBRdWVyeUNhbGxlZSA9IDQ7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBDU1MgdG9rZW5zIHRoYXQgY2FuJ3QgYmVcbiAgIGV4cHJlc3NlZCBieSBMZXplcidzIGJ1aWx0LWluIHRva2VuaXplci4gKi9cblxuY29uc3Qgc3BhY2UgPSBbOSwgMTAsIDExLCAxMiwgMTMsIDMyLCAxMzMsIDE2MCwgNTc2MCwgODE5MiwgODE5MywgODE5NCwgODE5NSwgODE5NiwgODE5NyxcbiAgICAgICAgICAgICAgIDgxOTgsIDgxOTksIDgyMDAsIDgyMDEsIDgyMDIsIDgyMzIsIDgyMzMsIDgyMzksIDgyODcsIDEyMjg4XTtcbmNvbnN0IGNvbG9uID0gNTgsIHBhcmVuTCA9IDQwLCB1bmRlcnNjb3JlID0gOTUsIGJyYWNrZXRMID0gOTEsIGRhc2ggPSA0NSwgcGVyaW9kID0gNDYsXG4gICAgICBoYXNoID0gMzUsIHBlcmNlbnQgPSAzNywgYW1wZXJzYW5kID0gMzgsIGJhY2tzbGFzaCA9IDkyLCBuZXdsaW5lID0gMTAsIGFzdGVyaXNrID0gNDI7XG5cbmZ1bmN0aW9uIGlzQWxwaGEoY2gpIHsgcmV0dXJuIGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjEgfVxuXG5mdW5jdGlvbiBpc0RpZ2l0KGNoKSB7IHJldHVybiBjaCA+PSA0OCAmJiBjaCA8PSA1NyB9XG5cbmZ1bmN0aW9uIGlzSGV4KGNoKSB7IHJldHVybiBpc0RpZ2l0KGNoKSB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMDIgfHwgY2ggPj0gNjUgJiYgY2ggPD0gNzAgfVxuXG5jb25zdCBpZGVudGlmaWVyVG9rZW5zID0gKGlkLCB2YXJOYW1lLCBjYWxsZWUpID0+IChpbnB1dCwgc3RhY2spID0+IHtcbiAgZm9yIChsZXQgaW5zaWRlID0gZmFsc2UsIGRhc2hlcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICAgIGlmIChpc0FscGhhKG5leHQpIHx8IG5leHQgPT0gZGFzaCB8fCBuZXh0ID09IHVuZGVyc2NvcmUgfHwgKGluc2lkZSAmJiBpc0RpZ2l0KG5leHQpKSkge1xuICAgICAgaWYgKCFpbnNpZGUgJiYgKG5leHQgIT0gZGFzaCB8fCBpID4gMCkpIGluc2lkZSA9IHRydWU7XG4gICAgICBpZiAoZGFzaGVzID09PSBpICYmIG5leHQgPT0gZGFzaCkgZGFzaGVzKys7XG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09IGJhY2tzbGFzaCAmJiBpbnB1dC5wZWVrKDEpICE9IG5ld2xpbmUpIHtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGlmIChpc0hleChpbnB1dC5uZXh0KSkge1xuICAgICAgICBkbyB7IGlucHV0LmFkdmFuY2UoKTsgfSB3aGlsZSAoaXNIZXgoaW5wdXQubmV4dCkpXG4gICAgICAgIGlmIChpbnB1dC5uZXh0ID09IDMyKSBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPiAtMSkge1xuICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBpbnNpZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zaWRlKSBpbnB1dC5hY2NlcHRUb2tlbihcbiAgICAgICAgZGFzaGVzID09IDIgJiYgc3RhY2suY2FuU2hpZnQoVmFyaWFibGVOYW1lKSA/IHZhck5hbWUgOiBuZXh0ID09IHBhcmVuTCA/IGNhbGxlZSA6IGlkXG4gICAgICApO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGlkZW50aWZpZXJzID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKFxuICBpZGVudGlmaWVyVG9rZW5zKGlkZW50aWZpZXIsIFZhcmlhYmxlTmFtZSwgY2FsbGVlKVxuKTtcbmNvbnN0IHF1ZXJ5SWRlbnRpZmllcnMgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoXG4gIGlkZW50aWZpZXJUb2tlbnMocXVlcnlJZGVudGlmaWVyLCBxdWVyeVZhcmlhYmxlTmFtZSwgUXVlcnlDYWxsZWUpXG4pO1xuXG5jb25zdCBkZXNjZW5kYW50ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgaWYgKHNwYWNlLmluY2x1ZGVzKGlucHV0LnBlZWsoLTEpKSkge1xuICAgIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgICBpZiAoaXNBbHBoYShuZXh0KSB8fCBuZXh0ID09IHVuZGVyc2NvcmUgfHwgbmV4dCA9PSBoYXNoIHx8IG5leHQgPT0gcGVyaW9kIHx8XG4gICAgICAgIG5leHQgPT0gYXN0ZXJpc2sgfHwgbmV4dCA9PSBicmFja2V0TCB8fCBuZXh0ID09IGNvbG9uICYmIGlzQWxwaGEoaW5wdXQucGVlaygxKSkgfHxcbiAgICAgICAgbmV4dCA9PSBkYXNoIHx8IG5leHQgPT0gYW1wZXJzYW5kKVxuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oZGVzY2VuZGFudE9wKTtcbiAgfVxufSk7XG5cbmNvbnN0IHVuaXRUb2tlbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGlmICghc3BhY2UuaW5jbHVkZXMoaW5wdXQucGVlaygtMSkpKSB7XG4gICAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICAgIGlmIChuZXh0ID09IHBlcmNlbnQpIHsgaW5wdXQuYWR2YW5jZSgpOyBpbnB1dC5hY2NlcHRUb2tlbihVbml0KTsgfVxuICAgIGlmIChpc0FscGhhKG5leHQpKSB7XG4gICAgICBkbyB7IGlucHV0LmFkdmFuY2UoKTsgfSB3aGlsZSAoaXNBbHBoYShpbnB1dC5uZXh0KSB8fCBpc0RpZ2l0KGlucHV0Lm5leHQpKVxuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oVW5pdCk7XG4gICAgfVxuICB9XG59KTtcblxuY29uc3QgY3NzSGlnaGxpZ2h0aW5nID0gc3R5bGVUYWdzKHtcbiAgXCJBdEtleXdvcmQgaW1wb3J0IGNoYXJzZXQgbmFtZXNwYWNlIGtleWZyYW1lcyBtZWRpYSBzdXBwb3J0c1wiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImZyb20gdG8gc2VsZWN0b3JcIjogdGFncy5rZXl3b3JkLFxuICBOYW1lc3BhY2VOYW1lOiB0YWdzLm5hbWVzcGFjZSxcbiAgS2V5ZnJhbWVOYW1lOiB0YWdzLmxhYmVsTmFtZSxcbiAgS2V5ZnJhbWVSYW5nZU5hbWU6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBUYWdOYW1lOiB0YWdzLnRhZ05hbWUsXG4gIENsYXNzTmFtZTogdGFncy5jbGFzc05hbWUsXG4gIFBzZXVkb0NsYXNzTmFtZTogdGFncy5jb25zdGFudCh0YWdzLmNsYXNzTmFtZSksXG4gIElkTmFtZTogdGFncy5sYWJlbE5hbWUsXG4gIFwiRmVhdHVyZU5hbWUgUHJvcGVydHlOYW1lXCI6IHRhZ3MucHJvcGVydHlOYW1lLFxuICBBdHRyaWJ1dGVOYW1lOiB0YWdzLmF0dHJpYnV0ZU5hbWUsXG4gIE51bWJlckxpdGVyYWw6IHRhZ3MubnVtYmVyLFxuICBLZXl3b3JkUXVlcnk6IHRhZ3Mua2V5d29yZCxcbiAgVW5hcnlRdWVyeU9wOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJDYWxsVGFnIFZhbHVlTmFtZVwiOiB0YWdzLmF0b20sXG4gIFZhcmlhYmxlTmFtZTogdGFncy52YXJpYWJsZU5hbWUsXG4gIENhbGxlZTogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFVuaXQ6IHRhZ3MudW5pdCxcbiAgXCJVbml2ZXJzYWxTZWxlY3RvciBOZXN0aW5nU2VsZWN0b3JcIjogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIFwiTWF0Y2hPcCBDb21wYXJlT3BcIjogdGFncy5jb21wYXJlT3BlcmF0b3IsXG4gIFwiQ2hpbGRPcCBTaWJsaW5nT3AsIExvZ2ljT3BcIjogdGFncy5sb2dpY09wZXJhdG9yLFxuICBCaW5PcDogdGFncy5hcml0aG1ldGljT3BlcmF0b3IsXG4gIEltcG9ydGFudDogdGFncy5tb2RpZmllcixcbiAgQ29tbWVudDogdGFncy5ibG9ja0NvbW1lbnQsXG4gIENvbG9yTGl0ZXJhbDogdGFncy5jb2xvcixcbiAgXCJQYXJlbnRoZXNpemVkQ29udGVudCBTdHJpbmdMaXRlcmFsXCI6IHRhZ3Muc3RyaW5nLFxuICBcIjpcIjogdGFncy5wdW5jdHVhdGlvbixcbiAgXCJQc2V1ZG9PcCAjXCI6IHRhZ3MuZGVyZWZPcGVyYXRvcixcbiAgXCI7ICxcIjogdGFncy5zZXBhcmF0b3IsXG4gIFwiKCApXCI6IHRhZ3MucGFyZW4sXG4gIFwiWyBdXCI6IHRhZ3Muc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogdGFncy5icmFjZVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19jYWxsZWUgPSB7X19wcm90b19fOm51bGwsbGFuZzozOCwgXCJudGgtY2hpbGRcIjozOCwgXCJudGgtbGFzdC1jaGlsZFwiOjM4LCBcIm50aC1vZi10eXBlXCI6MzgsIFwibnRoLWxhc3Qtb2YtdHlwZVwiOjM4LCBkaXI6MzgsIFwiaG9zdC1jb250ZXh0XCI6MzgsIGlmOjg0LCB1cmw6MTI0LCBcInVybC1wcmVmaXhcIjoxMjQsIGRvbWFpbjoxMjQsIHJlZ2V4cDoxMjR9O1xuY29uc3Qgc3BlY19xdWVyeUlkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsb3I6OTgsIGFuZDo5OCwgbm90OjEwNiwgb25seToxMDYsIGxheWVyOjE3MH07XG5jb25zdCBzcGVjX1F1ZXJ5Q2FsbGVlID0ge19fcHJvdG9fXzpudWxsLHNlbGVjdG9yOjExMiwgbGF5ZXI6MTY2fTtcbmNvbnN0IHNwZWNfQXRLZXl3b3JkID0ge19fcHJvdG9fXzpudWxsLFwiQGltcG9ydFwiOjE2MiwgXCJAbWVkaWFcIjoxNzQsIFwiQGNoYXJzZXRcIjoxNzgsIFwiQG5hbWVzcGFjZVwiOjE4MiwgXCJAa2V5ZnJhbWVzXCI6MTg4LCBcIkBzdXBwb3J0c1wiOjIwMCwgXCJAc2NvcGVcIjoyMDR9O1xuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLHRvOjIwN307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiRWJRWVFkT09PI3FRZE9PUCN4T2BPT09PUVAnI0NmJyNDZk9PUVAnI0NlJyNDZU8jfVFkTycjQ2hPJG5RYU8nI0NjTyR4UWRPJyNDa08lVFFkTycjRHBPJVlRZE8nI0RyTyVfUWRPJyNEdU8lX1FkTycjRHhPT1FQJyNGVicjRlZPJmVRaE8nI0VoT09RUycjRlUnI0ZVT09RUycjRWsnI0VrUVlRZE9PTyZsUWRPJyNFT08mUFFoTycjRVVPJmxRZE8nI0VXTydhUWRPJyNFWU8nbFFkTycjRV1PJ3RRaE8nI0VjTyhWUWRPJyNFZU8oYlFhTycjQ2ZPKVZRYE8nI0R7TylbUWBPJyNGYE8pZ1FkTycjRmBRT1FgT09QKXFPJmpPJyNDYVBPT08pQ0B0KUNAdE9PUVAnI0NqJyNDak9PUVAsNTlTLDU5U08jfVFkTyw1OVNPKXxRZE8sNTlWTyVUUWRPLDU6W08lWVFkTyw1Ol5PJV9RZE8sNTphTyVfUWRPLDU6Y08lX1FkTyw1OmRPJV9RZE8nI0VyTypYUWBPLDU4fU8qYVFkTycjRHpPT1FTLDU4fSw1OH1PT1FQJyNDbicjQ25PT1FPJyNEbicjRG5PT1FQLDU5Viw1OVZPKmhRYE8sNTlWTyptUWBPLDU5Vk9PUVAnI0RxJyNEcU9PUVAsNTpbLDU6W09PUU8nI0RzJyNEc08qclFwTyw1Ol5PK11RYU8sNTphTytzUWFPLDU6ZE9PUVcnI0RaJyNEWk8sWlFoTycjRGRPLHhRaE8nI0ZhTyd0UWhPJyNEYk8tV1FgTycjRGhPT1FXJyNGWycjRltPLV1RYE8sNTtTTy1lUWBPJyNEZU9PUVMtRThpLUU4aU9PUVsnI0NzJyNDc08talFkTycjQ3RPLlFRZE8nI0N6Ty5oUWRPJyNDfU8vT1EhcE8nI0RQTzFSUSFqTyw1OmpPT1FPJyNEVScjRFVPKm1RYE8nI0RUTzFjUSFuTycjRlhPM2BRYE8nI0RWTzNlUWBPJyNEa09PUVsnI0ZYJyNGWE8tYFFgTyw1OnBPM2pRIWJPLDU6ck9PUVMnI0VbJyNFW08zclFgTyw1OnRPM3dRZE8sNTp0T09RTycjRV8nI0VfTzRQUWBPLDU6d080VVFoTyw1On1PJV9RZE8nI0RnT09RUyw1O1AsNTtQTy1lUWBPLDU7UE80XlFkTyw1O1BPNGZRZE8sNTpnTzR2UWRPJyNFdE81VFFgTyw1O3pPNVRRYE8sNTt6UE9PTycjRWonI0VqUDVgTyZqTyw1OHtQT09PLDU4eyw1OHtPT1FQMUcubjFHLm5PT1FQMUcucTFHLnFPKmhRYE8xRy5xTyptUWBPMUcucU9PUVAxRy92MUcvdk81a1FwTzFHL3hPNXNRYU8xRy97TzZaUWFPMUcvfU82cVFhTzFHME9PN1hRYU8sNTteT09RTy1FOHAtRThwT09RUzFHLmkxRy5pTzdjUWBPLDU6Zk83aFFkTycjRG9PN29RZE8nI0NyT09RUDFHL3gxRy94TyZsUWRPMUcveE83dlEhak8nI0RaTzhVUSFiTyw1OXZPOF5RaE8sNTpPT09RTycjRl0nI0ZdTzhYUSFiTyw1OXpPJ3RRaE8sNTl4TzhmUWhPJyNFdk84c1FgTyw1O3tPOU9RaE8sNTl8Tzl1UWhPJyNEaU9PUVcsNTpTLDU6U09PUVMxRzBuMUcwbk9PUVcsNTpQLDU6UE85fFEhZk8nI0ZZT09RUycjRlknI0ZZT09RUycjRW0nI0VtTzteUWRPLDU5YE9PUVssNTlgLDU5YE87dFFkTyw1OWZPT1FbLDU5Ziw1OWZPPFtRZE8sNTlpT09RWyw1OWksNTlpT09RWyw1OWssNTlrTyZsUWRPLDU5bU88clFoTycjRVFPT1FXJyNFUScjRVFPPVdRYE8xRzBVTzFbUWhPMUcwVU9PUVssNTlvLDU5b08ndFFoTycjRFhPT1FbLDU5cSw1OXFPPV1RI3RPLDU6Vk9PUVMxRzBbMUcwW09PUVMxRzBeMUcwXk9PUVMxRzBgMUcwYE89aFFgTzFHMGBPPW1RZE8nI0VgT09RUzFHMGMxRzBjT09RUzFHMGkxRzBpTz14UWFPLDU6Uk8tYFFgTzFHMGtPT1FTMUcwazFHMGtPLWVRYE8xRzBrTz5QUSFmTzFHMFJPT1FPMUcwUjFHMFJPT1FPLDU7YCw1O2BPPmdRZE8sNTtgT09RTy1FOHItRThyTz50UWBPMUcxZlBPT08tRThoLUU4aFBPT08xRy5nMUcuZ09PUVA3KyRdNyskXU9PUVA3KyVkNyslZE8mbFFkTzcrJWRPT1FTMUcwUTFHMFFPP1BRYU8nI0ZfTz9aUWBPLDU6Wk8/YFEhZk8nI0VsT0BeUWRPJyNGV09AaFFgTyw1OV5PQG1RIWJPNyslZE8mbFFkTzFHL2JPQHVRaE8xRy9mT09RVzFHL2oxRy9qT09RVzFHL2QxRy9kT0FXUWhPLDU7Yk9PUU8tRTh0LUU4dE9BZlFoTycjRFpPQXRRaE8nI0ZeT0JQUWBPJyNGXk9CVVFgTyw1OlRPT1FTLUU4ay1FOGtPT1FbMUcuejFHLnpPT1FbMUcvUTFHL1FPT1FbMUcvVDFHL1RPT1FbMUcvWDFHL1hPQlpRZE8sNTpsT09RUzcrJXA3KyVwT0JgUWBPNyslcE9CZVFoTycjRFlPQm1RYE8sNTlzTyd0UWhPLDU5c09PUVsxRy9xMUcvcU9CdVFgTzFHL3FPT1FTNyslejcrJXpPQnpRYk8nI0RQT09RTycjRWInI0ViT0NZUWBPJyNFYU9PUU8nI0VhJyNFYU9DZVFgTycjRXdPQ21RZE8sNTp6T09RUyw1OnosNTp6T09RWzFHL20xRy9tT09RUzcrJlY3KyZWTy1gUWBPNysmVk9DeFEhZk8nI0VzTyZsUWRPJyNFc09FUFFkTzcrJW1PT1FPNyslbTcrJW1PT1FPMUcwejFHMHpPRWRRIWJPPDxJT09FbFFkTycjRXFPRXZRYE8sNTt5T09RUDFHL3UxRy91T09RUy1FOGotRThqT0ZPUWRPJyNFcE9GWVFgTyw1O3JPT1FdMUcueDFHLnhPT1FQPDxJTzw8SU9PRmJRZE83KyR8T09RTycjRF0nI0RdT0ZpUSFiTzcrJVFPRnFRaE8nI0VvT0Z7UWBPLDU7eE8mbFFkTyw1O3hPT1FXMUcvbzFHL29PT1FPJyNFUycjRVNPR1RRYE8xRzBXT09RUzw8SVs8PElbTyZsUWRPLDU5dE9HblFoTzFHL19PT1FbMUcvXzFHL19PR3VRYE8xRy9fT09RVy1FOGwtRThsT09RWzcrJV03KyVdT09RTyw1OnssNTp7Tz1wUWRPJyNFeE9DZVFgTyw1O2NPT1FTLDU7Yyw1O2NPT1FTLUU4dS1FOHVPT1FTMUcwZjFHMGZPT1FTPDxJcTw8SXFPR31RIWZPLDU7X09PUVMtRThxLUU4cU9PUU88PElYPDxJWE9PUVBBTj5qQU4+ak9JVVFhTyw1O11PT1FPLUU4by1FOG9PSWBRZE8sNTtbT09RTy1FOG4tRThuT09RVzw8SGg8PEhoT09RVzw8SGw8PEhsT0lqUWhPPDxIbE9Je1FoTyw1O1pPSldRYE8sNTtaT09RTy1FOG0tRThtT0pdUWRPMUcxZE9CWlFkTycjRXVPSmdRYE83KyVyT09RVzcrJXI3KyVyT0pvUSFiTzFHL2BPT1FbNyskeTcrJHlPSnpRaE83KyR5UEtSUWBPJyNFbk9PUU8sNTtkLDU7ZE9PUU8tRTh2LUU4dk9PUVMxRzB9MUcwfU9LV1FgT0FOPldPJmxRZE8xRzB1T0tdUWBPNysnT09PUU8sNTthLDU7YU9PUU8tRThzLUU4c09PUVc8PElePDxJXk9PUVs8PEhlPDxIZVBPUVcsNTtZLDU7WU9PUVdHMjNyRzIzck9LZVFkTzcrJmFcIixcbiAgc3RhdGVEYXRhOiBcIkt4fk8jc09TI3RRUX5PV1tPWltPXVRPYFZPYVZPaV1PaldPbVhPIWpZTyFtWk8hc2FPIXliTyF7Y08hfWRPI1FlTyNXZk8jWWdPI29ST35PUWlPV1tPWltPXVRPYFZPYVZPaV1PaldPbVhPIWpZTyFtWk8hc2FPIXliTyF7Y08hfWRPI1FlTyNXZk8jWWdPI29oT35PI20kU1B+UCFkTyN0bU9+TyNvb09+T11xT2ByT2FyT2pzT210TyFqdU8hbXdPI252T35PcHpPIV54T35QJFNPYyFRTyNvfE8jcH1Pfk8jbyFST35PI28hVE9+T1dbT1pbT11UT2BWT2FWT2pXT21YTyFqWU8hbVpPI29ST35PUyFdT2UhWU8hViFbTyFZIWBPI3EhWE9wJFRQfk9rJFRQflAmUE9RIWpPZSFjT20hZE9wIWVPciFtT3QhbU96IWtPIWAhbE8jbyFiTyNwIWhPI30hZk9+T3QhcU8hYCFsTyNvIXBPfk90IXNPI28hc09+T1MhXU9lIVlPIVYhW08hWSFgTyNxIVhPfk9lIXZPcHpPI1oheE9+T11ZWGBZWGAhcFhhWVhqWVhtWVhwWVghXllYIWpZWCFtWVgjbllYfk9gIXpPfk9rIXtPI20kU1hvJFNYfk8jbSRTWG8kU1h+UCFkTyN1I09PI3YjT08jdyNRT35PYyNVTyNvfE8jcH1Pfk9wek8hXnhPfk9vJFNQflAhZE9lI2BPfk9lI2FPfk9sI2JPIWgjY09+T11xT2ByT2FyT2pzT210T35PcCFpYSFeIWlhIWohaWEhbSFpYSNuIWlhZCFpYX5QKnpPcCFsYSFeIWxhIWohbGEhbSFsYSNuIWxhZCFsYX5QKnpPUiNnT1MhXU9lIVlPciNnT3QjZ08hViFbTyFZIWBPI3EjZE8jfSFmT35PIVIjaU8hXiNqT2skVFhwJFRYfk9lI21Pfk9rI29PcHpPfk9lIXZPfk9dI3JPYCNyT2QjdU9pI3JPaiNyT2sjck9+UCZsT10jck9gI3JPaSNyT2ojck9rI3JPbCN3T35QJmxPXSNyT2Ajck9pI3JPaiNyT2sjck9vI3lPflAmbE9QI3pPU3NYZXNYa3NYdnNYIVZzWCFZc1ghdXNYIXdzWCNxc1ghVHNYUXNYXXNYYHNYZHNYaXNYanNYbXNYcHNYcnNYdHNYenNYIWBzWCNvc1gjcHNYI31zWGxzWG9zWCFec1ghcXNYI21zWH5PdiN7TyF1I3xPIXcjfU9rJFRQflAndE9lI2FPUyN7WGsje1h2I3tYIVYje1ghWSN7WCF1I3tYIXcje1gjcSN7WFEje1hdI3tYYCN7WGQje1hpI3tYaiN7WG0je1hwI3tYciN7WHQje1h6I3tYIWAje1gjbyN7WCNwI3tYI30je1hsI3tYbyN7WCFeI3tYIXEje1gjbSN7WH5PZSRST35PZSRUT35PayRWT3Yje09+T2skV09+T3QkWE8hYCFsT35PcCRZT35PcHpPIVIjaU9+T3B6TyNaJGBPfk8hcSRiT2shb2EjbSFvYW8hb2F+UCZsT2sjaFgjbSNoWG8jaFh+UCFkT2she08jbSRTYW8kU2F+TyN1I09PI3YjT08jdyRoT35PbCRqTyFoJGtPfk9wIWlpIV4haWkhaiFpaSFtIWlpI24haWlkIWlpflAqek9wIWtpIV4ha2khaiFraSFtIWtpI24ha2lkIWtpflAqek9wIWxpIV4hbGkhaiFsaSFtIWxpI24hbGlkIWxpflAqek9wI2ZhIV4jZmF+UCRTT28kbE9+T2QkUlB+UCVfT2QjelB+UCZsT2AhUFhkfVghUn1YIVQhUFh+T2Akc08hVCR0T35PZCR1TyFSI2lPfk9rI2pYcCNqWCFeI2pYflAndE8hXiNqT2skVGFwJFRhfk8hUiNpT2shVWFwIVVhIV4hVWFkIVVhYCFVYX5PUyFdT2UhWU8hViFbTyFZIWBPI3EkeU9+T2QkUVB+UDlkT3Yje09RI3xYXSN8WGAjfFhkI3xYZSN8WGkjfFhqI3xYayN8WG0jfFhwI3xYciN8WHQjfFh6I3xYIWAjfFgjbyN8WCNwI3xYI30jfFhsI3xYbyN8WH5PXSNyT2Ajck9kJU9PaSNyT2ojck9rI3JPflAmbE9dI3JPYCNyT2kjck9qI3JPayNyT2wlUE9+UCZsT10jck9gI3JPaSNyT2ojck9rI3JPbyVRT35QJmxPZSVTT1MhdFhrIXRYIVYhdFghWSF0WCNxIXRYfk9rJVRPfk9kJVlPdCVaTyFhJVpPfk9rJVtPfk9vJWNPI28lXk8jfSVdT35PZCVkT35QJFNPdiN7TyFeJWhPIXElak9rIW9pI20hb2lvIW9pflAmbE9rI2hhI20jaGFvI2hhflAhZE9rIXtPI20kU2lvJFNpfk8hXiVtT2QkUlh+UCRTT2Qlb09+T3Yje09RI2BYZCNgWGUjYFhtI2BYcCNgWHIjYFh0I2BYeiNgWCFeI2BYIWAjYFgjbyNgWCNwI2BYI30jYFh+TyFeJXFPZCN6WH5QJmxPZCVzT35PbCV0T3Yje09+T1IjZ09yI2dPdCNnTyNxJXZPI30hZk9+TyFSI2lPayNqYXAjamEhXiNqYX5PYCFQWGR9WCFSfVghXn1Yfk8hUiNpTyFeJXhPZCRRWH5PYCV6T35PZCV7T35PI28lfE9+T2smT09+T2AmUE8hUiNpT35PZCZST2smUU9+T2QmVU9+T1Ajek9wc1ghXnNYZHNYfk8jfSVdT3AjVFghXiNUWH5PcHpPIV4mV09+T28mW08jbyVeTyN9JV1Pfk92I3tPUSNnWGUjZ1hrI2dYbSNnWHAjZ1hyI2dYdCNnWHojZ1ghXiNnWCFgI2dYIXEjZ1gjbSNnWCNvI2dYI3AjZ1gjfSNnWG8jZ1h+TyFeJWhPIXEmYE9rIW9xI20hb3FvIW9xflAmbE9sJmFPdiN7T35PZCNlWCFeI2VYflAlX08hXiVtT2QkUmF+T2QjZFghXiNkWH5QJmxPIV4lcU9kI3phfk9kJmZPflAmbE9kJmdPIVQmaE9+T2QjY1ghXiNjWH5QOWRPIV4leE9kJFFhfk9dJm1PZCZvT35PUyNiYWUjYmEhViNiYSFZI2JhI3EjYmF+T2QmcU9+UEddT2QmcU9rJnJPfk92I3tPUSNnYWUjZ2FrI2dhbSNnYXAjZ2FyI2dhdCNnYXojZ2EhXiNnYSFgI2dhIXEjZ2EjbSNnYSNvI2dhI3AjZ2EjfSNnYW8jZ2F+T2QjZWEhXiNlYX5QJFNPZCNkYSFeI2RhflAmbE9SI2dPciNnT3QjZ08jcSV2TyN9JV1Pfk8hUiNpT2QjY2EhXiNjYX5PYCZ4T35PIV4leE9kJFFpflAmbE9dJm1PZCZ8T35PdiN7T2R8aWt8aX5PZCZ9T35QR11PaydPT35PZCdQT35PIV4leE9kJFFxfk9kI2NxIV4jY3F+UCZsTyNzIWEjdCN9XSN9diFtflwiLFxuICBnb3RvOiBcIjJoJFVQUFBQUCRWUCRZUCRjJHVQJGNQJVgkY1BQJV9QUFAlZSVvJW9QUFBQUCVvUFAlb1AmXVAlb1AlbydXJW9QJ3Qndyd9J30oXid9UCd9UCd9UCd9J31QKG0nfSh5UCh8UFApcCl2JGMpfCRjKlNQJGNQJGMkY1AqWSp7K1lQJFlQK2FQK2RQJFlQJFlQJFlQK2okWVArbStwK3MreiRZUCRZUFAkWVAsUCxWLGYsfC1bLWItbC1yLXguTy5VLmAuZi5sLnJQUFBQUFBQUFBQUC54L1Ivdy96MHxQMVUxdTJPMlIyVTJbUm5RX15PUGBreiF7JGRxW09QWVpga3V2d3h6IXYheyNgJGQlbXFTT1BZWmBrdXZ3eHohdiF7I2AkZCVtUXBUUiNScVEhT1ZSI1NyUSNTIVFTJFEhaSFqUiRpI1UhViFtYWMhYyFkIWUheiNhI2MjdCN2I3gjeyRhJGskcCRzJWglaSVxJXUleiZQJmQmbCZ4J1EhVSFtYWMhYyFkIWUheiNhI2MjdCN2I3gjeyRhJGskcCRzJWglaSVxJXUleiZQJmQmbCZ4J1FVI2chWSR0JmhVJWAkWSViJldSJlYlXyFWIWlhYyFjIWQhZSF6I2EjYyN0I3YjeCN7JGEkayRwJHMlaCVpJXEldSV6JlAmZCZsJngnUVIkUyFrUSVXJFJSJlMlWGshXl1iZiFZIVshZyNpI2ojbSRQJFIlWCV4USNlIVlRJHsjbVEldyR0USZqJXhSJncmaFEheWdRI3AhYFEkXiF4UiVmJGBSI24hXSFVIW1hYyFjIWQhZSF6I2EjYyN0I3YjeCN7JGEkayRwJHMlaCVpJXEldSV6JlAmZCZsJngnUVEhcWRSJFghclEhUFZSI1RyUSNTIVBSJGkjVFEhU1dSI1ZzUSFVWFIjV3RRe1VRIXdnUSNeeVEjbyFfUSRVIW5RJFshdVEkXyF5USVlJF5RJlklYVEmXSVmUiZ2JlhTalB6USF9a1EkYyF7UiVrJGRaaVBreiF7JGRSJFAhZ1ElfSVTUiZ6Jm1SIXJkUiF0ZVIkWiF0UyVhJFklYlImdCZXViVfJFklYiZXUSNQbVIkZyNQUWBPU2tQelUhYWBrJGRSJGQhe1EkcCNhWSVwJHAldSZkJmwnUVEldSRzUSZkJXFRJmwlelInUSZ4USN0IWNRI3YhZFEjeCFlViR9I3QjdiN4USVYJFJSJlQlWFEleSR6UyZrJXkmeVImeSZsUSVyJHBSJmUlclElbiRtUiZjJW5ReVVSI115USVpJGFSJl8laVEhfGpTJGUhfCRmUiRmIX1RJm4lfVImeyZuUSNrIVpSJHgja1ElYiRZUiZaJWJRJlglYVImdSZYX19PUGBreiF7JGReVU9QYGt6IXskZFEhVllRIVdaUSNYdVEjWXZRI1p3USNbeFEkXSF2USRtI2BSJmIlbVIkcSNhUSFnYVEhb2NbI3EhYyFkIWUjdCN2I3hRJGEhemQkbyNhJHAkcyVxJXUleiZkJmwmeCdRUSRyI2NRJVIje1MlZyRhJWlRJWwka1EmXiVoUiZwJlBdI3MhYyFkIWUjdCN2I3hXIVpdYiFnJFBRIXVmUSNmIVlRI2whW1EkdiNpUSR3I2pRJHojbVMlViRSJVhSJmkleFEjaCFZUSV3JHRSJncmaFIkfCNtUiRuI2BRbFBSI196USFfXVEhbmJRJE8hZ1IlVSRQXCIsXG4gIG5vZGVOYW1lczogXCLimqAgVW5pdCBWYXJpYWJsZU5hbWUgVmFyaWFibGVOYW1lIFF1ZXJ5Q2FsbGVlIENvbW1lbnQgU3R5bGVTaGVldCBSdWxlU2V0IFVuaXZlcnNhbFNlbGVjdG9yIFRhZ1NlbGVjdG9yIFRhZ05hbWUgTmVzdGluZ1NlbGVjdG9yIENsYXNzU2VsZWN0b3IgLiBDbGFzc05hbWUgUHNldWRvQ2xhc3NTZWxlY3RvciA6IDo6IFBzZXVkb0NsYXNzTmFtZSBQc2V1ZG9DbGFzc05hbWUgKSAoIEFyZ0xpc3QgVmFsdWVOYW1lIFBhcmVudGhlc2l6ZWRWYWx1ZSBBdEtleXdvcmQgIyA7IF0gWyBCcmFja2V0ZWRWYWx1ZSB9IHsgQnJhY2VkVmFsdWUgQ29sb3JMaXRlcmFsIE51bWJlckxpdGVyYWwgU3RyaW5nTGl0ZXJhbCBCaW5hcnlFeHByZXNzaW9uIEJpbk9wIENhbGxFeHByZXNzaW9uIENhbGxlZSBJZkV4cHJlc3Npb24gaWYgQXJnTGlzdCBJZkJyYW5jaCBLZXl3b3JkUXVlcnkgRmVhdHVyZVF1ZXJ5IEZlYXR1cmVOYW1lIEJpbmFyeVF1ZXJ5IExvZ2ljT3AgQ29tcGFyaXNvblF1ZXJ5IENvbXBhcmVPcCBVbmFyeVF1ZXJ5IFVuYXJ5UXVlcnlPcCBQYXJlbnRoZXNpemVkUXVlcnkgU2VsZWN0b3JRdWVyeSBzZWxlY3RvciBQYXJlbnRoZXNpemVkU2VsZWN0b3IgQ2FsbFF1ZXJ5IEFyZ0xpc3QgLCBDYWxsTGl0ZXJhbCBDYWxsVGFnIFBhcmVudGhlc2l6ZWRDb250ZW50IFBzZXVkb0NsYXNzTmFtZSBBcmdMaXN0IElkU2VsZWN0b3IgSWROYW1lIEF0dHJpYnV0ZVNlbGVjdG9yIEF0dHJpYnV0ZU5hbWUgTWF0Y2hPcCBDaGlsZFNlbGVjdG9yIENoaWxkT3AgRGVzY2VuZGFudFNlbGVjdG9yIFNpYmxpbmdTZWxlY3RvciBTaWJsaW5nT3AgQmxvY2sgRGVjbGFyYXRpb24gUHJvcGVydHlOYW1lIEltcG9ydGFudCBJbXBvcnRTdGF0ZW1lbnQgaW1wb3J0IExheWVyIGxheWVyIExheWVyTmFtZSBsYXllciBNZWRpYVN0YXRlbWVudCBtZWRpYSBDaGFyc2V0U3RhdGVtZW50IGNoYXJzZXQgTmFtZXNwYWNlU3RhdGVtZW50IG5hbWVzcGFjZSBOYW1lc3BhY2VOYW1lIEtleWZyYW1lc1N0YXRlbWVudCBrZXlmcmFtZXMgS2V5ZnJhbWVOYW1lIEtleWZyYW1lTGlzdCBLZXlmcmFtZVNlbGVjdG9yIEtleWZyYW1lUmFuZ2VOYW1lIFN1cHBvcnRzU3RhdGVtZW50IHN1cHBvcnRzIFNjb3BlU3RhdGVtZW50IHNjb3BlIHRvIEF0UnVsZSBTdHlsZXNcIixcbiAgbWF4VGVybTogMTQzLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC0yLDUsMzYsXCJcIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjAsXCIoXCIsMjgsXCJbXCIsMzEsXCJ7XCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIDIxLFwiKVwiLDI5LFwiXVwiLDMyLFwifVwiXVxuICBdLFxuICBwcm9wU291cmNlczogW2Nzc0hpZ2hsaWdodGluZ10sXG4gIHNraXBwZWROb2RlczogWzAsNSwxMDZdLFxuICByZXBlYXROb2RlQ291bnQ6IDE1LFxuICB0b2tlbkRhdGE6IFwiSlF+UiFZT1gkcVheJWlecCRxcHElaXFyKHtycy11c3QvaXR1Nld1diRxdnc3UXd4N2N4eTlReXo5Y3p7OWh7fDpSfH0+dH0hTz9WIU8hUD90IVAhUUBdIVEhW0FVIVshXUJQIV0hXkJ7IV4hX0NeIV8hYERZIWAhYURtIWEhYiRxIWIhY0VuIWMhfSRxIX0jT0d7I08jUCRxI1AjUUheI1EjUjZXI1IjbyRxI28jcEhvI3AjcTZXI3EjcklRI3Ijc0ljI3MjeSRxI3kjeiVpI3okZiRxJGYkZyVpJGcjQlkkcSNCWSNCWiVpI0JaJElTJHEkSVMkSV8laSRJXyRJfCRxJEl8JEpPJWkkSk8kSlQkcSRKVCRKVSVpJEpVJEtWJHEkS1YkS1claSRLVyZGVSRxJkZVJkZWJWkmRlY7J1MkcTsnUzs9YEl6PCVsTyRxYCR0U095JVF6OydTJVE7J1M7PWAlYzwlbE8lUWAlVlMhYWBPeSVRejsnUyVROydTOz1gJWM8JWxPJVFgJWZQOz1gPCVsJVF+JW5oI3N+T1glUVheJ1lecCVRcHEnWXF5JVF6I3klUSN5I3onWSN6JGYlUSRmJGcnWSRnI0JZJVEjQlkjQlonWSNCWiRJUyVRJElTJElfJ1kkSV8kSXwlUSRJfCRKTydZJEpPJEpUJVEkSlQkSlUnWSRKVSRLViVRJEtWJEtXJ1kkS1cmRlUlUSZGVSZGVidZJkZWOydTJVE7J1M7PWAlYzwlbE8lUX4nYWgjc34hYWBPWCVRWF4nWV5wJVFwcSdZcXklUXojeSVRI3kjeidZI3okZiVRJGYkZydZJGcjQlklUSNCWSNCWidZI0JaJElTJVEkSVMkSV8nWSRJXyRJfCVRJEl8JEpPJ1kkSk8kSlQlUSRKVCRKVSdZJEpVJEtWJVEkS1YkS1cnWSRLVyZGVSVRJkZVJkZWJ1kmRlY7J1MlUTsnUzs9YCVjPCVsTyVRailPVU95JVF6I10lUSNdI14pYiNeOydTJVE7J1M7PWAlYzwlbE8lUWopZ1UhYWBPeSVReiNhJVEjYSNiKXkjYjsnUyVROydTOz1gJWM8JWxPJVFqKk9VIWFgT3klUXojZCVRI2QjZSpiI2U7J1MlUTsnUzs9YCVjPCVsTyVRaipnVSFhYE95JVF6I2MlUSNjI2QqeSNkOydTJVE7J1M7PWAlYzwlbE8lUWorT1UhYWBPeSVReiNmJVEjZiNnK2IjZzsnUyVROydTOz1gJWM8JWxPJVFqK2dVIWFgT3klUXojaCVRI2gjaSt5I2k7J1MlUTsnUzs9YCVjPCVsTyVRaixPVSFhYE95JVF6I1QlUSNUI1UsYiNVOydTJVE7J1M7PWAlYzwlbE8lUWosZ1UhYWBPeSVReiNiJVEjYiNjLHkjYzsnUyVROydTOz1gJWM8JWxPJVFqLU9VIWFgT3klUXojaCVRI2gjaS1iI2k7J1MlUTsnUzs9YCVjPCVsTyVRai1pUyFxWSFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUX4teFdPWS11WnItdXJzLmJzI08tdSNPI1AuZyNQOydTLXU7J1M7PWAvYzwlbE8tdX4uZ090fn4ualJPOydTLXU7J1M7PWAuczs9YE8tdX4udlhPWS11WnItdXJzLmJzI08tdSNPI1AuZyNQOydTLXU7J1M7PWAvYzs9YDwlbC11PCVsTy11fi9mUDs9YDwlbC11ai9uWWpZT3klUXohUSVRIVEhWzBeIVshYyVRIWMhaTBeIWkjVCVRI1QjWjBeI1o7J1MlUTsnUzs9YCVjPCVsTyVRajBjWSFhYE95JVF6IVElUSFRIVsxUiFbIWMlUSFjIWkxUiFpI1QlUSNUI1oxUiNaOydTJVE7J1M7PWAlYzwlbE8lUWoxV1khYWBPeSVReiFRJVEhUSFbMXYhWyFjJVEhYyFpMXYhaSNUJVEjVCNaMXYjWjsnUyVROydTOz1gJWM8JWxPJVFqMX1ZclkhYWBPeSVReiFRJVEhUSFbMm0hWyFjJVEhYyFpMm0haSNUJVEjVCNaMm0jWjsnUyVROydTOz1gJWM8JWxPJVFqMnRZclkhYWBPeSVReiFRJVEhUSFbM2QhWyFjJVEhYyFpM2QhaSNUJVEjVCNaM2QjWjsnUyVROydTOz1gJWM8JWxPJVFqM2lZIWFgT3klUXohUSVRIVEhWzRYIVshYyVRIWMhaTRYIWkjVCVRI1QjWjRYI1o7J1MlUTsnUzs9YCVjPCVsTyVRajRgWXJZIWFgT3klUXohUSVRIVEhWzVPIVshYyVRIWMhaTVPIWkjVCVRI1QjWjVPI1o7J1MlUTsnUzs9YCVjPCVsTyVRajVUWSFhYE95JVF6IVElUSFRIVs1cyFbIWMlUSFjIWk1cyFpI1QlUSNUI1o1cyNaOydTJVE7J1M7PWAlYzwlbE8lUWo1elNyWSFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWQ2WlVPeSVReiFfJVEhXyFgNm0hYDsnUyVROydTOz1gJWM8JWxPJVFkNnRTIWhTIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRYjdWU1pRT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRfjdmV09ZN2Nadzdjd3guYngjTzdjI08jUDhPI1A7J1M3YzsnUzs9YDh6PCVsTzdjfjhSUk87J1M3YzsnUzs9YDhbOz1gTzdjfjhfWE9ZN2Nadzdjd3guYngjTzdjI08jUDhPI1A7J1M3YzsnUzs9YDh6Oz1gPCVsN2M8JWxPN2N+OH1QOz1gPCVsN2NqOVZTZVlPeSVRejsnUyVROydTOz1gJWM8JWxPJVF+OWhPZH5uOW9VV1F2V095JVF6IV8lUSFfIWA2bSFgOydTJVE7J1M7PWAlYzwlbE8lUWo6WVd2VyFtUU95JVF6IU8lUSFPIVA6ciFQIVElUSFRIVs9dyFbOydTJVE7J1M7PWAlYzwlbE8lUWo6d1UhYWBPeSVReiFRJVEhUSFbO1ohWzsnUyVROydTOz1gJWM8JWxPJVFqO2JZIWFgI31ZT3klUXohUSVRIVEhWztaIVshZyVRIWchaDxRIWgjWCVRI1gjWTxRI1k7J1MlUTsnUzs9YCVjPCVsTyVRajxWWSFhYE95JVF6eyVRe3w8dXx9JVF9IU88dSFPIVElUSFRIVs9XiFbOydTJVE7J1M7PWAlYzwlbE8lUWo8elUhYWBPeSVReiFRJVEhUSFbPV4hWzsnUyVROydTOz1gJWM8JWxPJVFqPWVVIWFgI31ZT3klUXohUSVRIVEhWz1eIVs7J1MlUTsnUzs9YCVjPCVsTyVRaj5PWyFhYCN9WU95JVF6IU8lUSFPIVA7WiFQIVElUSFRIVs9dyFbIWclUSFnIWg8USFoI1glUSNYI1k8USNZOydTJVE7J1M7PWAlYzwlbE8lUWo+eVMhXllPeSVRejsnUyVROydTOz1gJWM8JWxPJVFqP1tXdldPeSVReiFPJVEhTyFQOnIhUCFRJVEhUSFbPXchWzsnUyVROydTOz1gJWM8JWxPJVFqP3lVXVlPeSVReiFRJVEhUSFbO1ohWzsnUyVROydTOz1gJWM8JWxPJVF+QGJUdldPeSVRentAcXs7J1MlUTsnUzs9YCVjPCVsTyVRfkB4UyFhYCN0fk95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpBWlsjfVlPeSVReiFPJVEhTyFQO1ohUCFRJVEhUSFbPXchWyFnJVEhZyFoPFEhaCNYJVEjWCNZPFEjWTsnUyVROydTOz1gJWM8JWxPJVFqQlVVYFlPeSVReiFbJVEhWyFdQmghXTsnUyVROydTOz1gJWM8JWxPJVFiQm9TYVEhYWBPeSVRejsnUyVROydTOz1gJWM8JWxPJVFqQ1FTa1lPeSVRejsnUyVROydTOz1gJWM8JWxPJVFoQ2NVIVRXT3klUXohXyVRIV8hYEN1IWA7J1MlUTsnUzs9YCVjPCVsTyVRaEN8UyFUVyFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWxEYVMhVFchaFNPeSVRejsnUyVROydTOz1gJWM8JWxPJVFqRHRWIWpRIVRXT3klUXohXyVRIV8hYEN1IWAhYUVaIWE7J1MlUTsnUzs9YCVjPCVsTyVRYkViUyFqUSFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpFcVlPeSVRen0lUX0hT0ZhIU8hYyVRIWMhfUdPIX0jVCVRI1Qjb0dPI287J1MlUTsnUzs9YCVjPCVsTyVRakZmVyFhYE95JVF6IWMlUSFjIX1HTyF9I1QlUSNUI29HTyNvOydTJVE7J1M7PWAlYzwlbE8lUWpHVltpWSFhYE95JVF6fSVRfSFPR08hTyFRJVEhUSFbR08hWyFjJVEhYyF9R08hfSNUJVEjVCNvR08jbzsnUyVROydTOz1gJWM8JWxPJVFqSFFTbVlPeSVRejsnUyVROydTOz1gJWM8JWxPJVFuSGNTbF5PeSVRejsnUyVROydTOz1gJWM8JWxPJVFqSHRTcFlPeSVRejsnUyVROydTOz1gJWM8JWxPJVFqSVZTb1lPeSVRejsnUyVROydTOz1gJWM8JWxPJVFmSWhVIW1RT3klUXohXyVRIV8hYDZtIWA7J1MlUTsnUzs9YCVjPCVsTyVRYEl9UDs9YDwlbCRxXCIsXG4gIHRva2VuaXplcnM6IFtkZXNjZW5kYW50LCB1bml0VG9rZW4sIGlkZW50aWZpZXJzLCBxdWVyeUlkZW50aWZpZXJzLCAxLCAyLCAzLCA0LCBuZXcgTG9jYWxUb2tlbkdyb3VwKFwibX5SUllaW3p7YX5+Z35hTyN2fn5kUCFQIVFnfmxPI3d+flwiLCAyOCwgMTI5KV0sXG4gIHRvcFJ1bGVzOiB7XCJTdHlsZVNoZWV0XCI6WzAsNl0sXCJTdHlsZXNcIjpbMSwxMDVdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogMTI0LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19jYWxsZWVbdmFsdWVdIHx8IC0xfSx7dGVybTogMTI1LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19xdWVyeUlkZW50aWZpZXJbdmFsdWVdIHx8IC0xfSx7dGVybTogNCwgZ2V0OiAodmFsdWUpID0+IHNwZWNfUXVlcnlDYWxsZWVbdmFsdWVdIHx8IC0xfSx7dGVybTogMjUsIGdldDogKHZhbHVlKSA9PiBzcGVjX0F0S2V5d29yZFt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAxMjMsIGdldDogKHZhbHVlKSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMTk2M1xufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/css/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The optional name of the base tag @internal\n    */\n    name, \n    /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */\n    set, \n    /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */\n    base, \n    /**\n    The modifiers applied to this.base @internal\n    */\n    modified) {\n        this.name = name;\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */\n        this.id = nextTagID++;\n    }\n    toString() {\n        let { name } = this;\n        for (let mod of this.modified)\n            if (mod.name)\n                name = `${mod.name}(${name})`;\n        return name;\n    }\n    static define(nameOrParent, parent) {\n        let name = typeof nameOrParent == \"string\" ? nameOrParent : \"?\";\n        if (nameOrParent instanceof Tag)\n            parent = nameOrParent;\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag(name, [], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n    static defineModifier(name) {\n        let mod = new Modifier(name);\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(name) {\n        this.name = name;\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(base.name, set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.configure({props: [\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n]})\n```\n*/\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Mode.Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Mode.Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n    combine(a, b) {\n        let cur, root, take;\n        while (a || b) {\n            if (!a || b && a.depth >= b.depth) {\n                take = b;\n                b = b.next;\n            }\n            else {\n                take = a;\n                a = a.next;\n            }\n            if (cur && cur.mode == take.mode && !take.context && !cur.context)\n                continue;\n            let copy = new Rule(take.tags, take.mode, take.context);\n            if (cur)\n                cur.next = copy;\n            else\n                root = copy;\n            cur = copy;\n        }\n        return root;\n    }\n});\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Mode.Opaque */; }\n    get inherit() { return this.mode == 1 /* Mode.Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/\nfunction highlightTree(tree, highlighter, \n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle, \n/**\nThe start of the range to highlight.\n*/\nfrom = 0, \n/**\nThe end of the range.\n*/\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/\nfunction highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos)\n            return;\n        for (let text = code.slice(pos, p), i = 0;;) {\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i)\n                putText(text.slice(i, upto), classes);\n            if (nextBreak < 0)\n                break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes) => {\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            if (mounted)\n                inheritedClass = \"\";\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n    /**\n    A comment.\n    */\n    comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */\n    lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */\n    blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */\n    docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */\n    name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */\n    variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */\n    typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */\n    tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */\n    propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */\n    attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */\n    className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */\n    labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */\n    namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */\n    macroName: t(name),\n    /**\n    A literal value.\n    */\n    literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */\n    string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */\n    docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */\n    character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */\n    attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */\n    number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */\n    integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */\n    float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */\n    bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */\n    regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */\n    escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */\n    color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */\n    url: t(literal),\n    /**\n    A language keyword.\n    */\n    keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */\n    self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */\n    null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */\n    atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */\n    unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */\n    modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */\n    operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */\n    controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */\n    definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */\n    moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */\n    operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */\n    derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */\n    arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */\n    logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */\n    bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */\n    compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */\n    updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */\n    definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */\n    typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */\n    controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */\n    punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */\n    separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */\n    bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */\n    angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */\n    squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */\n    content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */\n    heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */\n    heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */\n    heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */\n    heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */\n    heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */\n    heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */\n    heading6: t(heading),\n    /**\n    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).\n    */\n    contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */\n    list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */\n    quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */\n    emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */\n    strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */\n    link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */\n    monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */\n    strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */\n    inserted: t(),\n    /**\n    Deleted text.\n    */\n    deleted: t(),\n    /**\n    Changed text.\n    */\n    changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */\n    invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */\n    meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */\n    documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */\n    annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */\n    processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */\n    definition: Tag.defineModifier(\"definition\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */\n    constant: Tag.defineModifier(\"constant\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */\n    function: Tag.defineModifier(\"function\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */\n    standard: Tag.defineModifier(\"standard\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */\n    local: Tag.defineModifier(\"local\"),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */\n    special: Tag.defineModifier(\"special\")\n};\nfor (let name in tags) {\n    let val = tags[name];\n    if (val instanceof Tag)\n        val.name = name;\n}\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLDBCQUEwQixTQUFTLEdBQUcsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSxrRkFBa0Y7QUFDeEYsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSxtRkFBbUY7QUFDekYsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxtRkFBbUY7QUFDekYsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTTtBQUNOOztBQUU4RyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWxlYXJuaW5nLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzPzlmZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vKipcbkhpZ2hsaWdodGluZyB0YWdzIGFyZSBtYXJrZXJzIHRoYXQgZGVub3RlIGEgaGlnaGxpZ2h0aW5nIGNhdGVnb3J5LlxuVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG50cmVlIGJ5IGEgbGFuZ3VhZ2UgbW9kZSwgYW5kIHRoZW4gbWFwcGVkIHRvIGFuIGFjdHVhbCBDU1Mgc3R5bGUgYnlcbmEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cblxuQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbmFibGUgdG8gdGFsayB0aGUgc2FtZSBsYW5ndWFnZSwgQ29kZU1pcnJvciB1c2VzIGEgbW9zdGx5IF9jbG9zZWRfXG5bdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xudHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuaGlnaGxpZ2h0aW5nIHRoZW1lcyB0byBjb3ZlciBhbGwgdGhlIHRva2VucyBwcm9kdWNlZCBieSB0aGVcbnZhcmlvdXMgbGFuZ3VhZ2VzKS5cblxuSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG5oaWdobGlnaHRpbmcgdGFncyBmb3Igc3lzdGVtLWludGVybmFsIHVzZSAod2hlcmUgeW91IGNvbnRyb2wgYm90aFxudGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3RcbmJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbmZyb20gc3RhbmRhcmQgdGFncyB0byBhbGxvdyBoaWdobGlnaHRlcnMgdG8gZmFsbCBiYWNrIHRvIHRob3NlKS5cbiovXG5jbGFzcyBUYWcge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGJhc2UgdGFnIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIHRoaXMgb25lIGl0c2VsZiBhbmQgc29ydGVkIGluIG9yZGVyIG9mIGRlY3JlYXNpbmcgc3BlY2lmaWNpdHkuXG4gICAgKi9cbiAgICBzZXQsIFxuICAgIC8qKlxuICAgIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICBtb2RpZmllZCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJhc2UsIFxuICAgIC8qKlxuICAgIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RpZmllZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG1vZGlmaWVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0VGFnSUQrKztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IG1vZCBvZiB0aGlzLm1vZGlmaWVkKVxuICAgICAgICAgICAgaWYgKG1vZC5uYW1lKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBgJHttb2QubmFtZX0oJHtuYW1lfSlgO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShuYW1lT3JQYXJlbnQsIHBhcmVudCkge1xuICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBuYW1lT3JQYXJlbnQgPT0gXCJzdHJpbmdcIiA/IG5hbWVPclBhcmVudCA6IFwiP1wiO1xuICAgICAgICBpZiAobmFtZU9yUGFyZW50IGluc3RhbmNlb2YgVGFnKVxuICAgICAgICAgICAgcGFyZW50ID0gbmFtZU9yUGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhuYW1lLCBbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIobmFtZSkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyKG5hbWUpO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKGJhc2UubmFtZSwgc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLyoqXG5UaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYWRkIGEgc2V0IG9mIHRhZ3MgdG8gYSBsYW5ndWFnZSBzeW50YXhcbnZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbltgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLkxSUGFyc2VyLmNvbmZpZ3VyZSkuXG5cblRoZSBhcmd1bWVudCBvYmplY3QgbWFwcyBub2RlIHNlbGVjdG9ycyB0byBbaGlnaGxpZ2h0aW5nXG50YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG5cbk5vZGUgc2VsZWN0b3JzIG1heSBob2xkIG9uZSBvciBtb3JlIChzcGFjZS1zZXBhcmF0ZWQpIG5vZGUgcGF0aHMuXG5TdWNoIGEgcGF0aCBjYW4gYmUgYSBbbm9kZSBuYW1lXSgjY29tbW9uLk5vZGVUeXBlLm5hbWUpLCBvclxubXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG5jaGFyYWN0ZXJzLCBhcyBpbiBgXCJCbG9jay9EZWNsYXJhdGlvbi9WYXJpYWJsZU5hbWVcImAuIFN1Y2ggYSBwYXRoXG5tYXRjaGVzIHRoZSBmaW5hbCBub2RlIGJ1dCBvbmx5IGlmIGl0cyBkaXJlY3QgcGFyZW50IG5vZGVzIGFyZSB0aGVcbm90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuYnV0IG9ubHkgYSBzaW5nbGUgbGV2ZWzigJR3aWxkY2FyZHMgdGhhdCBtYXRjaCBtdWx0aXBsZSBwYXJlbnRzXG5hcmVuJ3Qgc3VwcG9ydGVkLCBib3RoIGZvciBlZmZpY2llbmN5IHJlYXNvbnMgYW5kIGJlY2F1c2UgTGV6ZXJcbnRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG5cbkEgcGF0aCBjYW4gYmUgZW5kZWQgd2l0aCBgLy4uLmAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGFnIGFzc2lnbmVkXG50byB0aGUgbm9kZSBzaG91bGQgYWxzbyBhcHBseSB0byBhbGwgY2hpbGQgbm9kZXMsIGV2ZW4gaWYgdGhleVxubWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbnVzZWQpLlxuXG5XaGVuIGEgcGF0aCBlbmRzIGluIGAhYCwgYXMgaW4gYEF0dHJpYnV0ZSFgLCBubyBmdXJ0aGVyIG1hdGNoaW5nXG5oYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG5naXZlbiBzdHlsZS5cblxuSW4gdGhpcyBub3RhdGlvbiwgbm9kZSBuYW1lcyB0aGF0IGNvbnRhaW4gYC9gLCBgIWAsIGAqYCwgb3IgYC4uLmBcbm11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cblxuRm9yIGV4YW1wbGU6XG5cbmBgYGphdmFzY3JpcHRcbnBhcnNlci5jb25maWd1cmUoe3Byb3BzOiBbXG4gIHN0eWxlVGFncyh7XG4gICAgLy8gU3R5bGUgTnVtYmVyIGFuZCBCaWdOdW1iZXIgbm9kZXNcbiAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4gICAgLy8gU3R5bGUgRXNjYXBlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBTdHJpbmdcbiAgICBcIlN0cmluZy9Fc2NhcGVcIjogdGFncy5lc2NhcGUsXG4gICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbiAgICBcIkF0dHJpYnV0ZXMhXCI6IHRhZ3MubWV0YSxcbiAgICAvLyBBZGQgYSBzdHlsZSB0byBhbGwgY29udGVudCBpbnNpZGUgSXRhbGljIG5vZGVzXG4gICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4gICAgLy8gU3R5bGUgSW52YWxpZFN0cmluZyBub2RlcyBhcyBib3RoIGBzdHJpbmdgIGFuZCBgaW52YWxpZGBcbiAgICBcIkludmFsaWRTdHJpbmdcIjogW3RhZ3Muc3RyaW5nLCB0YWdzLmludmFsaWRdLFxuICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4gICAgJ1wiL1wiJzogdGFncy5wdW5jdHVhdGlvblxuICB9KVxuXX0pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCh7XG4gICAgY29tYmluZShhLCBiKSB7XG4gICAgICAgIGxldCBjdXIsIHJvb3QsIHRha2U7XG4gICAgICAgIHdoaWxlIChhIHx8IGIpIHtcbiAgICAgICAgICAgIGlmICghYSB8fCBiICYmIGEuZGVwdGggPj0gYi5kZXB0aCkge1xuICAgICAgICAgICAgICAgIHRha2UgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWtlID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1ciAmJiBjdXIubW9kZSA9PSB0YWtlLm1vZGUgJiYgIXRha2UuY29udGV4dCAmJiAhY3VyLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBSdWxlKHRha2UudGFncywgdGFrZS5tb2RlLCB0YWtlLmNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGN1cilcbiAgICAgICAgICAgICAgICBjdXIubmV4dCA9IGNvcHk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcm9vdCA9IGNvcHk7XG4gICAgICAgICAgICBjdXIgPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbn0pO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLiBPZnRlbiwgdGhlIGhpZ2hlci1sZXZlbFxuW2BoaWdobGlnaHRDb2RlYF0oI2hpZ2hsaWdodC5oaWdobGlnaHRDb2RlKSBmdW5jdGlvbiBpcyBlYXNpZXIgdG9cbnVzZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiB0cmVlIHdpdGggdGhlIGdpdmVuIGhpZ2hsaWdodGVyLCBjYWxsaW5nXG5gcHV0VGV4dGAgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRleHQsIGVpdGhlciB3aXRoIGEgc2V0IG9mIGNsYXNzZXMgb3JcbndpdGggdGhlIGVtcHR5IHN0cmluZyB3aGVuIHVuc3R5bGVkLCBhbmQgYHB1dEJyZWFrYCBmb3IgZXZlcnkgbGluZVxuYnJlYWsuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCB0cmVlLCBoaWdobGlnaHRlciwgcHV0VGV4dCwgcHV0QnJlYWssIGZyb20gPSAwLCB0byA9IGNvZGUubGVuZ3RoKSB7XG4gICAgbGV0IHBvcyA9IGZyb207XG4gICAgZnVuY3Rpb24gd3JpdGVUbyhwLCBjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwIDw9IHBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGV4dCA9IGNvZGUuc2xpY2UocG9zLCBwKSwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgIGxldCB1cHRvID0gbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrO1xuICAgICAgICAgICAgaWYgKHVwdG8gPiBpKVxuICAgICAgICAgICAgICAgIHB1dFRleHQodGV4dC5zbGljZShpLCB1cHRvKSwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHB1dEJyZWFrKCk7XG4gICAgICAgICAgICBpID0gbmV4dEJyZWFrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBwO1xuICAgIH1cbiAgICBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCAoZnJvbSwgdG8sIGNsYXNzZXMpID0+IHtcbiAgICAgICAgd3JpdGVUbyhmcm9tLCBcIlwiKTtcbiAgICAgICAgd3JpdGVUbyh0bywgY2xhc3Nlcyk7XG4gICAgfSwgZnJvbSwgdG8pO1xuICAgIHdyaXRlVG8odG8sIFwiXCIpO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWF4KGZyb20sIHN0YXJ0KSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgXCJcIiwgaW5uZXJIaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgcG9zKSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuTWF0Y2ggYSBzeW50YXggbm9kZSdzIFtoaWdobGlnaHQgcnVsZXNdKCNoaWdobGlnaHQuc3R5bGVUYWdzKS4gSWZcbnRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbm9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG4qL1xuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxueW91ciB1c2UgY2FzZS5cblxuTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbnRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW504oCUaWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbml0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cblxuRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xudGhlIHBhcmVudC5cbiovXG5jb25zdCB0YWdzID0ge1xuICAgIC8qKlxuICAgIEEgY29tbWVudC5cbiAgICAqL1xuICAgIGNvbW1lbnQsXG4gICAgLyoqXG4gICAgQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgKi9cbiAgICBuYW1lLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgKi9cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLyoqXG4gICAgQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICAqL1xuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICAqL1xuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgICovXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICAqL1xuICAgIGxpdGVyYWwsXG4gICAgLyoqXG4gICAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgKi9cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgbnVtYmVyLFxuICAgIC8qKlxuICAgIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgKi9cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgb2JqZWN0LlxuICAgICovXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgICovXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICAqL1xuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgICovXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICAqL1xuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8qKlxuICAgIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICAgIHRoaW5ncy5cbiAgICAqL1xuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICAgKi9cbiAgICBicmFja2V0LFxuICAgIC8qKlxuICAgIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgKi9cbiAgICBoZWFkaW5nLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNCBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgcHJvc2UgW2NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgICovXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGxpc3QuXG4gICAgKi9cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgKi9cbiAgICBxdW90ZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICAqL1xuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgc3Ryb25nLlxuICAgICovXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICAqL1xuICAgIGxpbms6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgbW9ub3NwYWNlLlxuICAgICovXG4gICAgbW9ub3NwYWNlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIHN0eWxlLlxuICAgICovXG4gICAgc3RyaWtldGhyb3VnaDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICAqL1xuICAgIGluc2VydGVkOiB0KCksXG4gICAgLyoqXG4gICAgRGVsZXRlZCB0ZXh0LlxuICAgICovXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8qKlxuICAgIENoYW5nZWQgdGV4dC5cbiAgICAqL1xuICAgIGNoYW5nZWQ6IHQoKSxcbiAgICAvKipcbiAgICBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLyoqXG4gICAgTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cbiAgICAqL1xuICAgIG1ldGEsXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgYXR0cmlidXRlcyB0byBhIGdpdmVuIHN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIFttZXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkuXG4gICAgKi9cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgZ2l2ZW4gZWxlbWVudCBpcyBiZWluZyBkZWZpbmVkLiBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggdGhlXG4gICAgdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJkZWZpbml0aW9uXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICBbdmFyaWFibGUgbmFtZXNdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcihcImNvbnN0YW50XCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIGEgW3ZhcmlhYmxlXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIGFzIGEgZnVuY3Rpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKFwiZnVuY3Rpb25cIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgICAqL1xuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJzdGFuZGFyZFwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgaXMgbG9jYWwgdG8gc29tZSBzY29wZS5cbiAgICAqL1xuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJsb2NhbFwiKSxcbiAgICAvKipcbiAgICBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIFt2YXJpYWJsZSBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSB0YWdzLCBzaW5jZSB0aG9zZVxuICAgIGNvbWUgdXAgYSBsb3QuXG4gICAgKi9cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJzcGVjaWFsXCIpXG59O1xuZm9yIChsZXQgbmFtZSBpbiB0YWdzKSB7XG4gICAgbGV0IHZhbCA9IHRhZ3NbbmFtZV07XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRhZylcbiAgICAgICAgdmFsLm5hbWUgPSBuYW1lO1xufVxuLyoqXG5UaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xudG9rZW5zLCBmb3Igc3R5bGluZyB3aXRoIGV4dGVybmFsIENTUy5cblxuVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbihmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXG4qIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXG4qIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbiogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4qIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbiogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbiogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4qIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbiogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4qIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4qIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcblxuSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcblxuKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4gIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbiogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4qIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qL1xuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnQgeyBUYWcsIGNsYXNzSGlnaGxpZ2h0ZXIsIGdldFN0eWxlVGFncywgaGlnaGxpZ2h0Q29kZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdIaWdobGlnaHRlciwgdGFncyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/html/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/@lezer/html/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   configureNesting: () => (/* binding */ configureNesting),\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst scriptText = 55,\n  StartCloseScriptTag = 1,\n  styleText = 56,\n  StartCloseStyleTag = 2,\n  textareaText = 57,\n  StartCloseTextareaTag = 3,\n  EndTag = 4,\n  SelfClosingEndTag = 5,\n  StartTag = 6,\n  StartScriptTag = 7,\n  StartStyleTag = 8,\n  StartTextareaTag = 9,\n  StartSelfClosingTag = 10,\n  StartCloseTag = 11,\n  NoMatchStartCloseTag = 12,\n  MismatchedStartCloseTag = 13,\n  missingCloseTag = 58,\n  IncompleteTag = 14,\n  IncompleteCloseTag = 15,\n  commentContent$1 = 59,\n  Element = 21,\n  TagName = 23,\n  Attribute = 24,\n  AttributeName = 25,\n  AttributeValue = 27,\n  UnquotedAttributeValue = 28,\n  ScriptText = 29,\n  StyleText = 32,\n  TextareaText = 35,\n  OpenTag = 37,\n  CloseTag = 38,\n  Dialect_noMatch = 0,\n  Dialect_selfClosing = 1;\n\n/* Hand-written tokenizers for HTML. */\n\nconst selfClosers = {\n  area: true, base: true, br: true, col: true, command: true,\n  embed: true, frame: true, hr: true, img: true, input: true,\n  keygen: true, link: true, meta: true, param: true, source: true,\n  track: true, wbr: true, menuitem: true\n};\n\nconst implicitlyClosed = {\n  dd: true, li: true, optgroup: true, option: true, p: true,\n  rp: true, rt: true, tbody: true, td: true, tfoot: true,\n  th: true, tr: true\n};\n\nconst closeOnOpen = {\n  dd: {dd: true, dt: true},\n  dt: {dd: true, dt: true},\n  li: {li: true},\n  option: {option: true, optgroup: true},\n  optgroup: {optgroup: true},\n  p: {\n    address: true, article: true, aside: true, blockquote: true, dir: true,\n    div: true, dl: true, fieldset: true, footer: true, form: true,\n    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,\n    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,\n    p: true, pre: true, section: true, table: true, ul: true\n  },\n  rp: {rp: true, rt: true},\n  rt: {rp: true, rt: true},\n  tbody: {tbody: true, tfoot: true},\n  td: {td: true, th: true},\n  tfoot: {tbody: true},\n  th: {td: true, th: true},\n  thead: {tbody: true, tfoot: true},\n  tr: {tr: true}\n};\n\nfunction nameChar(ch) {\n  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161\n}\n\nlet cachedName = null, cachedInput = null, cachedPos = 0;\nfunction tagNameAfter(input, offset) {\n  let pos = input.pos + offset;\n  if (cachedPos == pos && cachedInput == input) return cachedName\n  let next = input.peek(offset), name = \"\";\n  for (;;) {\n    if (!nameChar(next)) break\n    name += String.fromCharCode(next);\n    next = input.peek(++offset);\n  }\n  // Undefined to signal there's a <? or <!, null for just missing\n  cachedInput = input; cachedPos = pos;\n  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null\n}\n\nconst lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;\n\nfunction ElementContext(name, parent) {\n  this.name = name;\n  this.parent = parent;\n}\n\nconst startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];\n\nconst elementContext = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: null,\n  shift(context, term, stack, input) {\n    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context\n  },\n  reduce(context, term) {\n    return term == Element && context ? context.parent : context\n  },\n  reuse(context, node, stack, input) {\n    let type = node.type.id;\n    return type == StartTag || type == OpenTag\n      ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context\n  },\n  strict: false\n});\n\nconst tagStart = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next != lessThan) {\n    // End of file, close any open tags\n    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);\n    return\n  }\n  input.advance();\n  let close = input.next == slash;\n  if (close) input.advance();\n  let name = tagNameAfter(input, 0);\n  if (name === undefined) return\n  if (!name) return input.acceptToken(close ? IncompleteCloseTag : IncompleteTag)\n\n  let parent = stack.context ? stack.context.name : null;\n  if (close) {\n    if (name == parent) return input.acceptToken(StartCloseTag)\n    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)\n    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)\n    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return\n    input.acceptToken(MismatchedStartCloseTag);\n  } else {\n    if (name == \"script\") return input.acceptToken(StartScriptTag)\n    if (name == \"style\") return input.acceptToken(StartStyleTag)\n    if (name == \"textarea\") return input.acceptToken(StartTextareaTag)\n    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)\n    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);\n    else input.acceptToken(StartTag);\n  }\n}, {contextual: true});\n\nconst commentContent = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  for (let dashes = 0, i = 0;; i++) {\n    if (input.next < 0) {\n      if (i) input.acceptToken(commentContent$1);\n      break\n    }\n    if (input.next == dash) {\n      dashes++;\n    } else if (input.next == greaterThan && dashes >= 2) {\n      if (i >= 3) input.acceptToken(commentContent$1, -2);\n      break\n    } else {\n      dashes = 0;\n    }\n    input.advance();\n  }\n});\n\nfunction inForeignElement(context) {\n  for (; context; context = context.parent)\n    if (context.name == \"svg\" || context.name == \"math\") return true\n  return false\n}\n\nconst endTag = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next == slash && input.peek(1) == greaterThan) {\n    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);\n    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);\n  } else if (input.next == greaterThan) {\n    input.acceptToken(EndTag, 1);\n  }\n});\n\nfunction contentTokenizer(tag, textToken, endToken) {\n  let lastState = 2 + tag.length;\n  return new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n    // state means:\n    // - 0 nothing matched\n    // - 1 '<' matched\n    // - 2 '</'\n    // - 3-(1+tag.length) part of the tag matched\n    // - lastState whole tag + possibly whitespace matched\n    for (let state = 0, matchedLen = 0, i = 0;; i++) {\n      if (input.next < 0) {\n        if (i) input.acceptToken(textToken);\n        break\n      }\n      if (state == 0 && input.next == lessThan ||\n          state == 1 && input.next == slash ||\n          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {\n        state++;\n        matchedLen++;\n      } else if (state == lastState && input.next == greaterThan) {\n        if (i > matchedLen)\n          input.acceptToken(textToken, -matchedLen);\n        else\n          input.acceptToken(endToken, -(matchedLen - 2));\n        break\n      } else if ((input.next == 10 /* '\\n' */ || input.next == 13 /* '\\r' */) && i) {\n        input.acceptToken(textToken, 1);\n        break\n      } else {\n        state = matchedLen = 0;\n      }\n      input.advance();\n    }\n  })\n}\n\nconst scriptTokens = contentTokenizer(\"script\", scriptText, StartCloseScriptTag);\n\nconst styleTokens = contentTokenizer(\"style\", styleText, StartCloseStyleTag);\n\nconst textareaTokens = contentTokenizer(\"textarea\", textareaText, StartCloseTextareaTag);\n\nconst htmlHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"Text RawText IncompleteTag IncompleteCloseTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"StartTag StartCloseTag SelfClosingEndTag EndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"MismatchedCloseTag/TagName\": [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,  _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid],\n  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"AttributeValue UnquotedAttributeValue\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  Is: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  \"EntityReference CharacterReference\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,\n  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  ProcessingInst: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,\n  DoctypeDecl: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.documentMeta\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[\",\n  stateData: \",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~\",\n  goto: \"%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp\",\n  nodeNames: \"âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl\",\n  maxTerm: 68,\n  context: elementContext,\n  nodeProps: [\n    [\"closedBy\", -10,1,2,3,7,8,9,10,11,12,13,\"EndTag\",6,\"EndTag SelfClosingEndTag\",-4,22,31,34,37,\"CloseTag\"],\n    [\"openedBy\", 4,\"StartTag StartCloseTag\",5,\"StartTag\",-4,30,33,36,38,\"OpenTag\"],\n    [\"group\", -10,14,15,18,19,20,21,40,41,42,43,\"Entity\",17,\"Entity TextContent\",-3,29,32,35,\"TextContent Entity\"],\n    [\"isolate\", -11,22,30,31,33,34,36,37,38,39,42,43,\"ltr\",-3,27,28,40,\"\"]\n  ],\n  propSources: [htmlHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 9,\n  tokenData: \"!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X\",\n  tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],\n  topRules: {\"Document\":[0,16]},\n  dialects: {noMatch: 0, selfClosing: 515},\n  tokenPrec: 517\n});\n\nfunction getAttrs(openTag, input) {\n  let attrs = Object.create(null);\n  for (let att of openTag.getChildren(Attribute)) {\n    let name = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);\n    if (name) attrs[input.read(name.from, name.to)] =\n      !value ? \"\" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);\n  }\n  return attrs\n}\n\nfunction findTagName(openTag, input) {\n  let tagNameNode = openTag.getChild(TagName);\n  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : \" \"\n}\n\nfunction maybeNest(node, input, tags) {\n  let attrs;\n  for (let tag of tags) {\n    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent.firstChild, input))))\n      return {parser: tag.parser}\n  }\n  return null\n}\n\n// tags?: {\n//   tag: string,\n//   attrs?: ({[attr: string]: string}) => boolean,\n//   parser: Parser\n// }[]\n// attributes?: {\n//   name: string,\n//   tagName?: string,\n//   parser: Parser\n// }[]\n \nfunction configureNesting(tags = [], attributes = []) {\n  let script = [], style = [], textarea = [], other = [];\n  for (let tag of tags) {\n    let array = tag.tag == \"script\" ? script : tag.tag == \"style\" ? style : tag.tag == \"textarea\" ? textarea : other;\n    array.push(tag);\n  }\n  let attrs = attributes.length ? Object.create(null) : null;\n  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);\n\n  return (0,_lezer_common__WEBPACK_IMPORTED_MODULE_2__.parseMixed)((node, input) => {\n    let id = node.type.id;\n    if (id == ScriptText) return maybeNest(node, input, script)\n    if (id == StyleText) return maybeNest(node, input, style)\n    if (id == TextareaText) return maybeNest(node, input, textarea)\n\n    if (id == Element && other.length) {\n      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input), attrs;\n      if (tagName) for (let tag of other) {\n        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(open, input))))) {\n          let close = n.lastChild;\n          let to = close.type.id == CloseTag ? close.from : n.to;\n          if (to > open.to)\n            return {parser: tag.parser, overlay: [{from: open.to, to}]}\n        }\n      }\n    }\n\n    if (attrs && id == Attribute) {\n      let n = node.node, nameNode;\n      if (nameNode = n.firstChild) {\n        let matches = attrs[input.read(nameNode.from, nameNode.to)];\n        if (matches) for (let attr of matches) {\n          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue\n          let value = n.lastChild;\n          if (value.type.id == AttributeValue) {\n            let from = value.from + 1;\n            let last = value.lastChild, to = value.to - (last && last.isError ? 0 : 1);\n            if (to > from) return {parser: attr.parser, overlay: [{from, to}]}\n          } else if (value.type.id == UnquotedAttributeValue) {\n            return {parser: attr.parser, overlay: [{from: value.from, to: value.to}]}\n          }\n        }\n      }\n    }\n    return null\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2h0bWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RTtBQUNyQjtBQUNSOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sU0FBUztBQUNoQixXQUFXLDZCQUE2QjtBQUN4QyxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sbUJBQW1CO0FBQzFCLFVBQVUseUJBQXlCO0FBQ25DLE9BQU8sbUJBQW1CO0FBQzFCLFVBQVUsWUFBWTtBQUN0QixPQUFPLG1CQUFtQjtBQUMxQixVQUFVLHlCQUF5QjtBQUNuQyxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixxREFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQscUJBQXFCLHdEQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNB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QUcseUJBQXlCLDBDQUEwQyxNQUFNLEdBQUcsNEJBQTRCLEtBQUssR0FBRyxnQkFBZ0IsaURBQWlELEdBQUcsTUFBTSxHQUFHLHdEQUF3RCxNQUFNLEdBQUcsZ0NBQWdDLEtBQUssR0FBRyxnQkFBZ0IseURBQXlELElBQUksTUFBTSxHQUFHLElBQUksWUFBWSw0QkFBNEIsS0FBSyxHQUFHLGNBQWMsR0FBRyxnQ0FBZ0Msc0JBQXNCLEtBQUssR0FBRztBQUNsb007QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLDZCQUE2QjtBQUMxQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMseURBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDLFNBQVM7QUFDNUUsWUFBWTtBQUNaLG9CQUFvQixnQ0FBZ0MsK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtbGVhcm5pbmctcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaHRtbC9kaXN0L2luZGV4LmpzP2QzMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcbmltcG9ydCB7IHBhcnNlTWl4ZWQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzY3JpcHRUZXh0ID0gNTUsXG4gIFN0YXJ0Q2xvc2VTY3JpcHRUYWcgPSAxLFxuICBzdHlsZVRleHQgPSA1NixcbiAgU3RhcnRDbG9zZVN0eWxlVGFnID0gMixcbiAgdGV4dGFyZWFUZXh0ID0gNTcsXG4gIFN0YXJ0Q2xvc2VUZXh0YXJlYVRhZyA9IDMsXG4gIEVuZFRhZyA9IDQsXG4gIFNlbGZDbG9zaW5nRW5kVGFnID0gNSxcbiAgU3RhcnRUYWcgPSA2LFxuICBTdGFydFNjcmlwdFRhZyA9IDcsXG4gIFN0YXJ0U3R5bGVUYWcgPSA4LFxuICBTdGFydFRleHRhcmVhVGFnID0gOSxcbiAgU3RhcnRTZWxmQ2xvc2luZ1RhZyA9IDEwLFxuICBTdGFydENsb3NlVGFnID0gMTEsXG4gIE5vTWF0Y2hTdGFydENsb3NlVGFnID0gMTIsXG4gIE1pc21hdGNoZWRTdGFydENsb3NlVGFnID0gMTMsXG4gIG1pc3NpbmdDbG9zZVRhZyA9IDU4LFxuICBJbmNvbXBsZXRlVGFnID0gMTQsXG4gIEluY29tcGxldGVDbG9zZVRhZyA9IDE1LFxuICBjb21tZW50Q29udGVudCQxID0gNTksXG4gIEVsZW1lbnQgPSAyMSxcbiAgVGFnTmFtZSA9IDIzLFxuICBBdHRyaWJ1dGUgPSAyNCxcbiAgQXR0cmlidXRlTmFtZSA9IDI1LFxuICBBdHRyaWJ1dGVWYWx1ZSA9IDI3LFxuICBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlID0gMjgsXG4gIFNjcmlwdFRleHQgPSAyOSxcbiAgU3R5bGVUZXh0ID0gMzIsXG4gIFRleHRhcmVhVGV4dCA9IDM1LFxuICBPcGVuVGFnID0gMzcsXG4gIENsb3NlVGFnID0gMzgsXG4gIERpYWxlY3Rfbm9NYXRjaCA9IDAsXG4gIERpYWxlY3Rfc2VsZkNsb3NpbmcgPSAxO1xuXG4vKiBIYW5kLXdyaXR0ZW4gdG9rZW5pemVycyBmb3IgSFRNTC4gKi9cblxuY29uc3Qgc2VsZkNsb3NlcnMgPSB7XG4gIGFyZWE6IHRydWUsIGJhc2U6IHRydWUsIGJyOiB0cnVlLCBjb2w6IHRydWUsIGNvbW1hbmQ6IHRydWUsXG4gIGVtYmVkOiB0cnVlLCBmcmFtZTogdHJ1ZSwgaHI6IHRydWUsIGltZzogdHJ1ZSwgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSwgbGluazogdHJ1ZSwgbWV0YTogdHJ1ZSwgcGFyYW06IHRydWUsIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsIHdicjogdHJ1ZSwgbWVudWl0ZW06IHRydWVcbn07XG5cbmNvbnN0IGltcGxpY2l0bHlDbG9zZWQgPSB7XG4gIGRkOiB0cnVlLCBsaTogdHJ1ZSwgb3B0Z3JvdXA6IHRydWUsIG9wdGlvbjogdHJ1ZSwgcDogdHJ1ZSxcbiAgcnA6IHRydWUsIHJ0OiB0cnVlLCB0Ym9keTogdHJ1ZSwgdGQ6IHRydWUsIHRmb290OiB0cnVlLFxuICB0aDogdHJ1ZSwgdHI6IHRydWVcbn07XG5cbmNvbnN0IGNsb3NlT25PcGVuID0ge1xuICBkZDoge2RkOiB0cnVlLCBkdDogdHJ1ZX0sXG4gIGR0OiB7ZGQ6IHRydWUsIGR0OiB0cnVlfSxcbiAgbGk6IHtsaTogdHJ1ZX0sXG4gIG9wdGlvbjoge29wdGlvbjogdHJ1ZSwgb3B0Z3JvdXA6IHRydWV9LFxuICBvcHRncm91cDoge29wdGdyb3VwOiB0cnVlfSxcbiAgcDoge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBkaXI6IHRydWUsXG4gICAgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSxcbiAgICBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsIGg2OiB0cnVlLFxuICAgIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbWVudTogdHJ1ZSwgbmF2OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB1bDogdHJ1ZVxuICB9LFxuICBycDoge3JwOiB0cnVlLCBydDogdHJ1ZX0sXG4gIHJ0OiB7cnA6IHRydWUsIHJ0OiB0cnVlfSxcbiAgdGJvZHk6IHt0Ym9keTogdHJ1ZSwgdGZvb3Q6IHRydWV9LFxuICB0ZDoge3RkOiB0cnVlLCB0aDogdHJ1ZX0sXG4gIHRmb290OiB7dGJvZHk6IHRydWV9LFxuICB0aDoge3RkOiB0cnVlLCB0aDogdHJ1ZX0sXG4gIHRoZWFkOiB7dGJvZHk6IHRydWUsIHRmb290OiB0cnVlfSxcbiAgdHI6IHt0cjogdHJ1ZX1cbn07XG5cbmZ1bmN0aW9uIG5hbWVDaGFyKGNoKSB7XG4gIHJldHVybiBjaCA9PSA0NSB8fCBjaCA9PSA0NiB8fCBjaCA9PSA1OCB8fCBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fCBjaCA9PSA5NSB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMjIgfHwgY2ggPj0gMTYxXG59XG5cbmxldCBjYWNoZWROYW1lID0gbnVsbCwgY2FjaGVkSW5wdXQgPSBudWxsLCBjYWNoZWRQb3MgPSAwO1xuZnVuY3Rpb24gdGFnTmFtZUFmdGVyKGlucHV0LCBvZmZzZXQpIHtcbiAgbGV0IHBvcyA9IGlucHV0LnBvcyArIG9mZnNldDtcbiAgaWYgKGNhY2hlZFBvcyA9PSBwb3MgJiYgY2FjaGVkSW5wdXQgPT0gaW5wdXQpIHJldHVybiBjYWNoZWROYW1lXG4gIGxldCBuZXh0ID0gaW5wdXQucGVlayhvZmZzZXQpLCBuYW1lID0gXCJcIjtcbiAgZm9yICg7Oykge1xuICAgIGlmICghbmFtZUNoYXIobmV4dCkpIGJyZWFrXG4gICAgbmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQpO1xuICAgIG5leHQgPSBpbnB1dC5wZWVrKCsrb2Zmc2V0KTtcbiAgfVxuICAvLyBVbmRlZmluZWQgdG8gc2lnbmFsIHRoZXJlJ3MgYSA8PyBvciA8ISwgbnVsbCBmb3IganVzdCBtaXNzaW5nXG4gIGNhY2hlZElucHV0ID0gaW5wdXQ7IGNhY2hlZFBvcyA9IHBvcztcbiAgcmV0dXJuIGNhY2hlZE5hbWUgPSBuYW1lID8gbmFtZS50b0xvd2VyQ2FzZSgpIDogbmV4dCA9PSBxdWVzdGlvbiB8fCBuZXh0ID09IGJhbmcgPyB1bmRlZmluZWQgOiBudWxsXG59XG5cbmNvbnN0IGxlc3NUaGFuID0gNjAsIGdyZWF0ZXJUaGFuID0gNjIsIHNsYXNoID0gNDcsIHF1ZXN0aW9uID0gNjMsIGJhbmcgPSAzMywgZGFzaCA9IDQ1O1xuXG5mdW5jdGlvbiBFbGVtZW50Q29udGV4dChuYW1lLCBwYXJlbnQpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG59XG5cbmNvbnN0IHN0YXJ0VGFnVGVybXMgPSBbU3RhcnRUYWcsIFN0YXJ0U2VsZkNsb3NpbmdUYWcsIFN0YXJ0U2NyaXB0VGFnLCBTdGFydFN0eWxlVGFnLCBTdGFydFRleHRhcmVhVGFnXTtcblxuY29uc3QgZWxlbWVudENvbnRleHQgPSBuZXcgQ29udGV4dFRyYWNrZXIoe1xuICBzdGFydDogbnVsbCxcbiAgc2hpZnQoY29udGV4dCwgdGVybSwgc3RhY2ssIGlucHV0KSB7XG4gICAgcmV0dXJuIHN0YXJ0VGFnVGVybXMuaW5kZXhPZih0ZXJtKSA+IC0xID8gbmV3IEVsZW1lbnRDb250ZXh0KHRhZ05hbWVBZnRlcihpbnB1dCwgMSkgfHwgXCJcIiwgY29udGV4dCkgOiBjb250ZXh0XG4gIH0sXG4gIHJlZHVjZShjb250ZXh0LCB0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm0gPT0gRWxlbWVudCAmJiBjb250ZXh0ID8gY29udGV4dC5wYXJlbnQgOiBjb250ZXh0XG4gIH0sXG4gIHJldXNlKGNvbnRleHQsIG5vZGUsIHN0YWNrLCBpbnB1dCkge1xuICAgIGxldCB0eXBlID0gbm9kZS50eXBlLmlkO1xuICAgIHJldHVybiB0eXBlID09IFN0YXJ0VGFnIHx8IHR5cGUgPT0gT3BlblRhZ1xuICAgICAgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHRcbiAgfSxcbiAgc3RyaWN0OiBmYWxzZVxufSk7XG5cbmNvbnN0IHRhZ1N0YXJ0ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgIT0gbGVzc1RoYW4pIHtcbiAgICAvLyBFbmQgb2YgZmlsZSwgY2xvc2UgYW55IG9wZW4gdGFnc1xuICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBzdGFjay5jb250ZXh0KSBpbnB1dC5hY2NlcHRUb2tlbihtaXNzaW5nQ2xvc2VUYWcpO1xuICAgIHJldHVyblxuICB9XG4gIGlucHV0LmFkdmFuY2UoKTtcbiAgbGV0IGNsb3NlID0gaW5wdXQubmV4dCA9PSBzbGFzaDtcbiAgaWYgKGNsb3NlKSBpbnB1dC5hZHZhbmNlKCk7XG4gIGxldCBuYW1lID0gdGFnTmFtZUFmdGVyKGlucHV0LCAwKTtcbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGlmICghbmFtZSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKGNsb3NlID8gSW5jb21wbGV0ZUNsb3NlVGFnIDogSW5jb21wbGV0ZVRhZylcblxuICBsZXQgcGFyZW50ID0gc3RhY2suY29udGV4dCA/IHN0YWNrLmNvbnRleHQubmFtZSA6IG51bGw7XG4gIGlmIChjbG9zZSkge1xuICAgIGlmIChuYW1lID09IHBhcmVudCkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0Q2xvc2VUYWcpXG4gICAgaWYgKHBhcmVudCAmJiBpbXBsaWNpdGx5Q2xvc2VkW3BhcmVudF0pIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihtaXNzaW5nQ2xvc2VUYWcsIC0yKVxuICAgIGlmIChzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X25vTWF0Y2gpKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oTm9NYXRjaFN0YXJ0Q2xvc2VUYWcpXG4gICAgZm9yIChsZXQgY3ggPSBzdGFjay5jb250ZXh0OyBjeDsgY3ggPSBjeC5wYXJlbnQpIGlmIChjeC5uYW1lID09IG5hbWUpIHJldHVyblxuICAgIGlucHV0LmFjY2VwdFRva2VuKE1pc21hdGNoZWRTdGFydENsb3NlVGFnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobmFtZSA9PSBcInNjcmlwdFwiKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTY3JpcHRUYWcpXG4gICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTdHlsZVRhZylcbiAgICBpZiAobmFtZSA9PSBcInRleHRhcmVhXCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRleHRhcmVhVGFnKVxuICAgIGlmIChzZWxmQ2xvc2Vycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0U2VsZkNsb3NpbmdUYWcpXG4gICAgaWYgKHBhcmVudCAmJiBjbG9zZU9uT3BlbltwYXJlbnRdICYmIGNsb3NlT25PcGVuW3BhcmVudF1bbmFtZV0pIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZywgLTEpO1xuICAgIGVsc2UgaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRUYWcpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBjb21tZW50Q29udGVudCA9IG5ldyBFeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gIGZvciAobGV0IGRhc2hlcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICBpZiAoaSkgaW5wdXQuYWNjZXB0VG9rZW4oY29tbWVudENvbnRlbnQkMSk7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5wdXQubmV4dCA9PSBkYXNoKSB7XG4gICAgICBkYXNoZXMrKztcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4gJiYgZGFzaGVzID49IDIpIHtcbiAgICAgIGlmIChpID49IDMpIGlucHV0LmFjY2VwdFRva2VuKGNvbW1lbnRDb250ZW50JDEsIC0yKTtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhc2hlcyA9IDA7XG4gICAgfVxuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGluRm9yZWlnbkVsZW1lbnQoY29udGV4dCkge1xuICBmb3IgKDsgY29udGV4dDsgY29udGV4dCA9IGNvbnRleHQucGFyZW50KVxuICAgIGlmIChjb250ZXh0Lm5hbWUgPT0gXCJzdmdcIiB8fCBjb250ZXh0Lm5hbWUgPT0gXCJtYXRoXCIpIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBlbmRUYWcgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCA9PSBzbGFzaCAmJiBpbnB1dC5wZWVrKDEpID09IGdyZWF0ZXJUaGFuKSB7XG4gICAgbGV0IHNlbGZDbG9zaW5nID0gc3RhY2suZGlhbGVjdEVuYWJsZWQoRGlhbGVjdF9zZWxmQ2xvc2luZykgfHwgaW5Gb3JlaWduRWxlbWVudChzdGFjay5jb250ZXh0KTtcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihzZWxmQ2xvc2luZyA/IFNlbGZDbG9zaW5nRW5kVGFnIDogRW5kVGFnLCAyKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5uZXh0ID09IGdyZWF0ZXJUaGFuKSB7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oRW5kVGFnLCAxKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbnRlbnRUb2tlbml6ZXIodGFnLCB0ZXh0VG9rZW4sIGVuZFRva2VuKSB7XG4gIGxldCBsYXN0U3RhdGUgPSAyICsgdGFnLmxlbmd0aDtcbiAgcmV0dXJuIG5ldyBFeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gICAgLy8gc3RhdGUgbWVhbnM6XG4gICAgLy8gLSAwIG5vdGhpbmcgbWF0Y2hlZFxuICAgIC8vIC0gMSAnPCcgbWF0Y2hlZFxuICAgIC8vIC0gMiAnPC8nXG4gICAgLy8gLSAzLSgxK3RhZy5sZW5ndGgpIHBhcnQgb2YgdGhlIHRhZyBtYXRjaGVkXG4gICAgLy8gLSBsYXN0U3RhdGUgd2hvbGUgdGFnICsgcG9zc2libHkgd2hpdGVzcGFjZSBtYXRjaGVkXG4gICAgZm9yIChsZXQgc3RhdGUgPSAwLCBtYXRjaGVkTGVuID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCkge1xuICAgICAgICBpZiAoaSkgaW5wdXQuYWNjZXB0VG9rZW4odGV4dFRva2VuKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PSAwICYmIGlucHV0Lm5leHQgPT0gbGVzc1RoYW4gfHxcbiAgICAgICAgICBzdGF0ZSA9PSAxICYmIGlucHV0Lm5leHQgPT0gc2xhc2ggfHxcbiAgICAgICAgICBzdGF0ZSA+PSAyICYmIHN0YXRlIDwgbGFzdFN0YXRlICYmIGlucHV0Lm5leHQgPT0gdGFnLmNoYXJDb2RlQXQoc3RhdGUgLSAyKSkge1xuICAgICAgICBzdGF0ZSsrO1xuICAgICAgICBtYXRjaGVkTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09IGxhc3RTdGF0ZSAmJiBpbnB1dC5uZXh0ID09IGdyZWF0ZXJUaGFuKSB7XG4gICAgICAgIGlmIChpID4gbWF0Y2hlZExlbilcbiAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4sIC1tYXRjaGVkTGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKGVuZFRva2VuLCAtKG1hdGNoZWRMZW4gLSAyKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKChpbnB1dC5uZXh0ID09IDEwIC8qICdcXG4nICovIHx8IGlucHV0Lm5leHQgPT0gMTMgLyogJ1xccicgKi8pICYmIGkpIHtcbiAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGV4dFRva2VuLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gbWF0Y2hlZExlbiA9IDA7XG4gICAgICB9XG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBzY3JpcHRUb2tlbnMgPSBjb250ZW50VG9rZW5pemVyKFwic2NyaXB0XCIsIHNjcmlwdFRleHQsIFN0YXJ0Q2xvc2VTY3JpcHRUYWcpO1xuXG5jb25zdCBzdHlsZVRva2VucyA9IGNvbnRlbnRUb2tlbml6ZXIoXCJzdHlsZVwiLCBzdHlsZVRleHQsIFN0YXJ0Q2xvc2VTdHlsZVRhZyk7XG5cbmNvbnN0IHRleHRhcmVhVG9rZW5zID0gY29udGVudFRva2VuaXplcihcInRleHRhcmVhXCIsIHRleHRhcmVhVGV4dCwgU3RhcnRDbG9zZVRleHRhcmVhVGFnKTtcblxuY29uc3QgaHRtbEhpZ2hsaWdodGluZyA9IHN0eWxlVGFncyh7XG4gIFwiVGV4dCBSYXdUZXh0IEluY29tcGxldGVUYWcgSW5jb21wbGV0ZUNsb3NlVGFnXCI6IHRhZ3MuY29udGVudCxcbiAgXCJTdGFydFRhZyBTdGFydENsb3NlVGFnIFNlbGZDbG9zaW5nRW5kVGFnIEVuZFRhZ1wiOiB0YWdzLmFuZ2xlQnJhY2tldCxcbiAgVGFnTmFtZTogdGFncy50YWdOYW1lLFxuICBcIk1pc21hdGNoZWRDbG9zZVRhZy9UYWdOYW1lXCI6IFt0YWdzLnRhZ05hbWUsICB0YWdzLmludmFsaWRdLFxuICBBdHRyaWJ1dGVOYW1lOiB0YWdzLmF0dHJpYnV0ZU5hbWUsXG4gIFwiQXR0cmlidXRlVmFsdWUgVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVwiOiB0YWdzLmF0dHJpYnV0ZVZhbHVlLFxuICBJczogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIFwiRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZVwiOiB0YWdzLmNoYXJhY3RlcixcbiAgQ29tbWVudDogdGFncy5ibG9ja0NvbW1lbnQsXG4gIFByb2Nlc3NpbmdJbnN0OiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbixcbiAgRG9jdHlwZURlY2w6IHRhZ3MuZG9jdW1lbnRNZXRhXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiLHhPVk8hck9PTyFaUSN0TycjQ3JPIWBRI3RPJyNDe08hZVEjdE8nI0RPTyFqUSN0TycjRFJPIW9RI3RPJyNEVE8hdE9hTycjQ3FPI1BPYk8nI0NxTyNbT2RPJyNDcU8ka08hck8nI0NxT09PYCcjQ3EnI0NxTyRyTyRmTycjRFVPJHpRI3RPJyNEV08lUFEjdE8nI0RYT09PYCcjRGwnI0RsT09PYCcjRFonI0RaUVZPIXJPT08lVVEmck8sNTleTyVhUSZyTyw1OWdPJWxRJnJPLDU5ak8ld1Emck8sNTltTyZTUSZyTyw1OW9PT09hJyNEXycjRF9PJl9PYU8nI0N5TyZqT2FPLDU5XU9PT2InI0RgJyNEYE8mck9iTycjQ3xPJn1PYk8sNTldT09PZCcjRGEnI0RhTydWT2RPJyNEUE8nYk9kTyw1OV1PT09gJyNEYicjRGJPJ2pPIXJPLDU5XU8ncVEjdE8nI0RTT09PYCw1OV0sNTldT09PcCcjRGMnI0RjTyd2TyRmTyw1OXBPT09gLDU5cCw1OXBPKE9RI3xPLDU5ck8oVFEjfE8sNTlzT09PYC1FN1gtRTdYTyhZUSZyTycjQ3RPT1FXJyNEWycjRFtPKGhRJnJPMUcueE9PT2ExRy54MUcueE9PT2AxRy9aMUcvWk8oc1Emck8xRy9ST09PYjFHL1IxRy9STylPUSZyTzFHL1VPT09kMUcvVTFHL1VPKVpRJnJPMUcvWE9PT2AxRy9YMUcvWE8pZlEmck8xRy9aT09PYS1FN10tRTddTylxUSN0TycjQ3pPT09gMUcudzFHLndPT09iLUU3Xi1FN15PKXZRI3RPJyNDfU9PT2QtRTdfLUU3X08pe1EjdE8nI0RRT09PYC1FN2AtRTdgTypRUSN8Tyw1OW5PT09wLUU3YS1FN2FPT09gMUcvWzFHL1tPT09gMUcvXjFHL15PT09gMUcvXzFHL19PKlZRLFVPLDU5YE9PUVctRTdZLUU3WU9PT2E3KyRkNyskZE9PT2A3KyR1NyskdU9PT2I3KyRtNyskbU9PT2Q3KyRwNyskcE9PT2A3KyRzNyskc08qYlEjfE8sNTlmTypnUSN8Tyw1OWlPKmxRI3xPLDU5bE9PT2AxRy9ZMUcvWU8qcU83W08nI0N3TytTT01oTycjQ3dPT1FXMUcuejFHLnpPT09gMUcvUTFHL1FPT09gMUcvVDFHL1RPT09gMUcvVzFHL1dPT09PJyNEXScjRF1PK2VPN1tPLDU5Y09PUVcsNTljLDU5Y09PT08nI0ReJyNEXk8rdk9NaE8sNTljT09PTy1FN1otRTdaT09RVzFHLn0xRy59T09PTy1FN1stRTdbXCIsXG4gIHN0YXRlRGF0YTogXCIsY35PIV9PU35PVVNPVlBPV1FPWFJPWVRPW11PXVtPXl5PX15PYV5PYl5PY15PZF5PeV5PfF9PIWVaT35PZ2FPfk9nYk9+T2djT35PZ2RPfk9nZU9+TyFYZk9QbVAhW21Qfk8hWWlPUXBQIVtwUH5PIVpsT1JzUCFbc1B+T1VTT1ZQT1dRT1hST1lUT1pxT1tdT11bT15eT19eT2FeT2JeT2NeT2ReT3leTyFlWk9+TyFbck9+UCNnTyFdc08hZnVPfk9ndk9+T2d3T35PU3xPVH1PaXlPfk9TIVBPVH1PaXlPfk9TIVJPVH1PaXlPfk9TIVRPVH1PaXlPfk9TfU9UfU9peU9+TyFYZk9QbVghW21Yfk9QIVdPIVshWE9+TyFZaU9RcFghW3BYfk9RIVpPIVshWE9+TyFabE9Sc1ghW3NYfk9SIV1PIVshWE9+TyFbIVhPflAjZ09nIV9Pfk8hXXNPIWYhYU9+T1MhYk9+T1MhY09+T2ohZE9TaFhUaFhpaFh+T1MhZk9UIWdPaXlPfk9TIWhPVCFnT2l5T35PUyFpT1QhZ09peU9+T1Mhak9UIWdPaXlPfk9TIWdPVCFnT2l5T35PZyFrT35PZyFsT35PZyFtT35PUyFuT35PbCFxTyFhIW9PIWMhcE9+T1Mhck9+T1Mhc09+T1MhdE9+T2IhdU9jIXVPZCF1TyFhIXdPIWIhdU9+T2IheE9jIXhPZCF4TyFjIXdPIWQheE9+T2IhdU9jIXVPZCF1TyFhIXtPIWIhdU9+T2IheE9jIXhPZCF4TyFjIXtPIWQheE9+T1R+Y2JkIWV5fCFlflwiLFxuICBnb3RvOiBcIiVxIWFQUFBQUFBQUFBQUFBQUFBQUFBQUFAhYiFoUCFuUFAhelAhfSNRI1QjWiNeI2EjZyNqI20jcyN5IWJQIWIhYlAkUCRWJG0kcyR5JVAlViVdJWNQUFBQUFBQUCVpWF5PWGBwWFVPWGBwZXphYmNkZXshTyFRIVMhVVIhcSFkUmhVUiFYaFhWT1hgcFJrVlIhWGtYV09YYHBSbldSIVhuWFhPWGBwUXJYUiFYcFhZT1hgcFFgT1J4YFF7YVEhT2JRIVFjUSFTZFEhVWVaIWV7IU8hUSFTIVVRIXYhb1IheiF2USF5IXBSIXwheVFnVVIhVmdRalZSIVlqUW1XUiFbbVFwWFIhXnBRdFpSIWB0U19PYFRvWHBcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBFbmRUYWcgU2VsZkNsb3NpbmdFbmRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgSW5jb21wbGV0ZVRhZyBJbmNvbXBsZXRlQ2xvc2VUYWcgRG9jdW1lbnQgVGV4dCBFbnRpdHlSZWZlcmVuY2UgQ2hhcmFjdGVyUmVmZXJlbmNlIEludmFsaWRFbnRpdHkgRWxlbWVudCBPcGVuVGFnIFRhZ05hbWUgQXR0cmlidXRlIEF0dHJpYnV0ZU5hbWUgSXMgQXR0cmlidXRlVmFsdWUgVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSBTY3JpcHRUZXh0IENsb3NlVGFnIE9wZW5UYWcgU3R5bGVUZXh0IENsb3NlVGFnIE9wZW5UYWcgVGV4dGFyZWFUZXh0IENsb3NlVGFnIE9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWcgQ29tbWVudCBQcm9jZXNzaW5nSW5zdCBNaXNtYXRjaGVkQ2xvc2VUYWcgQ2xvc2VUYWcgRG9jdHlwZURlY2xcIixcbiAgbWF4VGVybTogNjgsXG4gIGNvbnRleHQ6IGVsZW1lbnRDb250ZXh0LFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJjbG9zZWRCeVwiLCAtMTAsMSwyLDMsNyw4LDksMTAsMTEsMTIsMTMsXCJFbmRUYWdcIiw2LFwiRW5kVGFnIFNlbGZDbG9zaW5nRW5kVGFnXCIsLTQsMjIsMzEsMzQsMzcsXCJDbG9zZVRhZ1wiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCA0LFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZ1wiLDUsXCJTdGFydFRhZ1wiLC00LDMwLDMzLDM2LDM4LFwiT3BlblRhZ1wiXSxcbiAgICBbXCJncm91cFwiLCAtMTAsMTQsMTUsMTgsMTksMjAsMjEsNDAsNDEsNDIsNDMsXCJFbnRpdHlcIiwxNyxcIkVudGl0eSBUZXh0Q29udGVudFwiLC0zLDI5LDMyLDM1LFwiVGV4dENvbnRlbnQgRW50aXR5XCJdLFxuICAgIFtcImlzb2xhdGVcIiwgLTExLDIyLDMwLDMxLDMzLDM0LDM2LDM3LDM4LDM5LDQyLDQzLFwibHRyXCIsLTMsMjcsMjgsNDAsXCJcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtodG1sSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogOSxcbiAgdG9rZW5EYXRhOiBcIiE8cCFhUiFZT1gkcVhZLFFZWixRWlskcVtdJlhdXixRXnAkcXBxLFFxci1fcnMzX3N2LV92dzN9d3hIWXh9LV99IU9IeyFPIVAtXyFQIVEkcSFRIVstXyFbIV1NeiFdIV4tXyFeIV8hJFMhXyFgITt4IWAhYSZYIWEhYy1fIWMhfU16IX0jUi1fI1IjU016I1MjVDFrI1Qjb016I28jcy1fI3MkZiRxJGYlVy1fJVclb016JW8lcC1fJXAmYU16JmEmYi1fJmIxcE16MXA0VS1fNFU0ZE16NGQ0ZS1fNGUkSVNNeiRJUyRJYC1fJElgJEliTXokSWIkS2gtXyRLaCUjdE16JSN0Ji94LV8mL3gmRXRNeiZFdCZGVi1fJkZWOydTTXo7J1M7OmohI3w7Omo7PWAzWDwlbD8mci1fPyZyP0FoTXo/QWg/QlkkcT9CWT9Nbk16P01uTyRxIVokfGNhUGxXIWJgIWRwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXIkcXJzJn1zdiRxdncrUHd4KHR4IV4kcSFeIV8qViFfIWEmWCFhI1MkcSNTI1QmWCNUOydTJHE7J1M7PWArejwlbE8kcSFSJmJYYVAhYmAhZHBPciZYcnMmfXN2Jlh3eCh0eCFeJlghXiFfKlYhXzsnUyZYOydTOz1gKnk8JWxPJlhxJ1VWYVAhZHBPdiZ9d3gna3ghXiZ9IV4hXyhWIV87J1MmfTsnUzs9YChuPCVsTyZ9UCdwVGFQT3Yna3chXidrIV87J1MnazsnUzs9YChQPCVsTydrUChTUDs9YDwlbCdrcChbUyFkcE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnAoa1A7PWA8JWwoVnEocVA7PWA8JWwmfWEoe1dhUCFiYE9yKHRycydrc3YodHchXih0IV4hXyllIV87J1ModDsnUzs9YCpQPCVsTyh0YClqVCFiYE9yKWVzdilldzsnUyllOydTOz1gKXk8JWxPKWVgKXxQOz1gPCVsKWVhKlNQOz1gPCVsKHQhUSpeViFiYCFkcE9yKlZycyhWc3YqVnd4KWV4OydTKlY7J1M7PWAqczwlbE8qViFRKnZQOz1gPCVsKlYhUip8UDs9YDwlbCZYVytVWWxXT1grUFpbK1BecCtQcXIrUHN3K1B4IV4rUCFhI1MrUCNUOydTK1A7J1M7PWArdDwlbE8rUFcrd1A7PWA8JWwrUCFaK31QOz1gPCVsJHEhYSxdYGFQIWJgIWRwIV9eT1gmWFhZLFFZWixRWl0mWF1eLFFecCZYcHEsUXFyJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWCFfLWxqaVNhUGxXIWJgIWRwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4IVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWEmWCFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcVsvZWJpU2xXT1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUFMwclhpU3FyMG1zdzBteCFQMG0hUSFeMG0hYSNzMG0kZjsnUzBtOydTOz1gMV88JWw/QWgwbT9CWT9NbjBtUzFiUDs9YDwlbDBtWzFoUDs9YDwlbC9eIVYxdmNpU2FQIWJgIWRwT3EmWHFyMWtycyZ9c3Yxa3Z3MG13eCh0eCFQMWshUCFRJlghUSFeMWshXiFfKlYhXyFhJlghYSNzMWsjcyRmJlgkZjsnUzFrOydTOz1gM1I8JWw/QWgxaz9BaD9CWSZYP0JZP01uMWs/TW5PJlghVjNVUDs9YDwlbDFrIV8zW1A7PWA8JWwtXyFaM2hWIWFoYVAhZHBPdiZ9d3gna3ghXiZ9IV4hXyhWIV87J1MmfTsnUzs9YChuPCVsTyZ9IV80V2lpU2xXZCFST1g1dVhaN1NaWzV1W143U15wNXVxcjh0cnM3U3N0Pl10dzh0d3g3U3ghUDh0IVAhUTV1IVEhXTh0IV0hXi9eIV4hYTdTIWEjUzh0I1MjVDt7I1Qjczh0I3MkZjV1JGY7J1M4dDsnUzs9YD5WPCVsP0FoOHQ/QWg/Qlk1dT9CWT9Nbjh0P01uTzV1IVo1emJsV09YNXVYWjdTWls1dVteN1NecDV1cXI1dXJzN1NzdCtQdHc1dXd4N1N4IV01dSFdIV43dyFeIWE3UyFhI1M1dSNTI1Q3UyNUOydTNXU7J1M7PWA4bjwlbE81dSFSN1ZWT3A3U3FzN1N0IV03UyFdIV43bCFeOydTN1M7J1M7PWA3cTwlbE83UyFSN3FPYiFSIVI3dFA7PWA8JWw3UyFaOE9ZbFdiIVJPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQIVo4cVA7PWA8JWw1dSFfOHtpaVNsV09YNXVYWjdTWls1dVteN1NecDV1cXI4dHJzN1NzdC9edHc4dHd4N1N4IVA4dCFQIVE1dSFRIV04dCFdIV46aiFeIWE3UyFhI1M4dCNTI1Q7eyNUI3M4dCNzJGY1dSRmOydTOHQ7J1M7PWA+VjwlbD9BaDh0P0FoP0JZNXU/Qlk/TW44dD9Nbk81dSFfOnNiaVNsV2IhUk9YK1BaWytQXnArUHFyL15zdy9eeCFQL14hUCFRK1AhUSFeL14hYSNTL14jUyNUMG0jVCNzL14jcyRmK1AkZjsnUy9eOydTOz1gMWU8JWw/QWgvXj9BaD9CWStQP0JZP01uL14/TW5PK1AhVjxRY2lTT3A3U3FyO3tyczdTc3QwbXR3O3t3eDdTeCFQO3shUCFRN1MhUSFdO3shXSFePV0hXiFhN1MhYSNzO3sjcyRmN1MkZjsnUzt7OydTOz1gPlA8JWw/QWg7ez9BaD9CWTdTP0JZP01uO3s/TW5PN1MhVj1kWGlTYiFScXIwbXN3MG14IVAwbSFRIV4wbSFhI3MwbSRmOydTMG07J1M7PWAxXzwlbD9BaDBtP0JZP01uMG0hVj5TUDs9YDwlbDt7IV8+WVA7PWA8JWw4dCFfPmRoaVNsV09YQE9YWkFZWltAT1teQVlecEBPcXJCd3JzQVlzd0J3d3hBWXghUEJ3IVAhUUBPIVEhXUJ3IV0hXi9eIV4hYUFZIWEjU0J3I1MjVEV7I1Qjc0J3I3MkZkBPJGY7J1NCdzsnUzs9YEhTPCVsP0FoQnc/QWg/QllATz9CWT9NbkJ3P01uT0BPIVpAVGFsV09YQE9YWkFZWltAT1teQVlecEBPcXJAT3JzQVlzd0BPd3hBWXghXUBPIV0hXkF6IV4hYUFZIWEjU0BPI1MjVEFZI1Q7J1NATzsnUzs9YEJxPCVsT0BPIVJBXVVPcEFZcSFdQVkhXSFeQW8hXjsnU0FZOydTOz1gQXQ8JWxPQVkhUkF0T2MhUiFSQXdQOz1gPCVsQVkhWkJSWWxXYyFST1grUFpbK1BecCtQcXIrUHN3K1B4IV4rUCFhI1MrUCNUOydTK1A7J1M7PWArdDwlbE8rUCFaQnRQOz1gPCVsQE8hX0NPaGlTbFdPWEBPWFpBWVpbQE9bXkFZXnBAT3FyQndyc0FZc3dCd3d4QVl4IVBCdyFQIVFATyFRIV1CdyFdIV5EaiFeIWFBWSFhI1NCdyNTI1RFeyNUI3NCdyNzJGZATyRmOydTQnc7J1M7PWBIUzwlbD9BaEJ3P0FoP0JZQE8/Qlk/TW5Cdz9Nbk9ATyFfRHNiaVNsV2MhUk9YK1BaWytQXnArUHFyL15zdy9eeCFQL14hUCFRK1AhUSFeL14hYSNTL14jUyNUMG0jVCNzL14jcyRmK1AkZjsnUy9eOydTOz1gMWU8JWw/QWgvXj9BaD9CWStQP0JZP01uL14/TW5PK1AhVkZRYmlTT3BBWXFyRXtyc0FZc3dFe3d4QVl4IVBFeyFQIVFBWSFRIV1FeyFdIV5HWSFeIWFBWSFhI3NFeyNzJGZBWSRmOydTRXs7J1M7PWBHfDwlbD9BaEV7P0FoP0JZQVk/Qlk/TW5Fez9Nbk9BWSFWR2FYaVNjIVJxcjBtc3cwbXghUDBtIVEhXjBtIWEjczBtJGY7J1MwbTsnUzs9YDFfPCVsP0FoMG0/Qlk/TW4wbSFWSFBQOz1gPCVsRXshX0hWUDs9YDwlbEJ3IVpIY1chY3hhUCFiYE9yKHRycydrc3YodHchXih0IV4hXyllIV87J1ModDsnUzs9YCpQPCVsTyh0IWFJWWxpU2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHh9LV99IU9LUSFPIVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWEmWCFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcSFhS19raVNhUGxXIWJgIWRwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4IVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWAmWCFgIWFNUyFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcSFUTV9YYVAhYmAhZHAhZlFPciZYcnMmfXN2Jlh3eCh0eCFeJlghXiFfKlYhXzsnUyZYOydTOz1gKnk8JWxPJlghYU5aIVppU2dRYVBsVyFiYCFkcE9YJHFYWiZYWlskcVteJlhecCRxcHEmWHFyLV9ycyZ9c3YtX3Z3L153eCh0eH0tX30hT016IU8hUE16IVAhUSRxIVEhW016IVshXU16IV0hXi1fIV4hXypWIV8hYSZYIWEhYy1fIWMhfU16IX0jUi1fI1IjU016I1MjVDFrI1Qjb016I28jcy1fI3MkZiRxJGYkfS1fJH0lT016JU8lVy1fJVclb016JW8lcC1fJXAmYU16JmEmYi1fJmIxcE16MXA0VU16NFU0ZE16NGQ0ZS1fNGUkSVNNeiRJUyRJYC1fJElgJEliTXokSWIkSmUtXyRKZSRKZ016JEpnJEtoLV8kS2glI3RNeiUjdCYveC1fJi94JkV0TXomRXQmRlYtXyZGVjsnU016OydTOzpqISN8OzpqOz1gM1g8JWw/JnItXz8mcj9BaE16P0FoP0JZJHE/Qlk/TW5Nej9Nbk8kcSFhISRQUDs9YDwlbE16IVIhJFpZIWJgIWRwT3EqVnFyISR5cnMoVnN2KlZ3eClleCFhKlYhYSFiITR0IWI7J1MqVjsnUzs9YCpzPCVsTypWIVIhJVFdIWJgIWRwT3IqVnJzKFZzdipWd3gpZXh9KlZ9IU8hJXkhTyFmKlYhZiFnISddIWcjVypWI1cjWCEwYCNYOydTKlY7J1M7PWAqczwlbE8qViFSISZRWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4fSpWfSFPISZtIU87J1MqVjsnUzs9YCpzPCVsTypWIVIhJnZWIWJgIWRwIWVQT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVIhJ2RYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXghcSpWIXEhciEoUCFyOydTKlY7J1M7PWAqczwlbE8qViFSIShXWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4IWUqViFlIWYhKHMhZjsnUypWOydTOz1gKnM8JWxPKlYhUiEoelghYmAhZHBPcipWcnMoVnN2KlZ3eClleCF2KlYhdiF3ISlnIXc7J1MqVjsnUzs9YCpzPCVsTypWIVIhKW5YIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgheypWIXshfCEqWiF8OydTKlY7J1M7PWAqczwlbE8qViFSISpiWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4IXIqViFyIXMhKn0hczsnUypWOydTOz1gKnM8JWxPKlYhUiErVVghYmAhZHBPcipWcnMoVnN2KlZ3eClleCFnKlYhZyFoIStxIWg7J1MqVjsnUzs9YCpzPCVsTypWIVIhK3hZIWJgIWRwT3IhK3FycyEsaHN2IStxdnchLVN3eCEuW3ghYCErcSFgIWEhL2ohYTsnUyErcTsnUzs9YCEwWTwlbE8hK3FxISxtViFkcE92ISxodnghLVN4IWAhLGghYCFhIS1xIWE7J1MhLGg7J1M7PWAhLlU8JWxPISxoUCEtVlRPIWAhLVMhYCFhIS1mIWE7J1MhLVM7J1M7PWAhLWs8JWxPIS1TUCEta098UFAhLW5QOz1gPCVsIS1TcSEteFMhZHB8UE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnEhLlhQOz1gPCVsISxoYSEuYVghYmBPciEuW3JzIS1Tc3YhLlt2dyEtU3chYCEuWyFgIWEhLnwhYTsnUyEuWzsnUzs9YCEvZDwlbE8hLlthIS9UVCFiYHxQT3IpZXN2KWV3OydTKWU7J1M7PWApeTwlbE8pZWEhL2dQOz1gPCVsIS5bIVIhL3NWIWJgIWRwfFBPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiEwXVA7PWA8JWwhK3EhUiEwZ1ghYmAhZHBPcipWcnMoVnN2KlZ3eClleCNjKlYjYyNkITFTI2Q7J1MqVjsnUzs9YCpzPCVsTypWIVIhMVpYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgjVipWI1YjVyExdiNXOydTKlY7J1M7PWAqczwlbE8qViFSITF9WCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4I2gqViNoI2khMmojaTsnUypWOydTOz1gKnM8JWxPKlYhUiEycVghYmAhZHBPcipWcnMoVnN2KlZ3eClleCNtKlYjbSNuITNeI247J1MqVjsnUzs9YCpzPCVsTypWIVIhM2VYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgjZCpWI2QjZSE0USNlOydTKlY7J1M7PWAqczwlbE8qViFSITRYWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4I1gqViNYI1khK3EjWTsnUypWOydTOz1gKnM8JWxPKlYhUiE0e1khYmAhZHBPciE0dHJzITVrc3YhNHR2dyE2Vnd4IThdeCFhITR0IWEhYiE6XSFiOydTITR0OydTOz1gITtyPCVsTyE0dHEhNXBWIWRwT3YhNWt2eCE2VnghYSE1ayFhIWIhN1chYjsnUyE1azsnUzs9YCE4VjwlbE8hNWtQITZZVE8hYSE2ViFhIWIhNmkhYjsnUyE2VjsnUzs9YCE3UTwlbE8hNlZQITZsVE8hYCE2ViFgIWEhNnshYTsnUyE2VjsnUzs9YCE3UTwlbE8hNlZQITdRT3lQUCE3VFA7PWA8JWwhNlZxITddViFkcE92ITVrdnghNlZ4IWAhNWshYCFhITdyIWE7J1MhNWs7J1M7PWAhOFY8JWxPITVrcSE3eVMhZHB5UE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnEhOFlQOz1gPCVsITVrYSE4YlghYmBPciE4XXJzITZWc3YhOF12dyE2VnchYSE4XSFhIWIhOH0hYjsnUyE4XTsnUzs9YCE6VjwlbE8hOF1hITlTWCFiYE9yIThdcnMhNlZzdiE4XXZ3ITZWdyFgIThdIWAhYSE5byFhOydTIThdOydTOz1gITpWPCVsTyE4XWEhOXZUIWJgeVBPcillc3YpZXc7J1MpZTsnUzs9YCl5PCVsTyllYSE6WVA7PWA8JWwhOF0hUiE6ZFkhYmAhZHBPciE0dHJzITVrc3YhNHR2dyE2Vnd4IThdeCFgITR0IWAhYSE7UyFhOydTITR0OydTOz1gITtyPCVsTyE0dCFSITtdViFiYCFkcHlQT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVIhO3VQOz1gPCVsITR0IVYhPFRYalNhUCFiYCFkcE9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWFwiLFxuICB0b2tlbml6ZXJzOiBbc2NyaXB0VG9rZW5zLCBzdHlsZVRva2VucywgdGV4dGFyZWFUb2tlbnMsIGVuZFRhZywgdGFnU3RhcnQsIGNvbW1lbnRDb250ZW50LCAwLCAxLCAyLCAzLCA0LCA1XSxcbiAgdG9wUnVsZXM6IHtcIkRvY3VtZW50XCI6WzAsMTZdfSxcbiAgZGlhbGVjdHM6IHtub01hdGNoOiAwLCBzZWxmQ2xvc2luZzogNTE1fSxcbiAgdG9rZW5QcmVjOiA1MTdcbn0pO1xuXG5mdW5jdGlvbiBnZXRBdHRycyhvcGVuVGFnLCBpbnB1dCkge1xuICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBhdHQgb2Ygb3BlblRhZy5nZXRDaGlsZHJlbihBdHRyaWJ1dGUpKSB7XG4gICAgbGV0IG5hbWUgPSBhdHQuZ2V0Q2hpbGQoQXR0cmlidXRlTmFtZSksIHZhbHVlID0gYXR0LmdldENoaWxkKEF0dHJpYnV0ZVZhbHVlKSB8fCBhdHQuZ2V0Q2hpbGQoVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSk7XG4gICAgaWYgKG5hbWUpIGF0dHJzW2lucHV0LnJlYWQobmFtZS5mcm9tLCBuYW1lLnRvKV0gPVxuICAgICAgIXZhbHVlID8gXCJcIiA6IHZhbHVlLnR5cGUuaWQgPT0gQXR0cmlidXRlVmFsdWUgPyBpbnB1dC5yZWFkKHZhbHVlLmZyb20gKyAxLCB2YWx1ZS50byAtIDEpIDogaW5wdXQucmVhZCh2YWx1ZS5mcm9tLCB2YWx1ZS50byk7XG4gIH1cbiAgcmV0dXJuIGF0dHJzXG59XG5cbmZ1bmN0aW9uIGZpbmRUYWdOYW1lKG9wZW5UYWcsIGlucHV0KSB7XG4gIGxldCB0YWdOYW1lTm9kZSA9IG9wZW5UYWcuZ2V0Q2hpbGQoVGFnTmFtZSk7XG4gIHJldHVybiB0YWdOYW1lTm9kZSA/IGlucHV0LnJlYWQodGFnTmFtZU5vZGUuZnJvbSwgdGFnTmFtZU5vZGUudG8pIDogXCIgXCJcbn1cblxuZnVuY3Rpb24gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCB0YWdzKSB7XG4gIGxldCBhdHRycztcbiAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICBpZiAoIXRhZy5hdHRycyB8fCB0YWcuYXR0cnMoYXR0cnMgfHwgKGF0dHJzID0gZ2V0QXR0cnMobm9kZS5ub2RlLnBhcmVudC5maXJzdENoaWxkLCBpbnB1dCkpKSlcbiAgICAgIHJldHVybiB7cGFyc2VyOiB0YWcucGFyc2VyfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8vIHRhZ3M/OiB7XG4vLyAgIHRhZzogc3RyaW5nLFxuLy8gICBhdHRycz86ICh7W2F0dHI6IHN0cmluZ106IHN0cmluZ30pID0+IGJvb2xlYW4sXG4vLyAgIHBhcnNlcjogUGFyc2VyXG4vLyB9W11cbi8vIGF0dHJpYnV0ZXM/OiB7XG4vLyAgIG5hbWU6IHN0cmluZyxcbi8vICAgdGFnTmFtZT86IHN0cmluZyxcbi8vICAgcGFyc2VyOiBQYXJzZXJcbi8vIH1bXVxuIFxuZnVuY3Rpb24gY29uZmlndXJlTmVzdGluZyh0YWdzID0gW10sIGF0dHJpYnV0ZXMgPSBbXSkge1xuICBsZXQgc2NyaXB0ID0gW10sIHN0eWxlID0gW10sIHRleHRhcmVhID0gW10sIG90aGVyID0gW107XG4gIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgbGV0IGFycmF5ID0gdGFnLnRhZyA9PSBcInNjcmlwdFwiID8gc2NyaXB0IDogdGFnLnRhZyA9PSBcInN0eWxlXCIgPyBzdHlsZSA6IHRhZy50YWcgPT0gXCJ0ZXh0YXJlYVwiID8gdGV4dGFyZWEgOiBvdGhlcjtcbiAgICBhcnJheS5wdXNoKHRhZyk7XG4gIH1cbiAgbGV0IGF0dHJzID0gYXR0cmlidXRlcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbnVsbDtcbiAgZm9yIChsZXQgYXR0ciBvZiBhdHRyaWJ1dGVzKSAoYXR0cnNbYXR0ci5uYW1lXSB8fCAoYXR0cnNbYXR0ci5uYW1lXSA9IFtdKSkucHVzaChhdHRyKTtcblxuICByZXR1cm4gcGFyc2VNaXhlZCgobm9kZSwgaW5wdXQpID0+IHtcbiAgICBsZXQgaWQgPSBub2RlLnR5cGUuaWQ7XG4gICAgaWYgKGlkID09IFNjcmlwdFRleHQpIHJldHVybiBtYXliZU5lc3Qobm9kZSwgaW5wdXQsIHNjcmlwdClcbiAgICBpZiAoaWQgPT0gU3R5bGVUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCBzdHlsZSlcbiAgICBpZiAoaWQgPT0gVGV4dGFyZWFUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCB0ZXh0YXJlYSlcblxuICAgIGlmIChpZCA9PSBFbGVtZW50ICYmIG90aGVyLmxlbmd0aCkge1xuICAgICAgbGV0IG4gPSBub2RlLm5vZGUsIG9wZW4gPSBuLmZpcnN0Q2hpbGQsIHRhZ05hbWUgPSBvcGVuICYmIGZpbmRUYWdOYW1lKG9wZW4sIGlucHV0KSwgYXR0cnM7XG4gICAgICBpZiAodGFnTmFtZSkgZm9yIChsZXQgdGFnIG9mIG90aGVyKSB7XG4gICAgICAgIGlmICh0YWcudGFnID09IHRhZ05hbWUgJiYgKCF0YWcuYXR0cnMgfHwgdGFnLmF0dHJzKGF0dHJzIHx8IChhdHRycyA9IGdldEF0dHJzKG9wZW4sIGlucHV0KSkpKSkge1xuICAgICAgICAgIGxldCBjbG9zZSA9IG4ubGFzdENoaWxkO1xuICAgICAgICAgIGxldCB0byA9IGNsb3NlLnR5cGUuaWQgPT0gQ2xvc2VUYWcgPyBjbG9zZS5mcm9tIDogbi50bztcbiAgICAgICAgICBpZiAodG8gPiBvcGVuLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXJzZXI6IHRhZy5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbTogb3Blbi50bywgdG99XX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRycyAmJiBpZCA9PSBBdHRyaWJ1dGUpIHtcbiAgICAgIGxldCBuID0gbm9kZS5ub2RlLCBuYW1lTm9kZTtcbiAgICAgIGlmIChuYW1lTm9kZSA9IG4uZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IGF0dHJzW2lucHV0LnJlYWQobmFtZU5vZGUuZnJvbSwgbmFtZU5vZGUudG8pXTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIGZvciAobGV0IGF0dHIgb2YgbWF0Y2hlcykge1xuICAgICAgICAgIGlmIChhdHRyLnRhZ05hbWUgJiYgYXR0ci50YWdOYW1lICE9IGZpbmRUYWdOYW1lKG4ucGFyZW50LCBpbnB1dCkpIGNvbnRpbnVlXG4gICAgICAgICAgbGV0IHZhbHVlID0gbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGUuaWQgPT0gQXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWUuZnJvbSArIDE7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHZhbHVlLmxhc3RDaGlsZCwgdG8gPSB2YWx1ZS50byAtIChsYXN0ICYmIGxhc3QuaXNFcnJvciA/IDAgOiAxKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHJldHVybiB7cGFyc2VyOiBhdHRyLnBhcnNlciwgb3ZlcmxheTogW3tmcm9tLCB0b31dfVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZS5pZCA9PSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3BhcnNlcjogYXR0ci5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbTogdmFsdWUuZnJvbSwgdG86IHZhbHVlLnRvfV19XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0pXG59XG5cbmV4cG9ydCB7IGNvbmZpZ3VyZU5lc3RpbmcsIHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/html/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/javascript/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 316,\n  noSemiType = 317,\n  incdec = 1,\n  incdecPrefix = 2,\n  questionDot = 3,\n  JSXStartTag = 4,\n  insertSemi = 318,\n  spaces = 320,\n  newline = 321,\n  LineComment = 5,\n  BlockComment = 6,\n  Dialect_jsx = 0;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,\n               8201, 8202, 8232, 8233, 8239, 8287, 12288];\n\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44,\n      question = 63, dot = 46, bracketL = 91;\n\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: false,\n  shift(context, term) {\n    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline\n  },\n  strict: false\n});\n\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == braceR || next == -1 || stack.context)\n    input.acceptToken(insertSemi);\n}, {contextual: true, fallback: true});\n\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input, after;\n  if (space.indexOf(next) > -1) return\n  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return\n  if (next != braceR && next != semicolon && next != -1 && !stack.context)\n    input.acceptToken(noSemi);\n}, {contextual: true});\n\nconst noSemicolonType = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);\n}, {contextual: true});\n\nconst operatorToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == plus || next == minus) {\n    input.advance();\n    if (next == input.next) {\n      input.advance();\n      let mayPostfix = !stack.context && stack.canShift(incdec);\n      input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n    }\n  } else if (next == question && input.peek(1) == dot) {\n    input.advance(); input.advance();\n    if (input.next < 48 || input.next > 57) // No digit after\n      input.acceptToken(questionDot);\n  }\n}, {contextual: true});\n\nfunction identifierChar(ch, start) {\n  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 ||\n    !start && ch >= 48 && ch <= 57\n}\n\nconst jsx = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return\n  input.advance();\n  if (input.next == slash) return\n  // Scan for an identifier followed by a comma or 'extends', don't\n  // treat this as a start tag if present.\n  let back = 0;\n  while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n  if (identifierChar(input.next, true)) {\n    input.advance();\n    back++;\n    while (identifierChar(input.next, false)) { input.advance(); back++; }\n    while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n    if (input.next == comma) return\n    for (let i = 0;; i++) {\n      if (i == 7) {\n        if (!identifierChar(input.next, true)) return\n        break\n      }\n      if (input.next != \"extends\".charCodeAt(i)) break\n      input.advance();\n      back++;\n    }\n  }\n  input.acceptToken(JSXStartTag, -back);\n});\n\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case defer\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n  \"in of await yield void typeof delete instanceof as satisfies\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"let var const using function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n  \"with debugger new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n  super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n  this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n  null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n  Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n  \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  \"NewExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n  UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n  \"LineComment Hashbang\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n  BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n  ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n  CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n  Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n  \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n  \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n  \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n\n  TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n  TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n  \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"is keyof unique infer asserts\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n\n  JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,export:20, as:25, from:33, default:36, async:41, function:42, in:52, out:55, const:56, extends:60, this:64, true:72, false:72, null:84, void:88, typeof:92, super:108, new:142, delete:154, yield:163, await:167, class:172, public:235, private:235, protected:235, readonly:237, instanceof:256, satisfies:259, import:292, keyof:349, unique:353, infer:359, asserts:395, is:397, abstract:417, implements:419, type:421, let:424, var:426, using:429, interface:435, enum:439, namespace:445, module:447, declare:451, global:455, defer:471, for:476, of:485, while:488, with:492, do:496, if:500, else:502, switch:506, case:512, try:518, catch:522, finally:526, return:530, throw:534, break:538, continue:542, debugger:546};\nconst spec_word = {__proto__:null,async:129, get:131, set:133, declare:195, public:197, private:197, protected:197, static:199, abstract:201, override:203, readonly:209, accessor:211, new:401};\nconst spec_LessThan = {__proto__:null,\"<\":193};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]\",\n  stateData: \"()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~\",\n  goto: \"$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_\",\n  nodeNames: \"âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 380,\n  context: trackNewline,\n  nodeProps: [\n    [\"isolate\", -8,5,6,14,37,39,51,53,55,\"\"],\n    [\"group\", -26,9,17,19,68,207,211,215,216,218,221,224,234,237,243,245,247,249,252,258,264,266,268,270,272,274,275,\"Statement\",-34,13,14,32,35,36,42,51,54,55,57,62,70,72,76,80,82,84,85,110,111,120,121,136,139,141,142,143,144,145,147,148,167,169,171,\"Expression\",-23,31,33,37,41,43,45,173,175,177,178,180,181,182,184,185,186,188,189,190,201,203,205,206,\"Type\",-3,88,103,109,\"ClassItem\"],\n    [\"openedBy\", 23,\"<\",38,\"InterpolationStart\",56,\"[\",60,\"{\",73,\"(\",160,\"JSXStartCloseTag\"],\n    [\"closedBy\", -2,24,168,\">\",40,\"InterpolationEnd\",50,\"]\",61,\"}\",74,\")\",165,\"JSXEndTag\"]\n  ],\n  propSources: [jsHighlight],\n  skippedNodes: [0,5,6,278],\n  repeatNodeCount: 37,\n  tokenData: \"$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~\", 141, 340), new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~\", 25, 323)],\n  topRules: {\"Script\":[0,7],\"SingleExpression\":[1,276],\"SingleClassItem\":[2,277]},\n  dialects: {jsx: 0, ts: 15175},\n  dynamicPrecedences: {\"80\":1,\"82\":1,\"94\":1,\"169\":1,\"199\":1},\n  specialized: [{term: 327, get: (value) => spec_identifier[value] || -1},{term: 343, get: (value) => spec_word[value] || -1},{term: 95, get: (value) => spec_LessThan[value] || -1}],\n  tokenPrec: 15201\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDdEM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixxREFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDRCQUE0Qix3REFBaUI7QUFDN0MsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBLENBQUMsR0FBRyxpQ0FBaUM7O0FBRXJDLHdCQUF3Qix3REFBaUI7QUFDekMsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsaUJBQWlCOztBQUVyQiw0QkFBNEIsd0RBQWlCO0FBQzdDO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsMEJBQTBCLHdEQUFpQjtBQUMzQyxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakUsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsb0JBQW9CLDJEQUFTO0FBQzdCLDBCQUEwQixrREFBSTtBQUM5QixrR0FBa0csa0RBQUk7QUFDdEcsa0VBQWtFLGtEQUFJO0FBQ3RF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QiwwQkFBMEIsb0RBQW9ELEtBQUssR0FBRyxnQkFBZ0IsaUNBQWlDLDhDQUE4QyxLQUFLLEdBQUcsaURBQWlELDhDQUE4QyxLQUFLLEdBQUcsOEVBQThFLE1BQU0sR0FBRyx1Q0FBdUMsS0FBSyxHQUFHLHlGQUF5RixLQUFLLEdBQUcseUVBQXlFLEtBQUssR0FBRyx5RUFBeUUsS0FBSyxHQUFHLHlFQUF5RSxLQUFLLEdBQUcsOEVBQThFLCtDQUErQyw4Q0FBOEMsS0FBSyxHQUFHLGlEQUFpRCxvREFBb0QsS0FBSyxHQUFHLFlBQVkscUNBQXFDLDhDQUE4QyxLQUFLLEdBQUcsMERBQTBELG1CQUFtQixHQUFHLHdDQUF3QyxLQUFLLG1EQUFtRCxNQUFNLEdBQUcsaURBQWlELG1CQUFtQixHQUFHLHdDQUF3QyxLQUFLLG1EQUFtRCxNQUFNLEdBQUcsbUJBQW1CLGdCQUFnQixjQUFjLHlCQUF5QixnQkFBZ0IsS0FBSyxHQUFHLGlEQUFpRCwyREFBMkQsS0FBSyxHQUFHLG9EQUFvRCw4Q0FBOEMsS0FBSyxHQUFHLCtDQUErQyw4Q0FBOEMsS0FBSyxHQUFHLCtFQUErRSxrQkFBa0IsR0FBRyxzQ0FBc0MsSUFBSSw0SUFBNEksS0FBSyxHQUFHLCtDQUErQyxpQ0FBaUMsa0JBQWtCLEdBQUcsc0NBQXNDLElBQUksaURBQWlELEtBQUssR0FBRztBQUN4aGYsa0lBQWtJLHNEQUFlLCtEQUErRCxLQUFLLEdBQUcsNkVBQTZFLE1BQU0sTUFBTSw2RUFBNkUsaUNBQWlDLHNEQUFlLFdBQVc7QUFDemIsYUFBYSxvRUFBb0U7QUFDakYsYUFBYSxrQkFBa0I7QUFDL0IsdUJBQXVCLHFDQUFxQztBQUM1RCxpQkFBaUIsd0RBQXdELEVBQUUsa0RBQWtELEVBQUUscURBQXFEO0FBQ3BMO0FBQ0EsQ0FBQzs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1sZWFybmluZy1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0BsZXplci9qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanM/ZGQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAgfSBmcm9tICdAbGV6ZXIvbHInO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgbm9TZW1pID0gMzE2LFxuICBub1NlbWlUeXBlID0gMzE3LFxuICBpbmNkZWMgPSAxLFxuICBpbmNkZWNQcmVmaXggPSAyLFxuICBxdWVzdGlvbkRvdCA9IDMsXG4gIEpTWFN0YXJ0VGFnID0gNCxcbiAgaW5zZXJ0U2VtaSA9IDMxOCxcbiAgc3BhY2VzID0gMzIwLFxuICBuZXdsaW5lID0gMzIxLFxuICBMaW5lQ29tbWVudCA9IDUsXG4gIEJsb2NrQ29tbWVudCA9IDYsXG4gIERpYWxlY3RfanN4ID0gMDtcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplcnMgZm9yIEphdmFTY3JpcHQgdG9rZW5zIHRoYXQgY2FuJ3QgYmVcbiAgIGV4cHJlc3NlZCBieSBsZXplcidzIGJ1aWx0LWluIHRva2VuaXplci4gKi9cblxuY29uc3Qgc3BhY2UgPSBbOSwgMTAsIDExLCAxMiwgMTMsIDMyLCAxMzMsIDE2MCwgNTc2MCwgODE5MiwgODE5MywgODE5NCwgODE5NSwgODE5NiwgODE5NywgODE5OCwgODE5OSwgODIwMCxcbiAgICAgICAgICAgICAgIDgyMDEsIDgyMDIsIDgyMzIsIDgyMzMsIDgyMzksIDgyODcsIDEyMjg4XTtcblxuY29uc3QgYnJhY2VSID0gMTI1LCBzZW1pY29sb24gPSA1OSwgc2xhc2ggPSA0Nywgc3RhciA9IDQyLCBwbHVzID0gNDMsIG1pbnVzID0gNDUsIGx0ID0gNjAsIGNvbW1hID0gNDQsXG4gICAgICBxdWVzdGlvbiA9IDYzLCBkb3QgPSA0NiwgYnJhY2tldEwgPSA5MTtcblxuY29uc3QgdHJhY2tOZXdsaW5lID0gbmV3IENvbnRleHRUcmFja2VyKHtcbiAgc3RhcnQ6IGZhbHNlLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm0gPT0gTGluZUNvbW1lbnQgfHwgdGVybSA9PSBCbG9ja0NvbW1lbnQgfHwgdGVybSA9PSBzcGFjZXMgPyBjb250ZXh0IDogdGVybSA9PSBuZXdsaW5lXG4gIH0sXG4gIHN0cmljdDogZmFsc2Vcbn0pO1xuXG5jb25zdCBpbnNlcnRTZW1pY29sb24gPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQge25leHR9ID0gaW5wdXQ7XG4gIGlmIChuZXh0ID09IGJyYWNlUiB8fCBuZXh0ID09IC0xIHx8IHN0YWNrLmNvbnRleHQpXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oaW5zZXJ0U2VtaSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZSwgZmFsbGJhY2s6IHRydWV9KTtcblxuY29uc3Qgbm9TZW1pY29sb24gPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQge25leHR9ID0gaW5wdXQsIGFmdGVyO1xuICBpZiAoc3BhY2UuaW5kZXhPZihuZXh0KSA+IC0xKSByZXR1cm5cbiAgaWYgKG5leHQgPT0gc2xhc2ggJiYgKChhZnRlciA9IGlucHV0LnBlZWsoMSkpID09IHNsYXNoIHx8IGFmdGVyID09IHN0YXIpKSByZXR1cm5cbiAgaWYgKG5leHQgIT0gYnJhY2VSICYmIG5leHQgIT0gc2VtaWNvbG9uICYmIG5leHQgIT0gLTEgJiYgIXN0YWNrLmNvbnRleHQpXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obm9TZW1pKTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IG5vU2VtaWNvbG9uVHlwZSA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ID09IGJyYWNrZXRMICYmICFzdGFjay5jb250ZXh0KSBpbnB1dC5hY2NlcHRUb2tlbihub1NlbWlUeXBlKTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IG9wZXJhdG9yVG9rZW4gPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQge25leHR9ID0gaW5wdXQ7XG4gIGlmIChuZXh0ID09IHBsdXMgfHwgbmV4dCA9PSBtaW51cykge1xuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICBpZiAobmV4dCA9PSBpbnB1dC5uZXh0KSB7XG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICBsZXQgbWF5UG9zdGZpeCA9ICFzdGFjay5jb250ZXh0ICYmIHN0YWNrLmNhblNoaWZ0KGluY2RlYyk7XG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihtYXlQb3N0Zml4ID8gaW5jZGVjIDogaW5jZGVjUHJlZml4KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dCA9PSBxdWVzdGlvbiAmJiBpbnB1dC5wZWVrKDEpID09IGRvdCkge1xuICAgIGlucHV0LmFkdmFuY2UoKTsgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGlmIChpbnB1dC5uZXh0IDwgNDggfHwgaW5wdXQubmV4dCA+IDU3KSAvLyBObyBkaWdpdCBhZnRlclxuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4ocXVlc3Rpb25Eb3QpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5mdW5jdGlvbiBpZGVudGlmaWVyQ2hhcihjaCwgc3RhcnQpIHtcbiAgcmV0dXJuIGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA9PSA5NSB8fCBjaCA+PSAxOTIgfHxcbiAgICAhc3RhcnQgJiYgY2ggPj0gNDggJiYgY2ggPD0gNTdcbn1cblxuY29uc3QganN4ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgIT0gbHQgfHwgIXN0YWNrLmRpYWxlY3RFbmFibGVkKERpYWxlY3RfanN4KSkgcmV0dXJuXG4gIGlucHV0LmFkdmFuY2UoKTtcbiAgaWYgKGlucHV0Lm5leHQgPT0gc2xhc2gpIHJldHVyblxuICAvLyBTY2FuIGZvciBhbiBpZGVudGlmaWVyIGZvbGxvd2VkIGJ5IGEgY29tbWEgb3IgJ2V4dGVuZHMnLCBkb24ndFxuICAvLyB0cmVhdCB0aGlzIGFzIGEgc3RhcnQgdGFnIGlmIHByZXNlbnQuXG4gIGxldCBiYWNrID0gMDtcbiAgd2hpbGUgKHNwYWNlLmluZGV4T2YoaW5wdXQubmV4dCkgPiAtMSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICBpZiAoaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgdHJ1ZSkpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgYmFjaysrO1xuICAgIHdoaWxlIChpZGVudGlmaWVyQ2hhcihpbnB1dC5uZXh0LCBmYWxzZSkpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgICB3aGlsZSAoc3BhY2UuaW5kZXhPZihpbnB1dC5uZXh0KSA+IC0xKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gICAgaWYgKGlucHV0Lm5leHQgPT0gY29tbWEpIHJldHVyblxuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICBpZiAoaSA9PSA3KSB7XG4gICAgICAgIGlmICghaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgdHJ1ZSkpIHJldHVyblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0Lm5leHQgIT0gXCJleHRlbmRzXCIuY2hhckNvZGVBdChpKSkgYnJlYWtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGJhY2srKztcbiAgICB9XG4gIH1cbiAgaW5wdXQuYWNjZXB0VG9rZW4oSlNYU3RhcnRUYWcsIC1iYWNrKTtcbn0pO1xuXG5jb25zdCBqc0hpZ2hsaWdodCA9IHN0eWxlVGFncyh7XG4gIFwiZ2V0IHNldCBhc3luYyBzdGF0aWNcIjogdGFncy5tb2RpZmllcixcbiAgXCJmb3Igd2hpbGUgZG8gaWYgZWxzZSBzd2l0Y2ggdHJ5IGNhdGNoIGZpbmFsbHkgcmV0dXJuIHRocm93IGJyZWFrIGNvbnRpbnVlIGRlZmF1bHQgY2FzZSBkZWZlclwiOiB0YWdzLmNvbnRyb2xLZXl3b3JkLFxuICBcImluIG9mIGF3YWl0IHlpZWxkIHZvaWQgdHlwZW9mIGRlbGV0ZSBpbnN0YW5jZW9mIGFzIHNhdGlzZmllc1wiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJsZXQgdmFyIGNvbnN0IHVzaW5nIGZ1bmN0aW9uIGNsYXNzIGV4dGVuZHNcIjogdGFncy5kZWZpbml0aW9uS2V5d29yZCxcbiAgXCJpbXBvcnQgZXhwb3J0IGZyb21cIjogdGFncy5tb2R1bGVLZXl3b3JkLFxuICBcIndpdGggZGVidWdnZXIgbmV3XCI6IHRhZ3Mua2V5d29yZCxcbiAgVGVtcGxhdGVTdHJpbmc6IHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyksXG4gIHN1cGVyOiB0YWdzLmF0b20sXG4gIEJvb2xlYW5MaXRlcmFsOiB0YWdzLmJvb2wsXG4gIHRoaXM6IHRhZ3Muc2VsZixcbiAgbnVsbDogdGFncy5udWxsLFxuICBTdGFyOiB0YWdzLm1vZGlmaWVyLFxuICBWYXJpYWJsZU5hbWU6IHRhZ3MudmFyaWFibGVOYW1lLFxuICBcIkNhbGxFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IHRhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICBWYXJpYWJsZURlZmluaXRpb246IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gIExhYmVsOiB0YWdzLmxhYmVsTmFtZSxcbiAgUHJvcGVydHlOYW1lOiB0YWdzLnByb3BlcnR5TmFtZSxcbiAgUHJpdmF0ZVByb3BlcnR5TmFtZTogdGFncy5zcGVjaWFsKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9NZW1iZXJFeHByZXNzaW9uL1Byb3BlcnR5TmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgXCJGdW5jdGlvbkRlY2xhcmF0aW9uL1ZhcmlhYmxlRGVmaW5pdGlvblwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSkpLFxuICBcIkNsYXNzRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLmNsYXNzTmFtZSksXG4gIFwiTmV3RXhwcmVzc2lvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5jbGFzc05hbWUsXG4gIFByb3BlcnR5RGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3Muc3BlY2lhbCh0YWdzLnByb3BlcnR5TmFtZSkpLFxuICBVcGRhdGVPcDogdGFncy51cGRhdGVPcGVyYXRvcixcbiAgXCJMaW5lQ29tbWVudCBIYXNoYmFuZ1wiOiB0YWdzLmxpbmVDb21tZW50LFxuICBCbG9ja0NvbW1lbnQ6IHRhZ3MuYmxvY2tDb21tZW50LFxuICBOdW1iZXI6IHRhZ3MubnVtYmVyLFxuICBTdHJpbmc6IHRhZ3Muc3RyaW5nLFxuICBFc2NhcGU6IHRhZ3MuZXNjYXBlLFxuICBBcml0aE9wOiB0YWdzLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgTG9naWNPcDogdGFncy5sb2dpY09wZXJhdG9yLFxuICBCaXRPcDogdGFncy5iaXR3aXNlT3BlcmF0b3IsXG4gIENvbXBhcmVPcDogdGFncy5jb21wYXJlT3BlcmF0b3IsXG4gIFJlZ0V4cDogdGFncy5yZWdleHAsXG4gIEVxdWFsczogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIEFycm93OiB0YWdzLmZ1bmN0aW9uKHRhZ3MucHVuY3R1YXRpb24pLFxuICBcIjogU3ByZWFkXCI6IHRhZ3MucHVuY3R1YXRpb24sXG4gIFwiKCApXCI6IHRhZ3MucGFyZW4sXG4gIFwiWyBdXCI6IHRhZ3Muc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogdGFncy5icmFjZSxcbiAgXCJJbnRlcnBvbGF0aW9uU3RhcnQgSW50ZXJwb2xhdGlvbkVuZFwiOiB0YWdzLnNwZWNpYWwodGFncy5icmFjZSksXG4gIFwiLlwiOiB0YWdzLmRlcmVmT3BlcmF0b3IsXG4gIFwiLCA7XCI6IHRhZ3Muc2VwYXJhdG9yLFxuICBcIkBcIjogdGFncy5tZXRhLFxuXG4gIFR5cGVOYW1lOiB0YWdzLnR5cGVOYW1lLFxuICBUeXBlRGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MudHlwZU5hbWUpLFxuICBcInR5cGUgZW51bSBpbnRlcmZhY2UgaW1wbGVtZW50cyBuYW1lc3BhY2UgbW9kdWxlIGRlY2xhcmVcIjogdGFncy5kZWZpbml0aW9uS2V5d29yZCxcbiAgXCJhYnN0cmFjdCBnbG9iYWwgUHJpdmFjeSByZWFkb25seSBvdmVycmlkZVwiOiB0YWdzLm1vZGlmaWVyLFxuICBcImlzIGtleW9mIHVuaXF1ZSBpbmZlciBhc3NlcnRzXCI6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuXG4gIEpTWEF0dHJpYnV0ZVZhbHVlOiB0YWdzLmF0dHJpYnV0ZVZhbHVlLFxuICBKU1hUZXh0OiB0YWdzLmNvbnRlbnQsXG4gIFwiSlNYU3RhcnRUYWcgSlNYU3RhcnRDbG9zZVRhZyBKU1hTZWxmQ2xvc2VFbmRUYWcgSlNYRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBcIkpTWElkZW50aWZpZXIgSlNYTmFtZVNwYWNlZE5hbWVcIjogdGFncy50YWdOYW1lLFxuICBcIkpTWEF0dHJpYnV0ZS9KU1hJZGVudGlmaWVyIEpTWEF0dHJpYnV0ZS9KU1hOYW1lU3BhY2VkTmFtZVwiOiB0YWdzLmF0dHJpYnV0ZU5hbWUsXG4gIFwiSlNYQnVpbHRpbi9KU1hJZGVudGlmaWVyXCI6IHRhZ3Muc3RhbmRhcmQodGFncy50YWdOYW1lKVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGV4cG9ydDoyMCwgYXM6MjUsIGZyb206MzMsIGRlZmF1bHQ6MzYsIGFzeW5jOjQxLCBmdW5jdGlvbjo0MiwgaW46NTIsIG91dDo1NSwgY29uc3Q6NTYsIGV4dGVuZHM6NjAsIHRoaXM6NjQsIHRydWU6NzIsIGZhbHNlOjcyLCBudWxsOjg0LCB2b2lkOjg4LCB0eXBlb2Y6OTIsIHN1cGVyOjEwOCwgbmV3OjE0MiwgZGVsZXRlOjE1NCwgeWllbGQ6MTYzLCBhd2FpdDoxNjcsIGNsYXNzOjE3MiwgcHVibGljOjIzNSwgcHJpdmF0ZToyMzUsIHByb3RlY3RlZDoyMzUsIHJlYWRvbmx5OjIzNywgaW5zdGFuY2VvZjoyNTYsIHNhdGlzZmllczoyNTksIGltcG9ydDoyOTIsIGtleW9mOjM0OSwgdW5pcXVlOjM1MywgaW5mZXI6MzU5LCBhc3NlcnRzOjM5NSwgaXM6Mzk3LCBhYnN0cmFjdDo0MTcsIGltcGxlbWVudHM6NDE5LCB0eXBlOjQyMSwgbGV0OjQyNCwgdmFyOjQyNiwgdXNpbmc6NDI5LCBpbnRlcmZhY2U6NDM1LCBlbnVtOjQzOSwgbmFtZXNwYWNlOjQ0NSwgbW9kdWxlOjQ0NywgZGVjbGFyZTo0NTEsIGdsb2JhbDo0NTUsIGRlZmVyOjQ3MSwgZm9yOjQ3Niwgb2Y6NDg1LCB3aGlsZTo0ODgsIHdpdGg6NDkyLCBkbzo0OTYsIGlmOjUwMCwgZWxzZTo1MDIsIHN3aXRjaDo1MDYsIGNhc2U6NTEyLCB0cnk6NTE4LCBjYXRjaDo1MjIsIGZpbmFsbHk6NTI2LCByZXR1cm46NTMwLCB0aHJvdzo1MzQsIGJyZWFrOjUzOCwgY29udGludWU6NTQyLCBkZWJ1Z2dlcjo1NDZ9O1xuY29uc3Qgc3BlY193b3JkID0ge19fcHJvdG9fXzpudWxsLGFzeW5jOjEyOSwgZ2V0OjEzMSwgc2V0OjEzMywgZGVjbGFyZToxOTUsIHB1YmxpYzoxOTcsIHByaXZhdGU6MTk3LCBwcm90ZWN0ZWQ6MTk3LCBzdGF0aWM6MTk5LCBhYnN0cmFjdDoyMDEsIG92ZXJyaWRlOjIwMywgcmVhZG9ubHk6MjA5LCBhY2Nlc3NvcjoyMTEsIG5ldzo0MDF9O1xuY29uc3Qgc3BlY19MZXNzVGhhbiA9IHtfX3Byb3RvX186bnVsbCxcIjxcIjoxOTN9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIiRGfFElVFFsT09PJVtRbE9PTydfUXBPT1AobE9gT09PKnpRITBNeE8nI0NpTytSTyN0TycjQ2pPK2FPJmpPJyNDak8rb08jQEl0TycjRGFPLlFRbE8nI0RnTy5iUWxPJyNEck8lW1FsTycjRHpPMGZRbE8nI0VTT09RITBMZicjRVsnI0VbTzFQUWBPJyNFWE9PUU8nI0VwJyNFcE9PUU8nI0lsJyNJbE8xWFFgTycjR3NPMWRRYE8nI0VvTzFpUWBPJyNFb08zaFEhME14TycjSnJPNltRITBNeE8nI0pzTzZ1UWBPJyNGXU82elEsVU8nI0Z0T09RITBMZicjRmYnI0ZmTzdWTzdkTycjRmZPOVhRTWhPJyNGfE85YFFgTycjRntPT1EhMExmJyNKcycjSnNPT1EhMExiJyNKcicjSnJPOWVRYE8nI0d3T09RWycjS18nI0tfTzlwUWBPJyNJWU85dVEhMExyTycjSVpPT1FbJyNKYCcjSmBPT1FbJyNJXycjSV9RYFFsT09RYFFsT09POX1RIUxeTycjRHZPOlVRbE8nI0VPTzpdUWxPJyNFUU85a1FgTycjR3NPOmRRTWhPJyNDb086clFgTycjRW5POn1RYE8nI0V5TztoUU1oTycjRmVPO3hRYE8nI0dzT09RTycjS2AnI0tgTzt9UWBPJyNLYE88XVFgTycjR3tPPF1RYE8nI0d8TzxdUWBPJyNIT085a1FgTycjSFJPPVNRYE8nI0hVTz5rUWBPJyNDZU8+e1FgTycjSGNPP1RRYE8nI0hpTz9UUWBPJyNIa09gUWxPJyNIbU8/VFFgTycjSG9PP1RRYE8nI0hyTz9ZUWBPJyNIeE8/X1EhMExzTycjSU9PJVtRbE8nI0lRTz9qUSEwTHNPJyNJU08/dVEhMExzTycjSVVPOXVRITBMck8nI0lXT0BRUSEwTXhPJyNDaU9BU1FwTycjRGxRT1FgT09PJVtRbE8nI0VRT0FqUWBPJyNFVE86ZFFNaE8nI0VuT0F1UWBPJyNFbk9CUVEhYk8nI0ZlT09RWycjQ2cnI0NnT09RITBMYicjRHEnI0RxT09RITBMYicjSnYnI0p2TyVbUWxPJyNKdk9PUU8nI0p5JyNKeU9PUU8nI0loJyNJaE9DUVFwTycjRWdPT1EhMExiJyNFZicjRWZPT1EhMExiJyNKfScjSn1PQ3xRITBNU08nI0VnT0RXUXBPJyNFV09PUU8nI0p4JyNKeE9EbFFwTycjSnlPRXlRcE8nI0VXT0RXUXBPJyNFZ1BGV08mMkRqTycjQ2JQT09PKUNEfSlDRH1PT09PJyNJYCcjSWBPRmNPI3RPLDU5VU9PUSEwTGgsNTlVLDU5VU9PT08nI0lhJyNJYU9GcU8mak8sNTlVT0dQUSFMXk8nI0RjT09PTycjSWMnI0ljT0dXTyNASXRPLDU5e09PUSEwTGYsNTl7LDU5e09HZlFsTycjSWRPR3lRYE8nI0p0T0l4USFmTycjSnRPK31RbE8nI0p0T0pQUWBPLDU6Uk9KZ1FgTycjRXBPSnRRYE8nI0tUT0tQUWBPJyNLU09LUFFgTycjS1NPS1hRYE8sNTteT0teUWBPJyNLUk9PUSEwTG4sNTpeLDU6Xk9LZVFsTyw1Ol5PTWNRITBNeE8sNTpmT05TUWBPLDU6bk9ObVEhMExyTycjS1FPTnRRYE8nI0tQTzllUWBPJyNLUE8hIFlRYE8nI0tQTyEgYlFgTyw1O11PISBnUWBPJyNLUE8hI2xRIWZPJyNKc09PUSEwTGgnI0NpJyNDaU8lW1FsTycjRVNPISRbUSFmTyw1OnNPT1FTJyNKeicjSnpPT1FPLUU8ai1FPGpPOWtRYE8sNT1fTyEkclFgTyw1PV9PISR3UWxPLDU7Wk8hJnpRTWhPJyNFa08hKGVRYE8sNTtaTyEoalFsTycjRHlPISh0UXBPLDU7ZE8hKHxRcE8sNTtkTyVbUWxPLDU7ZE9PUVsnI0ZUJyNGVE9PUVsnI0ZWJyNGVk8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPT1FbJyNGWicjRlpPISlbUWxPLDU7dE9PUSEwTGYsNTt5LDU7eU9PUSEwTGYsNTt6LDU7ek9PUSEwTGYsNTt8LDU7fE8lW1FsTycjSXBPIStfUSEwTHJPLDU8aU8lW1FsTyw1O2VPISZ6UU1oTyw1O2VPISt8UU1oTyw1O2VPIS1uUU1oTycjRV5PJVtRbE8sNTt3T09RITBMZiw1O3ssNTt7TyEtdVEsVU8nI0ZqTyEuclEsVU8nI0tYTyEuXlEsVU8nI0tYTyEueVEsVU8nI0tYT09RTycjS1gnI0tYTyEvX1EsVU8sNTxTT09PVyw1PGAsNTxgTyEvcFFsTycjRnZPT09XJyNJbycjSW9PN1ZPN2RPLDU8UU8hL3dRLFVPJyNGeE9PUSEwTGYsNTxRLDU8UU8hMGhRJElVTycjQ3lPT1EhMExoJyNDfScjQ31PITB7TyNASXRPJyNEUk8hMWlRTWpPLDU8ZU8hMXBRYE8sNTxoTyEzWVEoQ1dPJyNHWE8hM2pRYE8nI0dZTyEzb1FgTycjR1lPITVfUShDV08nI0deTyE2ZFFwTycjR2JPT1FPJyNHbicjR25PISxUUU1oTycjR21PT1FPJyNHcCcjR3BPISxUUU1oTycjR29PITdWUSRJVU8nI0psT09RITBMaCcjSmwnI0psTyE3YVFgTycjSmtPITdvUWBPJyNKak8hN3dRYE8nI0N1T09RITBMaCcjQ3snI0N7TyE4WVFgTycjQ31PT1EhMExoJyNEVicjRFZPT1EhMExoJyNEWCcjRFhPIThfUWBPLDU8ZU8xU1FgTycjRFpPISxUUU1oTycjR1BPISxUUU1oTycjR1JPIThnUWBPJyNHVE8hOGxRYE8nI0dVTyEzb1FgTycjR1tPISxUUU1oTycjR2FPPF1RYE8nI0prTyE4cVFgTycjRXFPITlgUWBPLDU8Z09PUSEwTGInI0NyJyNDck8hOWhRYE8nI0VyTyE6YlFwTycjRXNPT1EhMExiJyNLUicjS1JPITppUSEwTHJPJyNLYU85dVEhMExyTyw1PWNPYFFsTyw1PnRPT1FbJyNKaCcjSmhPT1FbLDU+dSw1PnVPT1FbLUU8XS1FPF1PITxoUSEwTXhPLDU6Yk8hOl1RcE8sNTpgTyE/UlEhME14Tyw1OmpPJVtRbE8sNTpqTyFBaVEhME14Tyw1OmxPT1FPLDVAeiw1QHpPIUJZUU1oTyw1PV9PIUJoUSEwTHJPJyNKaU85YFFgTycjSmlPIUJ5USEwTHJPLDU5Wk8hQ1VRcE8sNTlaTyFDXlFNaE8sNTlaTzpkUU1oTyw1OVpPIUNpUWBPLDU7Wk8hQ3FRYE8nI0hiTyFEVlFgTycjS2RPJVtRbE8sNTt9TyE6XVFwTyw1PFBPIURfUWBPLDU9ek8hRGRRYE8sNT16TyFEaVFgTyw1PXpPIUR3UWBPLDU9ek85dVEhMExyTyw1PXpPPF1RYE8sNT1qT09RTycjQ3knI0N5TyFFT1FwTyw1PWdPIUVXUU1oTyw1PWhPIUVjUWBPLDU9ak8hRWhRIWJPLDU9bU8hRXBRYE8nI0tgTz9ZUWBPJyNIV085a1FgTycjSFlPIUV1UWBPJyNIWU86ZFFNaE8nI0hbTyFFelFgTycjSFtPT1FbLDU9cCw1PXBPIUZQUWBPJyNIXU8hRmJRYE8nI0NvTyFGZ1FgTyw1OVBPIUZxUWBPLDU5UE8hSHZRbE8sNTlQT09RWyw1OVAsNTlQTyFJV1EhMExyTyw1OVBPJVtRbE8sNTlQTyFLY1FsTycjSGVPT1FbJyNIZicjSGZPT1FbJyNIZycjSGdPYFFsTyw1PX1PIUt5UWBPLDU9fU9gUWxPLDU+VE9gUWxPLDU+Vk8hTE9RYE8sNT5YT2BRbE8sNT5aTyFMVFFgTyw1Pl5PIUxZUWxPLDU+ZE9PUVssNT5qLDU+ak8lW1FsTyw1PmpPOXVRITBMck8sNT5sT09RWyw1Pm4sNT5uTyMhZFFgTyw1Pm5PT1FbLDU+cCw1PnBPIyFkUWBPLDU+cE9PUVssNT5yLDU+ck8jI1FRcE8nI0RfTyVbUWxPJyNKdk8jI3NRcE8nI0p2TyMjfVFwTycjRG1PIyRgUXBPJyNEbU8jJnFRbE8nI0RtTyMmeFFgTycjSnVPIydRUWBPLDU6V08jJ1ZRYE8nI0V0TyMnZVFgTycjS1VPIydtUWBPLDU7X08jJ3JRcE8nI0RtTyMoUFFwTycjRVZPT1EhMExmLDU6byw1Om9PJVtRbE8sNTpvTyMoV1FgTyw1Om9PP1lRYE8sNTtZTyFDVVFwTyw1O1lPIUNeUU1oTyw1O1lPOmRRTWhPLDU7WU8jKGBRYE8sNUBiTyMoZVEwN2RPLDU6c09PUU8tRTxmLUU8Zk8jKWtRITBNU08sNTtST0RXUXBPLDU6ck8jKXVRcE8sNTpyT0RXUXBPLDU7Uk8hQnlRITBMck8sNTpyT09RITBMYicjRWonI0VqT09RTyw1O1IsNTtSTyVbUWxPLDU7Uk8jKlNRITBMck8sNTtSTyMqX1EhMExyTyw1O1JPIUNVUXBPLDU6ck9PUU8sNTtYLDU7WE8jKm1RITBMck8sNTtSUE9PTycjSV4nI0leUCMrUk8mMkRqTyw1OHxQT09PLDU4fCw1OHxPT09PLUU8Xi1FPF5PT1EhMExoMUcucDFHLnBPT09PLUU8Xy1FPF9PT09PLDU5fSw1OX1PIyteUSFiTyw1OX1PT09PLUU8YS1FPGFPT1EhMExmMUcvZzFHL2dPIytjUSFmTyw1P09PK31RbE8sNT9PT09RTyw1P1UsNT9VTyMrbVFsTycjSWRPT1FPLUU8Yi1FPGJPIyt6UWBPLDVAYE8jLFNRIWZPLDVAYE8jLFpRYE8sNUBuT09RITBMZjFHL20xRy9tTyVbUWxPLDVAb08jLGNRYE8nI0lqT09RTy1FPGgtRTxoTyMsWlFgTyw1QG5PT1EhMExiMUcweDFHMHhPT1EhMExuMUcveDFHL3hPT1EhMExuMUcwWTFHMFlPJVtRbE8sNUBsTyMsd1EhMExyTyw1QGxPIy1ZUSEwTHJPLDVAbE8jLWFRYE8sNUBrTzllUWBPLDVAa08jLWlRYE8sNUBrTyMtd1FgTycjSW1PIy1hUWBPLDVAa09PUSEwTGIxRzB3MUcwd08hKHRRcE8sNTp1TyEpUFFwTyw1OnVPT1FTLDU6dyw1OndPIy5pUWRPLDU6d08jLnFRTWhPMUcyeU85a1FgTzFHMnlPT1EhMExmMUcwdTFHMHVPIy9QUSEwTXhPMUcwdU8jMFVRITBNdk8sNTtWT09RITBMaCcjR1cnI0dXTyMwclEhME16TycjSmxPISR3UWxPMUcwdU8jMn1RIWZPJyNKd08lW1FsTycjSndPIzNYUWBPLDU6ZU9PUSEwTGgnI0RfJyNEX09PUSEwTGYxRzFPMUcxT08lW1FsTzFHMU9PT1EhMExmMUcxZjFHMWZPIzNeUWBPMUcxT08jNXJRITBNeE8xRzFQTyM1eVEhME14TzFHMVBPIzhhUSEwTXhPMUcxUE8jOGhRITBNeE8xRzFQTyM7T1EhME14TzFHMVBPIz1mUSEwTXhPMUcxUE8jPW1RITBNeE8xRzFQTyM9dFEhME14TzFHMVBPI0BbUSEwTXhPMUcxUE8jQGNRITBNeE8xRzFQTyNCcFE/TXRPJyNDaU8jRGtRP010TzFHMWBPI0RyUT9NdE8nI0pzTyNFVlEhME14Tyw1P1tPT1EhMExiLUU8bi1FPG5PI0dkUSEwTXhPMUcxUE8jSGFRITBNek8xRzFQT09RITBMZjFHMVAxRzFQTyNJZFFNak8nI0p8TyNJblFgTyw1OnhPI0lzUSEwTXhPMUcxY08jSmdRLFVPLDU8V08jSm9RLFVPLDU8WE8jSndRLFVPJyNGb08jS2BRYE8nI0ZuT09RTycjS1knI0tZT09RTycjSW4nI0luTyNLZVEsVU8xRzFuT09RITBMZjFHMW4xRzFuT09PVzFHMXkxRzF5TyNLdlE/TXRPJyNKck8jTFFRYE8sNTxiTyEpW1FsTyw1PGJPT09XLUU8bS1FPG1PT1EhMExmMUcxbDFHMWxPI0xWUXBPJyNLWE9PUSEwTGYsNTxkLDU8ZE8jTF9RcE8sNTxkTyNMZFFNaE8nI0RUT09PTycjSWInI0liTyNMa08jQEl0Tyw1OW1PT1EhMExoLDU5bSw1OW1PJVtRbE8xRzJQTyE4bFFgTycjSXJPI0x2UWBPLDU8ek9PUSEwTGgsNTx3LDU8d08hLFRRTWhPJyNJdU8jTWRRTWpPLDU9WE8hLFRRTWhPJyNJd08jTlZRTWpPLDU9Wk8hJnpRTWhPLDU9XU9PUU8xRzJTMUcyU08jTmFRIWRPJyNDck8jTnRRKENXTycjRXJPJCB8UXBPJyNHYk8kIWRRIWRPLDU8c08kIWtRYE8nI0tbTzllUWBPJyNLW08kIXlRYE8sNTx1TyQjYVEhZE8nI0N7TyEsVFFNaE8sNTx0TyQja1FgTycjR1pPJCRQUWBPLDU8dE8kJFVRIWRPJyNHV08kJGNRIWRPJyNLXU8kJG1RYE8nI0tdTyEmelFNaE8nI0tdTyQkclFgTyw1PHhPJCR3UWxPJyNKdk8kJVJRcE8nI0djTyMkYFFwTycjR2NPJCVkUWBPJyNHZ08hM29RYE8nI0drTyQlaVEhMExyTycjSXRPJCV0UXBPLDU8fE9PUSEwTHAsNTx8LDU8fE8kJXtRcE8nI0djTyQmWVFwTycjR2RPJCZrUXBPJyNHZE8kJnBRTWpPLDU9WE8kJ1FRTWpPLDU9Wk9PUSEwTGgsNT1eLDU9Xk8hLFRRTWhPLDVAVk8hLFRRTWhPLDVAVk8kJ2JRYE8nI0l5TyQndlFgTyw1QFVPJChPUWBPLDU5YU9PUSEwTGgsNTlpLDU5aU8kKFRRYE8sNUBWTyQpVFEkSVlPLDU5dU9PUSEwTGgnI0pwJyNKcE8kKXZRTWpPLDU8a08kKmlRTWpPLDU8bU9AelFgTyw1PG9PT1EhMExoLDU8cCw1PHBPJCpzUWBPLDU8dk8kKnhRTWpPLDU8e08kK1lRYE8nI0tQTyEkd1FsTzFHMlJPJCtfUWBPMUcyUk85ZVFgTycjS1NPOWVRYE8nI0V0TyVbUWxPJyNFdE85ZVFgTycjSXtPJCtkUSEwTHJPLDVAe09PUVsxRzJ9MUcyfU9PUVsxRzRgMUc0YE9PUSEwTGYxRy98MUcvfE9PUSEwTGYxRy96MUcvek8kLWZRITBNeE8xRzBVT09RWzFHMnkxRzJ5TyEmelFNaE8xRzJ5TyVbUWxPMUcyeU8jLnRRYE8xRzJ5TyQvalFNaE8nI0VrT09RITBMYiw1QFQsNUBUTyQvd1EhMExyTyw1QFRPT1FbMUcudTFHLnVPIUJ5USEwTHJPMUcudU8hQ1VRcE8xRy51TyFDXlFNaE8xRy51TyQwWVFgTzFHMHVPJDBfUWBPJyNDaU8kMGpRYE8nI0tlTyQwclFgTyw1PXxPJDB3UWBPJyNLZU8kMHxRYE8nI0tlTyQxW1FgTycjSlJPJDFqUWBPLDVBT08kMXJRIWZPMUcxaU9PUSEwTGYxRzFrMUcxa085a1FgTzFHM2ZPQHpRYE8xRzNmTyQxeVFgTzFHM2ZPJDJPUWBPMUczZk8hRGlRYE8xRzNmTzl1USEwTHJPMUczZk9PUVsxRzNmMUczZk8hRWNRYE8xRzNVTyEmelFNaE8xRzNSTyQyVFFgTzFHM1JPT1FbMUczUzFHM1NPISZ6UU1oTzFHM1NPJDJZUWBPMUczU08kMmJRcE8nI0hRT09RWzFHM1UxRzNVTyE2X1FwTycjSX1PIUVoUSFiTzFHM1hPT1FbMUczWDFHM1hPT1FbLDU9ciw1PXJPJDJqUU1oTyw1PXRPOWtRYE8sNT10TyQlZFFgTyw1PXZPOWBRYE8sNT12TyFDVVFwTyw1PXZPIUNeUU1oTyw1PXZPOmRRTWhPLDU9dk8kMnhRYE8nI0tjTyQzVFFgTyw1PXdPT1FbMUcuazFHLmtPJDNZUSEwTHJPMUcua09AelFgTzFHLmtPJDNlUWBPMUcua085dVEhMExyTzFHLmtPJDVtUSFmTyw1QVFPJDV6UWBPLDVBUU85ZVFgTyw1QVFPJDZWUWxPLDU+UE8kNl5RYE8sNT5QT09RWzFHM2kxRzNpT2BRbE8xRzNpT09RWzFHM28xRzNvT09RWzFHM3ExRzNxTz9UUWBPMUczc08kNmNRbE8xRzN1TyQ6Z1FsTycjSHRPT1FbMUczeDFHM3hPJDp0UWBPJyNIek8/WVFgTycjSHxPT1FbMUc0TzFHNE9PJDp8UWxPMUc0T085dVEhMExyTzFHNFVPT1FbMUc0VzFHNFdPT1EhMExiJyNHXycjR19POXVRITBMck8xRzRZTzl1USEwTHJPMUc0W08kP1RRYE8sNUBiTyEpW1FsTyw1O2BPOWVRYE8sNTtgTz9ZUWBPLDU6WE8hKVtRbE8sNTpYTyFDVVFwTyw1OlhPJD9ZUT9NdE8sNTpYT09RTyw1O2AsNTtgTyQ/ZFFwTycjSWVPJD96UWBPLDVAYU9PUSEwTGYxRy9yMUcvck8kQFNRcE8nI0lrTyRAXlFgTyw1QHBPT1EhMExiMUcweTFHMHlPIyRgUXBPLDU6WE9PUU8nI0lnJyNJZ08kQGZRcE8sNTpxT09RITBMbiw1OnEsNTpxTyMoWlFgTzFHMFpPT1EhMExmMUcwWjFHMFpPJVtRbE8xRzBaT09RITBMZjFHMHQxRzB0Tz9ZUWBPMUcwdE8hQ1VRcE8xRzB0TyFDXlFNaE8xRzB0T09RITBMYjFHNXwxRzV8TyFCeVEhMExyTzFHMF5PT1FPMUcwbTFHMG1PJVtRbE8xRzBtTyRAbVEhMExyTzFHMG1PJEB4USEwTHJPMUcwbU8hQ1VRcE8xRzBeT0RXUXBPMUcwXk8kQVdRITBMck8xRzBtT09RTzFHMF4xRzBeTyRBbFEhME14TzFHMG1QT09PLUU8Wy1FPFtQT09PMUcuaDFHLmhPT09PMUcvaTFHL2lPJEF2USFiTyw1PGlPJEJPUSFmTzFHNGpPT1FPMUc0cDFHNHBPJVtRbE8sNT9PTyRCWVFgTzFHNXpPJEJiUWBPMUc2WU8kQmpRIWZPMUc2Wk85ZVFgTyw1P1VPJEJ0USEwTXhPMUc2V08lW1FsTzFHNldPJENVUSEwTHJPMUc2V08kQ2dRYE8xRzZWTyRDZ1FgTzFHNlZPOWVRYE8xRzZWTyRDb1FgTyw1P1hPOWVRYE8sNT9YT09RTyw1P1gsNT9YTyREVFFgTyw1P1hPJCtZUWBPLDU/WE9PUU8tRTxrLUU8a09PUVMxRzBhMUcwYU9PUVMxRzBjMUcwY08jLmxRYE8xRzBjT09RWzcrKGU3KyhlTyEmelFNaE83KyhlTyVbUWxPNysoZU8kRGNRYE83KyhlTyREblFNaE83KyhlTyREfFEhME16Tyw1PVhPJEdYUSEwTXpPLDU9Wk8kSWRRITBNek8sNT1YTyRLdVEhME16Tyw1PVpPJE5XUSEwTXpPLDU5dU8lIV1RITBNek8sNTxrTyUkaFEhME16Tyw1PG1PJSZzUSEwTXpPLDU8e09PUSEwTGY3KyZhNysmYU8lKVVRITBNeE83KyZhTyUpeFFsTycjSWZPJSpWUWBPLDVAY08lKl9RIWZPLDVAY09PUSEwTGYxRzBQMUcwUE8lKmlRYE83KyZqT09RITBMZjcrJmo3KyZqTyUqblE/TXRPLDU6Zk8lW1FsTzcrJnpPJSp4UT9NdE8sNTpiTyUrVlE/TXRPLDU6ak8lK2FRP010Tyw1OmxPJStrUU1oTycjSWlPJSt1UWBPLDVAaE9PUSEwTGgxRzBkMUcwZE9PUU8xRzFyMUcxck9PUU8xRzFzMUcxc08lK31RIWpPLDU8Wk8hKVtRbE8sNTxZT09RTy1FPGwtRTxsT09RITBMZjcrJ1k3KydZT09PVzcrJ2U3KydlT09PVzFHMXwxRzF8TyUsWVFgTzFHMXxPT1EhMExmMUcyTzFHMk9PT09PLDU5byw1OW9PJSxfUSFkTyw1OW9PT09PLUU8YC1FPGBPT1EhMExoMUcvWDFHL1hPJSxmUSEwTXhPNysna09PUSEwTGgsNT9eLDU/Xk8lLVlRTWhPMUcyZlAlLWFRYE8nI0lyUE9RITBMaC1FPHAtRTxwTyUtfVFNak8sNT9hT09RITBMaC1FPHMtRTxzTyUucFFNak8sNT9jT09RITBMaC1FPHUtRTx1TyUuelEhZE8xRzJ3TyUvUlEhZE8nI0NyTyUvaVFNaE8nI0tTTyQkd1FsTycjSnZPT1EhMExoMUcyXzFHMl9PJS9zUWBPJyNJcU8lMFtRYE8sNUB2TyUwW1FgTyw1QHZPJTBkUWBPLDVAdk8lMG9RYE8sNUB2T09RTzFHMmExRzJhTyUwfVFNak8xRzJgTyQrWVFgTycjS1tPISxUUU1oTzFHMmBPJTFfUShDV08nI0lzTyUxbFFgTyw1QHdPISZ6UU1oTyw1QHdPJTF0USFkTyw1QHdPT1EhMExoMUcyZDFHMmRPJTRVUSFmTycjQ2lPJTRgUWBPLDU9UE9PUSEwTGIsNTx9LDU8fU8lNGhRcE8sNTx9T09RITBMYiw1PU8sNT1PT0N3UWBPLDU8fU8lNHNRcE8sNTx9T09RITBMYiw1PVIsNT1STyQrWVFgTyw1PVZPT1FPLDU/YCw1P2BPT1FPLUU8ci1FPHJPT1EhMExwMUcyaDFHMmhPIyRgUXBPLDU8fU8kJHdRbE8sNT1QTyU1UlFgTyw1PU9PJTVeUXBPLDU9T08hLFRRTWhPJyNJdU8lNldRTWpPMUcyc08hLFRRTWhPJyNJd08lNnlRTWpPMUcydU8lN1RRTWpPMUc1cU8lN19RTWpPMUc1cU9PUU8sNT9lLDU/ZU9PUU8tRTx3LUU8d09PUU8xRy57MUcue08hLFRRTWhPMUc1cU8hLFRRTWhPMUc1cU8hOl1RcE8sNTl3TyVbUWxPLDU5d09PUSEwTGgsNTxqLDU8ak8lN2xRYE8xRzJaTyEsVFFNaE8xRzJiTyU3cVEhME14TzcrJ21PT1EhMExmNysnbTcrJ21PISR3UWxPNysnbU8lOGVRYE8sNTtgT09RITBMYiw1P2csNT9nT09RITBMYi1FPHktRTx5TyU4alEhZE8nI0teTyMoWlFgTzcrKGVPNFVRIWZPNysoZU8kRGZRYE83KyhlTyU4dFEhME12TycjQ2lPJTlYUSEwTXZPLDU9U08lOWxRYE8sNT1TTyU5dFFgTyw1PVNPT1EhMExiMUc1bzFHNW9PT1FbNyskYTcrJGFPIUJ5USEwTHJPNyskYU8hQ1VRcE83KyRhTyEkd1FsTzcrJmFPJTl5UWBPJyNKUU8lOmJRYE8sNUFQT09RTzFHM2gxRzNoTzlrUWBPLDVBUE8lOmJRYE8sNUFQTyU6alFgTyw1QVBPT1FPLDU/bSw1P21PT1FPLUU9UC1FPVBPT1EhMExmNysnVDcrJ1RPJTpvUWBPNyspUU85dVEhMExyTzcrKVFPOWtRYE83KylRT0B6UWBPNyspUU8lOnRRYE83KylRT09RWzcrKVE3KylRT09RWzcrKHA3KyhwTyU6eVEhME12TzcrKG1PISZ6UU1oTzcrKG1PIUVeUWBPNysobk9PUVs3KyhuNysobk8hJnpRTWhPNysobk8lO1RRYE8nI0tiTyU7YFFgTyw1PWxPT1FPLDU/aSw1P2lPT1FPLUU8ey1FPHtPT1FbNysoczcrKHNPJTxyUXBPJyNIWk9PUVsxRzNgMUczYE8hJnpRTWhPMUczYE8lW1FsTzFHM2BPJTx5UWBPMUczYE8lPVVRTWhPMUczYE85dVEhMExyTzFHM2JPJCVkUWBPMUczYk85YFFgTzFHM2JPIUNVUXBPMUczYk8hQ15RTWhPMUczYk8lPWRRYE8nI0pQTyU9eFFgTyw1QH1PJT5RUXBPLDVAfU9PUSEwTGIxRzNjMUczY09PUVs3KyRWNyskVk9AelFgTzcrJFZPOXVRITBMck83KyRWTyU+XVFgTzcrJFZPJVtRbE8xRzZsTyVbUWxPMUc2bU8lPmJRITBMck8xRzZsTyU+bFFsTzFHM2tPJT5zUWBPMUcza08lPnhRbE8xRzNrT09RWzcrKVQ3KylUTzl1USEwTHJPNyspX09gUWxPNyspYU9PUVsnI0toJyNLaE9PUVsnI0pTJyNKU08lP1BRbE8sNT5gT09RWyw1PmAsNT5gTyVbUWxPJyNIdU8lP15RYE8nI0h3T09RWyw1PmYsNT5mTzllUWBPLDU+Zk9PUVssNT5oLDU+aE9PUVs3KylqNyspak9PUVs3KylwNyspcE9PUVs3Kyl0NyspdE9PUVs3Kyl2Nyspdk8lP2NRcE8xRzV8TyU/fVE/TXRPMUcwek8lQFhRYE8xRzB6T09RTzFHL3MxRy9zTyVAZFE/TXRPMUcvc08/WVFgTzFHL3NPISlbUWxPJyNEbU9PUU8sNT9QLDU/UE9PUU8tRTxjLUU8Y09PUU8sNT9WLDU/Vk9PUU8tRTxpLUU8aU8hQ1VRcE8xRy9zT09RTy1FPGUtRTxlT09RITBMbjFHMF0xRzBdT09RITBMZjcrJXU3KyV1TyMoWlFgTzcrJXVPT1EhMExmNysmYDcrJmBPP1lRYE83KyZgTyFDVVFwTzcrJmBPT1FPNysleDcrJXhPJEFsUSEwTXhPNysmWE9PUU83KyZYNysmWE8lW1FsTzcrJlhPJUBuUSEwTHJPNysmWE8hQnlRITBMck83KyV4TyFDVVFwTzcrJXhPJUB5USEwTHJPNysmWE8lQVhRITBNeE83KytyTyVbUWxPNysrck8lQWlRYE83KytxTyVBaVFgTzcrK3FPT1FPMUc0czFHNHNPOWVRYE8xRzRzTyVBcVFgTzFHNHNPT1FTNyslfTcrJX1PIyhaUWBPPDxMUE80VVEhZk88PExQTyVCUFFgTzw8TFBPT1FbPDxMUDw8TFBPISZ6UU1oTzw8TFBPJVtRbE88PExQTyVCWFFgTzw8TFBPJUJkUSEwTXpPLDU/YU8lRG9RITBNek8sNT9jTyVGelEhME16TzFHMmBPJUldUSEwTXpPMUcyc08lS2hRITBNek8xRzJ1TyVNc1EhZk8sNT9RTyVbUWxPLDU/UU9PUU8tRTxkLUU8ZE8lTX1RYE8xRzV9T09RITBMZjw8SlU8PEpVTyVOVlE/TXRPMUcwdU8mIV5RP010TzFHMVBPJiFlUT9NdE8xRzFQTyYkZlE/TXRPMUcxUE8mJG1RP010TzFHMVBPJiZuUT9NdE8xRzFQTyYob1E/TXRPMUcxUE8mKHZRP010TzFHMVBPJih9UT9NdE8xRzFQTyYrT1E/TXRPMUcxUE8mK1ZRP010TzFHMVBPJiteUSEwTXhPPDxKZk8mLVVRP010TzFHMVBPJi5SUT9Ndk8xRzFQTyYvVVE/TXZPJyNKbE8mMVtRP010TzFHMWNPJjFpUT9NdE8xRzBVTyYxc1FNak8sNT9UT09RTy1FPGctRTxnTyEpW1FsTycjRnFPT1FPJyNLWicjS1pPT1FPMUcxdTFHMXVPJjF9UWBPMUcxdE8mMlNRP010Tyw1P1tPT09XNysnaDcrJ2hPT09PMUcvWjFHL1pPJjJeUSFkTzFHNHhPT1EhMExoNysoUTcrKFFQISZ6UU1oTyw1P15PISxUUU1oTzcrKGNPJjJlUWBPLDU/XU85ZVFgTyw1P11PJCtZUWBPLDU/XU9PUU8tRTxvLUU8b08mMnNRYE8xRzZiTyYyc1FgTzFHNmJPJjJ7UWBPMUc2Yk8mM1dRTWpPNysnek8mM2hRIWRPLDU/X08mM3JRYE8sNT9fTyEmelFNaE8sNT9fT09RTy1FPHEtRTxxTyYzd1EhZE8xRzZjTyY0UlFgTzFHNmNPJjRaUWBPMUcya08hJnpRTWhPMUcya09PUSEwTGIxRzJpMUcyaU9PUSEwTGIxRzJqMUcyak8lNGhRcE8xRzJpTyFDVVFwTzFHMmlPQ3dRYE8xRzJpT09RITBMYjFHMnExRzJxTyY0YFFwTzFHMmlPJjRuUWBPMUcya08kK1lRYE8xRzJqT0N3UWBPMUcyak8kJHdRbE8xRzJrTyY0dlFgTzFHMmpPJjVqUU1qTyw1P2FPT1EhMExoLUU8dC1FPHRPJjZdUU1qTyw1P2NPT1EhMExoLUU8di1FPHZPISxUUU1oTzcrK11PJjZnUU1qTzcrK11PJjZxUU1qTzcrK11PT1EhMExoMUcvYzFHL2NPJjdPUWBPMUcvY09PUSEwTGg3Kyd1NysndU8mN1RRTWpPNysnfE8mN2VRITBNeE88PEtYT09RITBMZjw8S1g8PEtYTyY4WFFgTzFHMHpPISZ6UU1oTycjSXpPJjheUWBPLDVAeE8mOmBRIWZPPDxMUE8hJnpRTWhPMUcybk8mOmdRITBMck8xRzJuT09RWzw8R3s8PEd7TyFCeVEhMExyTzw8R3tPJjp4USEwTXhPPDxJe09PUSEwTGY8PEl7PDxJe09PUU8sNT9sLDU/bE8mO2xRYE8sNT9sTyY7cVFgTyw1P2xPT1FPLUU9Ty1FPU9PJjxQUWBPMUc2a08mPFBRYE8xRzZrTzlrUWBPMUc2a09AelFgTzw8TGxPT1FbPDxMbDw8TGxPJjxYUWBPPDxMbE85dVEhMExyTzw8TGxPOWtRYE88PExsT09RWzw8TFg8PExYTyU6eVEhME12Tzw8TFhPT1FbPDxMWTw8TFlPIUVeUWBPPDxMWU8mPF5RcE8nI0l8TyY8aVFgTyw1QHxPISlbUWxPLDVAfE9PUVsxRzNXMUczV09PUU8nI0pPJyNKT085dVEhMExyTycjSk9PJjxxUXBPLDU9dU9PUVssNT11LDU9dU8mPHhRcE8nI0VnTyY9UFFwTycjR2VPJj1VUWBPNysoek8mPVpRYE83Kyh6T09RWzcrKHo3Kyh6TyEmelFNaE83Kyh6TyVbUWxPNysoek8mPWNRYE83Kyh6T09RWzcrKHw3Kyh8Tzl1USEwTHJPNysofE8kJWRRYE83Kyh8TzlgUWBPNysofE8hQ1VRcE83Kyh8TyY9blFgTyw1P2tPT1FPLUU8fS1FPH1PT1FPJyNIXicjSF5PJj15UWBPMUc2aU85dVEhMExyTzw8R3FPT1FbPDxHcTw8R3FPQHpRYE88PEdxTyY+UlFgTzcrLFdPJj5XUWBPNyssWE8lW1FsTzcrLFdPJVtRbE83KyxYT09RWzcrKVY3KylWTyY+XVFgTzcrKVZPJj5iUWxPNyspVk8mPmlRYE83KylWT09RWzw8THk8PEx5T09RWzw8THs8PEx7T09RWy1FPVEtRT1RT09RWzFHM3oxRzN6TyY+blFgTyw1PmFPT1FbLDU+Yyw1PmNPJj5zUWBPMUc0UU85ZVFgTzcrJmZPISlbUWxPNysmZk9PUU83KyVfNyslX08mPnhRP010TzFHNlpPP1lRYE83KyVfT09RITBMZjw8SWE8PElhT09RITBMZjw8SXo8PEl6Tz9ZUWBPPDxJek9PUU88PElzPDxJc08kQWxRITBNeE88PElzTyVbUWxPPDxJc09PUU88PElkPDxJZE8hQnlRITBMck88PElkTyY/U1EhMExyTzw8SXNPJj9fUSEwTXhPPD0gXk8mP29RYE88PSBdT09RTzcrKl83KypfTzllUWBPNysqX09PUVtBTkFrQU5Ba08mP3dRIWZPQU5Ba08hJnpRTWhPQU5Ba08jKFpRYE9BTkFrTzRVUSFmT0FOQWtPJkBPUWBPQU5Ba08lW1FsT0FOQWtPJkBXUSEwTXpPNysnek8mQmlRITBNek8sNT9hTyZEdFEhME16Tyw1P2NPJkdQUSEwTXpPNysnfE8mSWJRIWZPMUc0bE8mSWxRP010TzcrJmFPJktwUT9Ndk8sNT1YTyZNd1E/TXZPLDU9Wk8mTlhRP012Tyw1PVhPJk5pUT9Ndk8sNT1aTyZOeVE/TXZPLDU5dU8nI1BRP012Tyw1PGtPJyVTUT9Ndk8sNTxtTycnaFE/TXZPLDU8e08nKV5RP010TzcrJ2tPJylrUT9NdE83KydtTycpeFFgTyw1PF1PT1FPNysnYDcrJ2BPT1EhMExoNysqZDcrKmRPJyl9UU1qTzw8S31PT1FPMUc0dzFHNHdPJypVUWBPMUc0d08nKmFRYE8xRzR3Tycqb1FgTzcrK3xPJypvUWBPNysrfE8hJnpRTWhPMUc0eU8nKndRIWRPMUc0eU8nK1JRYE83Kyt9TycrWlFgTzcrKFZPJytmUSFkTzcrKFZPT1EhMExiNysoVDcrKFRPT1EhMExiNysoVTcrKFVPIUNVUXBPNysoVE9Dd1FgTzcrKFRPJytwUWBPNysoVk8hJnpRTWhPNysoVk8kK1lRYE83KyhVTycrdVFgTzcrKFZPQ3dRYE83KyhVTycrfVFNak88PE53TyEsVFFNaE88PE53T09RITBMaDcrJH03KyR9TycsWFEhZE8sNT9mT09RTy1FPHgtRTx4TycsY1EhME12TzcrKFlPISZ6UU1oTzcrKFlPT1FbQU49Z0FOPWdPOWtRYE8xRzVXT09RTzFHNVcxRzVXTycsc1FgTzFHNVdPJyx4UWBPNyssVk8nLHhRYE83KyxWTzl1USEwTHJPQU5CV09AelFgT0FOQldPT1FbQU5CV0FOQldPJy1RUWBPQU5CV09PUVtBTkFzQU5Bc09PUVtBTkF0QU5BdE8nLVZRYE8sNT9oT09RTy1FPHotRTx6TyctYlE/TXRPMUc2aE9PUU8sNT9qLDU/ak9PUU8tRTx8LUU8fE9PUVsxRzNhMUczYU8nLWxRYE8sNT1QT09RWzw8TGY8PExmTyEmelFNaE88PExmTyY9VVFgTzw8TGZPJy1xUWBPPDxMZk8lW1FsTzw8TGZPT1FbPDxMaDw8TGhPOXVRITBMck88PExoTyQlZFFgTzw8TGhPOWBRYE88PExoTycteVFwTzFHNVZPJy5VUWBPNyssVE9PUVtBTj1dQU49XU85dVEhMExyT0FOPV1PT1FbPD0gcjw9IHJPT1FbPD0gczw9IHNPJy5eUWBPPD0gck8nLmNRYE88PSBzT09RWzw8THE8PExxTycuaFFgTzw8THFPJy5tUWxPPDxMcU9PUVsxRzN7MUcze08/WVFgTzcrKWxPJy50UWBPPDxKUU8nL1BRP010Tzw8SlFPT1FPPDxIeTw8SHlPT1EhMExmQU4/ZkFOP2ZPT1FPQU4/X0FOP19PJEFsUSEwTXhPQU4/X09PUU9BTj9PQU4/T08lW1FsT0FOP19PT1FPPDxNeTw8TXlPT1FbRzI3VkcyN1ZPISZ6UU1oT0cyN1ZPIyhaUWBPRzI3Vk8nL1pRIWZPRzI3Vk80VVEhZk9HMjdWTycvYlFgT0cyN1ZPJy9qUT9NdE88PEpmTycvd1E/TXZPMUcyYE8nMW1RP012Tyw1P2FPJzNwUT9Ndk8sNT9jTyc1c1E/TXZPMUcyc08nN3ZRP012TzFHMnVPJzl5UT9NdE88PEtYTyc6V1E/TXRPPDxJe09PUU8xRzF3MUcxd08hLFRRTWhPQU5BaU9PUU83KypjNysqY08nOmVRYE83KypjTyc6cFFgTzw9IGhPJzp4USFkTzcrKmVPT1EhMExiPDxLcTw8S3FPJCtZUWBPPDxLcU9Dd1FgTzw8S3FPJztTUWBPPDxLcU8hJnpRTWhPPDxLcU9PUSEwTGI8PEtvPDxLb08hQ1VRcE88PEtvTyc7X1EhZE88PEtxT09RITBMYjw8S3A8PEtwTyc7aVFgTzw8S3FPISZ6UU1oTzw8S3FPJCtZUWBPPDxLcE8nO25RTWpPQU5EY08nO3hRITBNdk88PEt0T09RTzcrKnI3KypyTzlrUWBPNysqck8nPFlRYE88PSBxT09RW0cyN3JHMjdyTzl1USEwTHJPRzI3ck9AelFgT0cyN3JPISlbUWxPMUc1U08nPGJRYE83KyxTTyc8alFgTzFHMmtPJj1VUWBPQU5CUU9PUVtBTkJRQU5CUU8hJnpRTWhPQU5CUU8nPG9RYE9BTkJRT09RW0FOQlNBTkJTTzl1USEwTHJPQU5CU08kJWRRYE9BTkJTT09RTycjSF8nI0hfT09RTzcrKnE3KypxT09RW0cyMndHMjJ3T09RW0FORV5BTkVeT09RW0FORV9BTkVfT09RW0FOQl1BTkJdTyc8d1FgT0FOQl1PT1FbPDxNVzw8TVdPISlbUWxPQU4/bE9PUU9HMjR5RzI0eU8kQWxRITBNeE9HMjR5TyMoWlFgT0xELHFPT1FbTEQscUxELHFPISZ6UU1oT0xELHFPJzx8USFmT0xELHFPJz1UUT9Ndk83Kyd6Tyc+eVE/TXZPLDU/YU8nQHxRP012Tyw1P2NPJ0NQUT9Ndk83Kyd8TydEdVFNak9HMjdUT09RTzw8TX08PE19T09RITBMYkFOQV1BTkFdTyQrWVFgT0FOQV1PQ3dRYE9BTkFdTydFVlEhZE9BTkFdT09RITBMYkFOQVpBTkFaTydFXlFgT0FOQV1PISZ6UU1oT0FOQV1PJ0VpUSFkT0FOQV1PT1EhMExiQU5BW0FOQVtPT1FPPDxOXjw8Tl5PT1FbTEQtXkxELV5POXVRITBMck9MRC1eTydFc1E/TXRPNysqbk9PUU8nI0dmJyNHZk9PUVtHMjdsRzI3bE8mPVVRYE9HMjdsTyEmelFNaE9HMjdsT09RW0cyN25HMjduTzl1USEwTHJPRzI3bk9PUVtHMjd3RzI3d08nRX1RP010T0cyNVdPT1FPTEQqZUxEKmVPT1FbISQoIV0hJCghXU8jKFpRYE8hJCghXU8hJnpRTWhPISQoIV1PJ0ZYUSEwTXpPRzI3VE9PUSEwTGJHMjZ3RzI2d08kK1lRYE9HMjZ3TydIalFgT0cyNndPQ3dRYE9HMjZ3TydIdVEhZE9HMjZ3TyEmelFNaE9HMjZ3T09RWyEkKCF4ISQoIXhPT1FbTEQtV0xELVdPJj1VUWBPTEQtV09PUVtMRC1ZTEQtWU9PUVshKTlFdyEpOUV3TyMoWlFgTyEpOUV3T09RITBMYkxELGNMRCxjTyQrWVFgT0xELGNPQ3dRYE9MRCxjTydIfFFgT0xELGNPJ0lYUSFkT0xELGNPT1FbISQoIXIhJCghck9PUVshLks7YyEuSztjTydJYFE/TXZPRzI3VE9PUSEwTGIhJCggfSEkKCB9TyQrWVFgTyEkKCB9T0N3UWBPISQoIH1PJ0tVUWBPISQoIH1PT1EhMExiISk5RWkhKTlFaU8kK1lRYE8hKTlFaU9Dd1FgTyEpOUVpT09RITBMYiEuSztUIS5LO1RPJCtZUWBPIS5LO1RPT1EhMExiITQvMG8hNC8wb08hKVtRbE8nI0R6TzFQUWBPJyNFWE8nS2FRIWZPJyNKck8nS2hRIUxeTycjRHZPJ0tvUWxPJyNFT08nS3ZRIWZPJyNDaU8nTl5RIWZPJyNDaU8hKVtRbE8nI0VRTydOblFsTyw1O1pPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8nI0lwTyghcVFgTyw1PGlPISlbUWxPLDU7ZU8oIXlRTWhPLDU7ZU8oJGRRTWhPLDU7ZU8hKVtRbE8sNTt3TyEmelFNaE8nI0dtTygheVFNaE8nI0dtTyEmelFNaE8nI0dvTygheVFNaE8nI0dvTzFTUWBPJyNEWk8xU1FgTycjRFpPISZ6UU1oTycjR1BPKCF5UU1oTycjR1BPISZ6UU1oTycjR1JPKCF5UU1oTycjR1JPISZ6UU1oTycjR2FPKCF5UU1oTycjR2FPISlbUWxPLDU6ak8oJGtRcE8nI0RfTygkdVFwTycjSnZPISlbUWxPLDVAb08nTm5RbE8xRzB1TyglUFE/TXRPJyNDaU8hKVtRbE8xRzJQTyEmelFNaE8nI0l1TygheVFNaE8nI0l1TyEmelFNaE8nI0l3TygheVFNaE8nI0l3TyglWlEhZE8nI0NyTyEmelFNaE8sNTx0TygheVFNaE8sNTx0TydOblFsTzFHMlJPISlbUWxPNysmek8hJnpRTWhPMUcyYE8oIXlRTWhPMUcyYE8hJnpRTWhPJyNJdU8oIXlRTWhPJyNJdU8hJnpRTWhPJyNJd08oIXlRTWhPJyNJd08hJnpRTWhPMUcyYk8oIXlRTWhPMUcyYk8nTm5RbE83KydtTydOblFsTzcrJmFPISZ6UU1oT0FOQWlPKCF5UU1oT0FOQWlPKCVuUWBPJyNFb08oJXNRYE8nI0VvTygle1FgTycjRl1PKCZRUWBPJyNFeU8oJlZRYE8nI0tUTygmYlFgTycjS1JPKCZtUWBPLDU7Wk8oJnJRTWpPLDU8ZU8oJnlRYE8nI0dZTygnT1FgTycjR1lPKCdUUWBPLDU8ZU8oJ11RYE8sNTxnTygnZVFgTyw1O1pPKCdtUT9NdE8xRzFgTygndFFgTyw1PHRPKCd5UWBPLDU8dE8oKE9RYE8sNTx2TygoVFFgTyw1PHZPKChZUWBPMUcyUk8oKF9RYE8xRzB1TygoZFFNak88PEt9Tygoa1FNak88PEt9TygoclFNaE8nI0Z8TzlgUWBPJyNGe09BdVFgTycjRW5PISlbUWxPLDU7dE8hM29RYE8nI0dZTyEzb1FgTycjR1lPITNvUWBPJyNHW08hM29RYE8nI0dbTyEsVFFNaE83KyhjTyEsVFFNaE83KyhjTyUuelEhZE8xRzJ3TyUuelEhZE8xRzJ3TyEmelFNaE8sNT1dTyEmelFNaE8sNT1dXCIsXG4gIHN0YXRlRGF0YTogXCIoKXh+Tyd8T1MnfU9TVE9TKE9SUX5PUFlPUVlPU2ZPWSFWT2FxT2R6T2V5T2whUE9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV9YTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1d08heHhPIXxdTyRXfE8kbmlPJWh9TyVqIVFPJWwhT08lbSFPTyVuIU9PJXEhUk8lcyFTTyV2IVRPJXchVE8leSFVTyZXIVdPJl4hWE8mYCFZTyZiIVpPJmQhW08mZyFdTyZtIV5PJnMhX08mdSFgTyZ3IWFPJnkhYk8meyFjTyhUU08oVlRPKFlVTyhhVk8ob1tPfk9XdE9+UGBPUFlPUVlPU2ZPZCFqT2UhaU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV8hZU8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8hdSFnTyF4IWhPJFcha08kbmlPKFQhZE8oVlRPKFlVTyhhVk8ob1tPfk9hIXdPcyFuTyFTIW9PIWIheU8hYyF2TyFkIXZPIXw8Vk8jVCFwTyNVIXBPI1YheE8jVyFwTyNYIXBPI1shek8jXSF6TyhVIWxPKFZUTyhZVU8oZSFtTyhvIXNPfk8oTyF7T35PUF1YUl1YW11YYV1Yal1Ycl1YIVFdWCFTXVghXV1YIWxdWCFwXVgjUl1YI1NdWCNgXVgja2ZYI25dWCNvXVgjcF1YI3FdWCNyXVgjc11YI3RdWCN1XVgjdl1YI3hdWCN6XVgje11YJFFdWCd6XVgoYV1YKHJdWCh5XVgoel1Yfk8hZyVSWH5QKHFPXyF9TyhWI1BPKFchfU8oWCNQT35PXyNRTyhYI1BPKFkjUE8oWiNRT35PeCNTTyFVI1RPKGIjVE8oYyNWT35PUFlPUVlPU2ZPZCFqT2UhaU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV8hZU8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8hdSFnTyF4IWhPJFcha08kbmlPKFQ8Wk8oVlRPKFlVTyhhVk8ob1tPfk8hWyNaTyFdI1dPIVkoaFAhWSh2UH5QK31PIV4jY09+UGBPUFlPUVlPU2ZPZCFqT2UhaU9yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV8hZU8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8hdSFnTyF4IWhPJFcha08kbmlPKFZUTyhZVU8oYVZPKG9bT35PcCNtTyFbI2lPIXxdTyNpI2xPI2ojaU8oVDxbTyFrKHNQflAuaU8hbCNvTyhUI25Pfk8heCNzTyF8XU8laCN0T35PI2sjdU9+TyFnI3ZPI2sjdU9+T1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFdJF9PIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPI3gkVU8jeiRXTyN7JFhPKGFWTyhyJFlPKHkjfE8oeiN9T35PYShmWCd6KGZYJ3coZlghayhmWCFZKGZYIV8oZlglaShmWCFnKGZYflAxcU8jUyRkTyNgJGVPJFEkZU9QKGdYUihnWFsoZ1hqKGdYcihnWCFRKGdYIVMoZ1ghXShnWCFsKGdYIXAoZ1gjUihnWCNuKGdYI28oZ1gjcChnWCNxKGdYI3IoZ1gjcyhnWCN0KGdYI3UoZ1gjdihnWCN4KGdYI3ooZ1gjeyhnWChhKGdYKHIoZ1goeShnWCh6KGdYIV8oZ1glaShnWH5PYShnWCd6KGdYJ3coZ1ghWShnWCFrKGdYdihnWCFnKGdYflA0VU8jYCRlT35PJF0kaE8kXyRnTyRmJG1Pfk9TZk8hXyRuTyRpJG9PJGskcU9+T2glVk9qJWRPayVkT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPJV1PIVMke08hXyR8TyFpJWJPIWwkeE8jaiVjTyRXJWBPJHQlXk8kdiVfTyR5JWFPKFQkc08oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT2coXlB+T2wlW09+UDdlTyFsJWVPfk8hUyVoTyFfJWlPKFQlZ09+TyFnJW1Pfk9hJW5PJ3olbk9+TyFRJXJPflAlW08oVSFsT35QJVtPJW4ldk9+UCVbT2glVk8hbCVlTyhUJWdPKFUhbE9+T2UlfU8hbCVlTyhUJWdPfk9qJFJPfk8hXyZQTyhUJWdPKFUhbE8oVlRPKFlVT2ApV1B+TyFRJlNPIWwmUk8laiZWTyZUJldPflA7U08heCNzT35PJXMmWU8hUylTWCFfKVNYKFQpU1h+TyhUJlpPfk9sIVBPIXUmYE8laiFRTyVsIU9PJW0hT08lbiFPTyVxIVJPJXMhU08ldiFUTyV3IVRPfk9kJmVPZSZkTyF4JmJPJWgmY08leyZhT35QPGJPZCZoT2V5T2whUE8hXyZnTyF1JmBPIXh4TyF8XU8laH1PJWwhT08lbSFPTyVuIU9PJXEhUk8lcyFTTyV2IVRPJXchVE8leSFVT35PYiZrTyNgJm5PJWomaU8oVSFsT35QPWdPIWwmb08hdSZzT35PIWwjb09+TyFfWE9+T2Elbk8neCZ7Tyd6JW5Pfk9hJW5PJ3gnT08neiVuT35PYSVuTyd4J1FPJ3olbk9+Tyd3XVghWV1Ydl1YIWtdWCZbXVghX11YJWldWCFnXVh+UChxTyFiJ19PIWMnV08hZCdXTyhVIWxPKFZUTyhZVU9+T3MnVU8hUydUTyFbJ1hPKGUnU08hXihpUCFeKHhQflBAbk9uJ2JPIV8nYE8oVCVnT35PZSdnTyFsJWVPKFQlZ09+TyFRJlNPIWwmUk9+T3Mhbk8hUyFvTyF8PFZPI1QhcE8jVSFwTyNXIXBPI1ghcE8oVSFsTyhWVE8oWVVPKGUhbU8obyFzT35PIWInbU8hYydsTyFkJ2xPI1YhcE8jWyduTyNdJ25PflBCWU9hJW5PaCVWTyFnI3ZPIWwlZU8neiVuTyhyJ3BPfk8hcCd0TyNgJ3JPflBDaE9zIW5PIVMhb08oVlRPKFlVTyhlIW1PKG8hc09+TyFfWE9zKG1YIVMobVghYihtWCFjKG1YIWQobVghfChtWCNUKG1YI1UobVgjVihtWCNXKG1YI1gobVgjWyhtWCNdKG1YKFUobVgoVihtWChZKG1YKGUobVgobyhtWH5PIWMnbE8hZCdsTyhVIWxPflBEV08oUCd4TyhRJ3hPKFInek9+T18hfU8oVid8TyhXIX1PKFgnfE9+T18jUU8oWCd8TyhZJ3xPKFojUU9+T3YoT09+UCVbT3gjU08hVSNUTyhiI1RPKGMoUk9+TyFbKFRPIVknV1ghWSdeWCFdJ1dYIV0nXlh+UCt9TyFdKFZPIVkoaFh+T1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFdKFZPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPI3gkVU8jeiRXTyN7JFhPKGFWTyhyJFlPKHkjfE8oeiN9T35PIVkoaFh+UEhSTyFZKFtPfk8hWSh1WCFdKHVYIWcodVghayh1WChyKHVYfk8jYCh1WCNrI2RYIV4odVh+UEpVTyNgKF1PIVkod1ghXSh3WH5PIV0oXk8hWSh2WH5PIVkoYU9+TyNgJGVPflBKVU8hXihiT35QYE9SI3pPIVEjeU8hUyN7TyFsI3hPKGFWT1AhbmFbIW5haiFuYXIhbmEhXSFuYSFwIW5hI1IhbmEjbiFuYSNvIW5hI3AhbmEjcSFuYSNyIW5hI3MhbmEjdCFuYSN1IW5hI3YhbmEjeCFuYSN6IW5hI3shbmEociFuYSh5IW5hKHohbmF+T2EhbmEneiFuYSd3IW5hIVkhbmEhayFuYXYhbmEhXyFuYSVpIW5hIWchbmF+UEtsTyFrKGNPfk8hZyN2TyNgKGRPKHIncE8hXSh0WGEodFgneih0WH5PIWsodFh+UE5YTyFTJWhPIV8laU8hfF1PI2koaU8jaihoTyhUJWdPfk8hXShqTyFrKHNYfk8hayhsT35PIVMlaE8hXyVpTyNqKGhPKFQlZ09+T1AoZ1hSKGdYWyhnWGooZ1hyKGdYIVEoZ1ghUyhnWCFdKGdYIWwoZ1ghcChnWCNSKGdYI24oZ1gjbyhnWCNwKGdYI3EoZ1gjcihnWCNzKGdYI3QoZ1gjdShnWCN2KGdYI3goZ1gjeihnWCN7KGdYKGEoZ1gocihnWCh5KGdYKHooZ1h+TyFnI3ZPIWsoZ1h+UCEgdU9SKG5PIVEobU8hbCN4TyNTJGRPIXwhe2EhUyF7YX5PIXghe2ElaCF7YSFfIXthI2khe2EjaiF7YShUIXthflAhI3ZPIXgock9+T1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfWE8haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8hdSFnTyF4IWhPJFcha08kbmlPKFQhZE8oVlRPKFlVTyhhVk8ob1tPfk9oJVZPcCVXT3IlWE9zJHRPdCR0T3olWU98JVpPIU88c08hUyR7TyFfJHxPIWk+Vk8hbCR4TyNqPHlPJFclYE8kdDx1TyR2PHdPJHklYU8oVCh2TyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk8jayh4T35PIVsoek8hayhrUH5QJVtPKGUofE8ob1tPfk8hUylPTyFsI3hPKGUofE8ob1tPfk9QPFVPUTxVT1NmT2Q+Uk9lIWlPcGtPcjxVT3NrT3RrT3prT3w8VU8hTzxVTyFTV08hV2tPIVhrTyFfIWVPIWk8WE8hbFpPIW88VU8hcDxVTyFxPFVPIXM8WU8hdTxdTyF4IWhPJFcha08kbj5QTyhUKV1PKFZUTyhZVU8oYVZPKG9bT35PIV0kX09hJHFhJ3okcWEndyRxYSFrJHFhIVkkcWEhXyRxYSVpJHFhIWckcWF+T2wpZE9+UCEmek9oJVZPcCVXT3IlWE9zJHRPdCR0T3olWU98JVpPIU8lXU8hUyR7TyFfJHxPIWklYk8hbCR4TyNqJWNPJFclYE8kdCVeTyR2JV9PJHklYU8oVCh2TyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk9nKHBQflAhLFRPIVEpaU8hZyloTyFfJF5YJFokXlgkXSReWCRfJF5YJGYkXlh+TyFnKWhPIV8oe1gkWih7WCRdKHtYJF8oe1gkZih7WH5PIVEpaU9+UCEuXk8hUSlpTyFfKHtYJFooe1gkXSh7WCRfKHtYJGYoe1h+TyFfKWtPJFopb08kXSlqTyRfKWpPJGYpcE9+TyFbKXNPflAhKVtPJF0kaE8kXyRnTyRmKXdPfk9uJHpYIVEkelgjUyR6WCd5JHpYKHkkelgoeiR6WH5PZ21YZyR6WG5tWCFdbVgjYG1YflAhMFNPeCl5TyhiKXpPKGMpfE9+T24qVk8hUSpPTyd5KlBPKHkkfU8oeiVQT35PZyl9T35QITFXT2cqV09+T2glVk9yJVhPcyR0T3QkdE96JVlPfCVaTyFPPHNPIVMqWU8hXypaTyFpPlZPIWwkeE8jajx5TyRXJWBPJHQ8dU8kdjx3TyR5JWFPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+T3AqYE8hWypeTyhUKlhPIWspT1B+UCExdU8jayphT35PIWwqYk9+T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxzTyFTJHtPIV8kfE8haT5WTyFsJHhPI2o8eU8kVyVgTyR0PHVPJHY8d08keSVhTyhUKmRPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+TyFbKmdPIVkpUFB+UCEzdE9yKnNPcyFuTyFTKmlPIWIqcU8hYyprTyFkKmtPIWwqYk8jWypyTyVgKm1PKFUhbE8oVlRPKFlVTyhlIW1Pfk8hXipwT35QITVpTyNTJGRPbihgWCFRKGBYJ3koYFgoeShgWCh6KGBYIV0oYFgjYChgWH5PZyhgWCRPKGBYflAhNmtPbip4TyNgKndPZyhfWCFdKF9Yfk8hXSp5T2coXlh+T2olZE9rJWRPbCVkTyhUJlpPZyheUH5Pcyp8T35PZyl9TyhUJlpPfk8hbCtTT35PKFQodk9+T3ArV08hUyVoTyFbI2lPIV8laU8hfF1PI2kjbE8jaiNpTyhUJWdPIWsoc1B+TyFnI3ZPI2srWE9+TyFTJWhPIVsrWk8hXSheTyFfJWlPKFQlZ08hWSh2UH5PcydbTyFTK11PIVsrW08oVlRPKFlVTyhlKHxPfk8hXih4UH5QITl8TyFdK15PYSlUWCd6KVRYfk9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyN6JFdPI3skWE8oYVZPKHIkWU8oeSN8Tyh6I31Pfk9hIWphIV0hamEneiFqYSd3IWphIVkhamEhayFqYXYhamEhXyFqYSVpIWphIWchamF+UCE6dE9SI3pPIVEjeU8hUyN7TyFsI3hPKGFWT1AhcmFbIXJhaiFyYXIhcmEhXSFyYSFwIXJhI1IhcmEjbiFyYSNvIXJhI3AhcmEjcSFyYSNyIXJhI3MhcmEjdCFyYSN1IXJhI3YhcmEjeCFyYSN6IXJhI3shcmEociFyYSh5IXJhKHohcmF+T2EhcmEneiFyYSd3IXJhIVkhcmEhayFyYXYhcmEhXyFyYSVpIXJhIWchcmF+UCE9W09SI3pPIVEjeU8hUyN7TyFsI3hPKGFWT1AhdGFbIXRhaiF0YXIhdGEhXSF0YSFwIXRhI1IhdGEjbiF0YSNvIXRhI3AhdGEjcSF0YSNyIXRhI3MhdGEjdCF0YSN1IXRhI3YhdGEjeCF0YSN6IXRhI3shdGEociF0YSh5IXRhKHohdGF+T2EhdGEneiF0YSd3IXRhIVkhdGEhayF0YXYhdGEhXyF0YSVpIXRhIWchdGF+UCE/ck9oJVZPbitnTyFfJ2BPJWkrZk9+TyFnK2lPYShdWCFfKF1YJ3ooXVghXShdWH5PYSVuTyFfWE8neiVuT35PaCVWTyFsJWVPfk9oJVZPIWwlZU8oVCVnT35PIWcjdk8jayh4T35PYit0TyVqK3VPKFQrcU8oVlRPKFlVTyFeKVhQfk8hXSt2T2ApV1h+T1srek9+T2Are09+TyFfJlBPKFQlZ08oVSFsT2ApV1B+TyVqLE9PflA7U09oJVZPI2AsU09+T2glVk9uLFZPIV8kfE9+TyFfLFhPfk8hUSxaTyFfWE9+TyVuJXZPfk8heCxgT35PZSxlT35PYixmTyhUI25PKFZUTyhZVU8hXilWUH5PZSV9T35PJWohUU8oVCZaT35QPWdPWyxrT2Asak9+T1BZT1FZT1NmT2R6T2V5T3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08haXVPIWxaTyFvWU8hcFlPIXFZTyFzdk8heHhPIXxdTyRuaU8laH1PKFZUTyhZVU8oYVZPKG9bT35PIV8hZU8hdSFnTyRXIWtPKFQhZE9+UCFGeU9gLGpPYSVuTyd6JW5Pfk9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF4IWhPJFcha08kbmlPKFQhZE8oVlRPKFlVTyhhVk8ob1tPfk9hLHBPbCFPTyF1d08lbCFPTyVtIU9PJW4hT09+UCFJY08hbCZvT35PJl4sdk9+TyFfLHhPfk8mbyx6TyZxLHtPUCZsYVEmbGFTJmxhWSZsYWEmbGFkJmxhZSZsYWwmbGFwJmxhciZsYXMmbGF0JmxheiZsYXwmbGEhTyZsYSFTJmxhIVcmbGEhWCZsYSFfJmxhIWkmbGEhbCZsYSFvJmxhIXAmbGEhcSZsYSFzJmxhIXUmbGEheCZsYSF8JmxhJFcmbGEkbiZsYSVoJmxhJWombGElbCZsYSVtJmxhJW4mbGElcSZsYSVzJmxhJXYmbGEldyZsYSV5JmxhJlcmbGEmXiZsYSZgJmxhJmImbGEmZCZsYSZnJmxhJm0mbGEmcyZsYSZ1JmxhJncmbGEmeSZsYSZ7JmxhJ3cmbGEoVCZsYShWJmxhKFkmbGEoYSZsYShvJmxhIV4mbGEmZSZsYWImbGEmaiZsYX5PKFQtUU9+T2ghZVghXSFSWCFeIVJYIWchUlghZyFlWCFsIWVYI2AhUlh+TyFdIWVYIV4hZVh+UCMhaU8hZy1WTyNgLVVPaChqWCFdI2hYIV4jaFghZyhqWCFsKGpYfk8hXShqWCFeKGpYflAjI1tPaCVWTyFnLVhPIWwlZU8hXSFhWCFeIWFYfk9zIW5PIVMhb08oVlRPKFlVTyhlIW1Pfk9QPFVPUTxVT1NmT2Q+Uk9lIWlPcGtPcjxVT3NrT3RrT3prT3w8VU8hTzxVTyFTV08hV2tPIVhrTyFfIWVPIWk8WE8hbFpPIW88VU8hcDxVTyFxPFVPIXM8WU8hdTxdTyF4IWhPJFcha08kbj5QTyhWVE8oWVVPKGFWTyhvW09+TyhUPVFPflAjJHFPIV0tXU8hXihpWH5PIV4tX09+TyFnLVZPI2AtVU8hXSNoWCFeI2hYfk8hXS1gTyFeKHhYfk8hXi1iT35PIWMtY08hZC1jTyhVIWxPflAjJGBPIV4tZk9+UCdfT24taU8hXydgT35PIVktbk9+T3Mhe2EhYiF7YSFjIXthIWQhe2EjVCF7YSNVIXthI1Yhe2EjVyF7YSNYIXthI1she2EjXSF7YShVIXthKFYhe2EoWSF7YShlIXthKG8he2F+UCEjdk8hcC1zTyNgLXFPflBDaE8hYy11TyFkLXVPKFUhbE9+UERXT2Elbk8jYC1xTyd6JW5Pfk9hJW5PIWcjdk8jYC1xTyd6JW5Pfk9hJW5PIWcjdk8hcC1zTyNgLXFPJ3olbk8ocidwT35PKFAneE8oUSd4TyhSLXpPfk92LXtPfk8hWSdXYSFdJ1dhflAhOnRPIVsuUE8hWSdXWCFdJ1dYflAlW08hXShWTyFZKGhhfk8hWShoYX5QSFJPIV0oXk8hWSh2YX5PIVMlaE8hWy5UTyFfJWlPKFQlZ08hWSdeWCFdJ15Yfk8jYC5WTyFdKHRhIWsodGFhKHRhJ3oodGF+TyFnI3ZPflAjLHdPIV0oak8hayhzYX5PIVMlaE8hXyVpTyNqLlpPKFQlZ09+T3AuYE8hUyVoTyFbLl1PIV8laU8hfF1PI2kuX08jai5dTyhUJWdPIV0nYVghaydhWH5PUi5kTyFsI3hPfk9oJVZPbi5nTyFfJ2BPJWkuZk9+T2EjY2khXSNjaSd6I2NpJ3cjY2khWSNjaSFrI2NpdiNjaSFfI2NpJWkjY2khZyNjaX5QITp0T24+XU8hUSpPTyd5KlBPKHkkfU8oeiVQT35PI2sjX2FhI19hI2AjX2EneiNfYSFdI19hIWsjX2EhXyNfYSFZI19hflAjL3NPI2soYFhQKGBYUihgWFsoYFhhKGBYaihgWHIoYFghUyhgWCFsKGBYIXAoYFgjUihgWCNuKGBYI28oYFgjcChgWCNxKGBYI3IoYFgjcyhgWCN0KGBYI3UoYFgjdihgWCN4KGBYI3ooYFgjeyhgWCd6KGBYKGEoYFgocihgWCFrKGBYIVkoYFgndyhgWHYoYFghXyhgWCVpKGBYIWcoYFh+UCE2a08hXS50TyFrKGtYflAhOnRPIWsud09+TyFZLnlPfk9QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPKGFWT1sjbWlhI21paiNtaXIjbWkhXSNtaSNSI21pI28jbWkjcCNtaSNxI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSd6I21pKHIjbWkoeSNtaSh6I21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI24jbWl+UCMzY08jbiRPT35QIzNjT1AkW09SI3pPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI24kT08jbyRQTyNwJFBPI3EkUE8oYVZPWyNtaWEjbWlqI21pIV0jbWkjUiNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJ3ojbWkociNtaSh5I21pKHojbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jciNtaX5QIzZRTyNyJFFPflAjNlFPUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyhhVk9hI21pIV0jbWkjeCNtaSN6I21pI3sjbWkneiNtaShyI21pKHkjbWkoeiNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyN2I21pflAjOG9PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPKGFWTyh6I31PYSNtaSFdI21pI3ojbWkjeyNtaSd6I21pKHIjbWkoeSNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyN4JFVPflAjO1ZPI3gjbWl+UCM7Vk8jdiRTT35QIzhvT1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyN4JFVPKGFWTyh5I3xPKHojfU9hI21pIV0jbWkjeyNtaSd6I21pKHIjbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jeiNtaX5QIz17TyN6JFdPflAjPXtPUF1YUl1YW11Yal1Ycl1YIVFdWCFTXVghbF1YIXBdWCNSXVgjU11YI2BdWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YKGFdWChyXVgoeV1YKHpdWCFdXVghXl1Yfk8kT11YflAjQGpPUCRbT1Ijek9bPG1PajxiT3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPGJPI248X08jbzxgTyNwPGBPI3E8YE8jcjxhTyNzPGJPI3Q8Yk8jdTxsTyN2PGNPI3g8ZU8jejxnTyN7PGhPKGFWTyhyJFlPKHkjfE8oeiN9T35PJE8ue09+UCNCd08jUyRkTyNgPG5PJFE8bk8kTyhnWCFeKGdYflAhIHVPYSdkYSFdJ2RhJ3onZGEndydkYSFrJ2RhIVknZGF2J2RhIV8nZGElaSdkYSFnJ2RhflAhOnRPWyNtaWEjbWlqI21pciNtaSFdI21pI1IjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJ3ojbWkociNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08jbiRPTyNvJFBPI3AkUE8jcSRQTyhhVk8oeSNtaSh6I21pflAjRXlPbj5dTyFRKk9PJ3kqUE8oeSR9Tyh6JVBPUCNtaVIjbWkhUyNtaSFsI21pIXAjbWkjbiNtaSNvI21pI3AjbWkjcSNtaShhI21pflAjRXlPIV0vUE9nKHBYflAhMVdPZy9ST35PYSRQaSFdJFBpJ3okUGkndyRQaSFZJFBpIWskUGl2JFBpIV8kUGklaSRQaSFnJFBpflAhOnRPJF0vU08kXy9TT35PJF0vVE8kXy9UT35PIWcpaE8jYC9VTyFfJGNYJFokY1gkXSRjWCRfJGNYJGYkY1h+TyFbL1ZPfk8hXylrTyRaL1hPJF0pak8kXylqTyRmL1lPfk8hXTxpTyFeKGZYflAjQndPIV4vWk9+TyFnKWhPJGYoe1h+TyRmL11Pfk92L15PflAhJnpPeCl5TyhiKXpPKGMvYU9+TyFTL2RPfk8oeSR9T24lYWEhUSVhYSd5JWFhKHolYWEhXSVhYSNgJWFhfk9nJWFhJE8lYWF+UCNMe08oeiVQT24lY2EhUSVjYSd5JWNhKHklY2EhXSVjYSNgJWNhfk9nJWNhJE8lY2F+UCNNbk8hXWZYIWdmWCFrZlghayR6WChyZlh+UCEwU09wJVdPIVsvbU8hXSheTyhUL2xPIVkodlAhWSlQUH5QITF1T3Iqc08hYipxTyFjKmtPIWQqa08hbCpiTyNbKnJPJWAqbU8oVSFsTyhWVE8oWVVPfk9zPH1PIVMvbk8hWytbTyFeKnBPKGU8fE8hXih4UH5QJCBbTyFrL29PflAjL3NPIV0vcE8hZyN2TyhyJ3BPIWspT1h+TyFrL3VPfk9ub1ghUW9YJ3lvWCh5b1goem9Yfk8hZyN2TyFrb1h+UCQjT09wL3dPIVMlaE8hWypeTyFfJWlPKFQlZ08haylPUH5PI2sveE9+TyFZJHpYIV0kelghZyVSWH5QITBTTyFdL3lPIVkpUFh+UCMvc08hZy97T35PIVkvfU9+T3BrTyhUME9PflAuaU9oJVZPcjBUTyFnI3ZPIWwlZU8ocidwT35PIWcraU9+T2Elbk8hXTBYTyd6JW5Pfk8hXjBaT35QITVpTyFjMFtPIWQwW08oVSFsT35QIyRgT3Mhbk8hUzBdTyhWVE8oWVVPKGUhbU9+TyNbMF9Pfk9nJWFhIV0lYWEjYCVhYSRPJWFhflAhMVdPZyVjYSFdJWNhI2AlY2EkTyVjYX5QITFXT2olZE9rJWRPbCVkTyhUJlpPZydtWCFdJ21Yfk8hXSp5T2coXmF+T2cwaE9+T24wak8jYDBpT2coX2EhXShfYX5PUjBrTyFRMGtPIVMwbE8jUyRkT259YSd5fWEoeX1hKHp9YSFdfWEjYH1hfk9nfWEkT31hflAkKGNPIVEqT08neSpQT24kc2EoeSRzYSh6JHNhIV0kc2EjYCRzYX5PZyRzYSRPJHNhflAkKV9PIVEqT08neSpQT24kdWEoeSR1YSh6JHVhIV0kdWEjYCR1YX5PZyR1YSRPJHVhflAkKlFPI2swb09+T2clVGEhXSVUYSNgJVRhJE8lVGF+UCExV08hZyN2T35PI2swck9+TyFdK15PYSlUYSd6KVRhfk9SI3pPIVEjeU8hUyN7TyFsI3hPKGFWT1AhcmlbIXJpaiFyaXIhcmkhXSFyaSFwIXJpI1IhcmkjbiFyaSNvIXJpI3AhcmkjcSFyaSNyIXJpI3MhcmkjdCFyaSN1IXJpI3YhcmkjeCFyaSN6IXJpI3shcmkociFyaSh5IXJpKHohcml+T2EhcmkneiFyaSd3IXJpIVkhcmkhayFyaXYhcmkhXyFyaSVpIXJpIWchcml+UCQrb09oJVZPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxzTyFTJHtPIV8kfE8haT5WTyFsJHhPI2o8eU8kVyVgTyR0PHVPJHY8d08keSVhTyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk9wMHtPJV0wfE8oVDB6T35QJC5WTyFnK2lPYShdYSFfKF1hJ3ooXWEhXShdYX5PI2sxU09+T1tdWCFdZlghXmZYfk8hXTFUTyFeKVhYfk8hXjFWT35PWzFXT35PYjFZTyhUK3FPKFZUTyhZVU9+TyFfJlBPKFQlZ09gJ3VYIV0ndVh+TyFdK3ZPYClXYX5PIWsxXU9+UCE6dE9bMWBPfk9gMWFPfk8jYDFmT35PbjFpTyFfJHxPfk8oZSh8TyFeKVVQfk9oJVZPbjFyTyFfMW9PJWkxcU9+T1sxfE8hXTF6TyFeKVZYfk8hXjF9T35PYDJQT2Elbk8neiVuT35PKFQjbk8oVlRPKFlVT35PI1MkZE8jYCRlTyRRJGVPUChnWFIoZ1hbKGdYcihnWCFRKGdYIVMoZ1ghXShnWCFsKGdYIXAoZ1gjUihnWCNuKGdYI28oZ1gjcChnWCNxKGdYI3IoZ1gjcyhnWCN0KGdYI3UoZ1gjdihnWCN4KGdYI3ooZ1gjeyhnWChhKGdYKHIoZ1goeShnWCh6KGdYfk9qMlNPJlsyVE9hKGdYflAkM3BPajJTTyNgJGVPJlsyVE9+T2EyVk9+UCVbT2EyWE9+TyZlMltPUCZjaVEmY2lTJmNpWSZjaWEmY2lkJmNpZSZjaWwmY2lwJmNpciZjaXMmY2l0JmNpeiZjaXwmY2khTyZjaSFTJmNpIVcmY2khWCZjaSFfJmNpIWkmY2khbCZjaSFvJmNpIXAmY2khcSZjaSFzJmNpIXUmY2kheCZjaSF8JmNpJFcmY2kkbiZjaSVoJmNpJWomY2klbCZjaSVtJmNpJW4mY2klcSZjaSVzJmNpJXYmY2kldyZjaSV5JmNpJlcmY2kmXiZjaSZgJmNpJmImY2kmZCZjaSZnJmNpJm0mY2kmcyZjaSZ1JmNpJncmY2kmeSZjaSZ7JmNpJ3cmY2koVCZjaShWJmNpKFkmY2koYSZjaShvJmNpIV4mY2liJmNpJmomY2l+T2IyYk8hXjJgTyZqMmFPflBgTyFfWE8hbDJkT35PJnEse09QJmxpUSZsaVMmbGlZJmxpYSZsaWQmbGllJmxpbCZsaXAmbGlyJmxpcyZsaXQmbGl6JmxpfCZsaSFPJmxpIVMmbGkhVyZsaSFYJmxpIV8mbGkhaSZsaSFsJmxpIW8mbGkhcCZsaSFxJmxpIXMmbGkhdSZsaSF4JmxpIXwmbGkkVyZsaSRuJmxpJWgmbGklaiZsaSVsJmxpJW0mbGklbiZsaSVxJmxpJXMmbGkldiZsaSV3JmxpJXkmbGkmVyZsaSZeJmxpJmAmbGkmYiZsaSZkJmxpJmcmbGkmbSZsaSZzJmxpJnUmbGkmdyZsaSZ5JmxpJnsmbGkndyZsaShUJmxpKFYmbGkoWSZsaShhJmxpKG8mbGkhXiZsaSZlJmxpYiZsaSZqJmxpfk8hWTJqT35PIV0hYWEhXiFhYX5QI0J3T3Mhbk8hUyFvTyFbMnBPKGUhbU8hXSdYWCFeJ1hYflBAbk8hXS1dTyFeKGlhfk8hXSdfWCFeJ19YflAhOXxPIV0tYE8hXih4YX5PIV4yd09+UCdfT2Elbk8jYDNRTyd6JW5Pfk9hJW5PIWcjdk8jYDNRTyd6JW5Pfk9hJW5PIWcjdk8hcDNVTyNgM1FPJ3olbk8ocidwT35PYSVuTyd6JW5PflAhOnRPIV0kX092JHFhfk8hWSdXaSFdJ1dpflAhOnRPIV0oVk8hWShoaX5PIV0oXk8hWSh2aX5PIVkod2khXSh3aX5QITp0TyFdKHRpIWsodGlhKHRpJ3oodGl+UCE6dE8jYDNXTyFdKHRpIWsodGlhKHRpJ3oodGl+TyFdKGpPIWsoc2l+TyFTJWhPIV8laU8hfF1PI2kzXU8jajNbTyhUJWdPfk8hUyVoTyFfJWlPI2ozW08oVCVnT35PbjNkTyFfJ2BPJWkzY09+T2glVk9uM2RPIV8nYE8laTNjT35PI2slYWFQJWFhUiVhYVslYWFhJWFhaiVhYXIlYWEhUyVhYSFsJWFhIXAlYWEjUiVhYSNuJWFhI28lYWEjcCVhYSNxJWFhI3IlYWEjcyVhYSN0JWFhI3UlYWEjdiVhYSN4JWFhI3olYWEjeyVhYSd6JWFhKGElYWEociVhYSFrJWFhIVklYWEndyVhYXYlYWEhXyVhYSVpJWFhIWclYWF+UCNMe08jayVjYVAlY2FSJWNhWyVjYWElY2FqJWNhciVjYSFTJWNhIWwlY2EhcCVjYSNSJWNhI24lY2EjbyVjYSNwJWNhI3ElY2EjciVjYSNzJWNhI3QlY2EjdSVjYSN2JWNhI3glY2EjeiVjYSN7JWNhJ3olY2EoYSVjYShyJWNhIWslY2EhWSVjYSd3JWNhdiVjYSFfJWNhJWklY2EhZyVjYX5QI01uTyNrJWFhUCVhYVIlYWFbJWFhYSVhYWolYWFyJWFhIVMlYWEhXSVhYSFsJWFhIXAlYWEjUiVhYSNuJWFhI28lYWEjcCVhYSNxJWFhI3IlYWEjcyVhYSN0JWFhI3UlYWEjdiVhYSN4JWFhI3olYWEjeyVhYSd6JWFhKGElYWEociVhYSFrJWFhIVklYWEndyVhYSNgJWFhdiVhYSFfJWFhJWklYWEhZyVhYX5QIy9zTyNrJWNhUCVjYVIlY2FbJWNhYSVjYWolY2FyJWNhIVMlY2EhXSVjYSFsJWNhIXAlY2EjUiVjYSNuJWNhI28lY2EjcCVjYSNxJWNhI3IlY2EjcyVjYSN0JWNhI3UlY2EjdiVjYSN4JWNhI3olY2EjeyVjYSd6JWNhKGElY2EociVjYSFrJWNhIVklY2EndyVjYSNgJWNhdiVjYSFfJWNhJWklY2EhZyVjYX5QIy9zTyNrfWFQfWFbfWFhfWFqfWFyfWEhbH1hIXB9YSNSfWEjbn1hI299YSNwfWEjcX1hI3J9YSNzfWEjdH1hI3V9YSN2fWEjeH1hI3p9YSN7fWEnen1hKGF9YShyfWEha31hIVl9YSd3fWF2fWEhX31hJWl9YSFnfWF+UCQoY08jayRzYVAkc2FSJHNhWyRzYWEkc2FqJHNhciRzYSFTJHNhIWwkc2EhcCRzYSNSJHNhI24kc2EjbyRzYSNwJHNhI3Ekc2EjciRzYSNzJHNhI3Qkc2EjdSRzYSN2JHNhI3gkc2EjeiRzYSN7JHNhJ3okc2EoYSRzYShyJHNhIWskc2EhWSRzYSd3JHNhdiRzYSFfJHNhJWkkc2EhZyRzYX5QJClfTyNrJHVhUCR1YVIkdWFbJHVhYSR1YWokdWFyJHVhIVMkdWEhbCR1YSFwJHVhI1IkdWEjbiR1YSNvJHVhI3AkdWEjcSR1YSNyJHVhI3MkdWEjdCR1YSN1JHVhI3YkdWEjeCR1YSN6JHVhI3skdWEneiR1YShhJHVhKHIkdWEhayR1YSFZJHVhJ3ckdWF2JHVhIV8kdWElaSR1YSFnJHVhflAkKlFPI2slVGFQJVRhUiVUYVslVGFhJVRhaiVUYXIlVGEhUyVUYSFdJVRhIWwlVGEhcCVUYSNSJVRhI24lVGEjbyVUYSNwJVRhI3ElVGEjciVUYSNzJVRhI3QlVGEjdSVUYSN2JVRhI3glVGEjeiVUYSN7JVRhJ3olVGEoYSVUYShyJVRhIWslVGEhWSVUYSd3JVRhI2AlVGF2JVRhIV8lVGElaSVUYSFnJVRhflAjL3NPYSNjcSFdI2NxJ3ojY3EndyNjcSFZI2NxIWsjY3F2I2NxIV8jY3ElaSNjcSFnI2NxflAhOnRPIVszbE8hXSdZWCFrJ1lYflAlW08hXS50TyFrKGthfk8hXS50TyFrKGthflAhOnRPIVkzb09+TyRPIW5hIV4hbmF+UEtsTyRPIWphIV0hamEhXiFqYX5QI0J3TyRPIXJhIV4hcmF+UCE9W08kTyF0YSFeIXRhflAhP3JPZyddWCFdJ11YflAhLFRPIV0vUE9nKHBhfk9TZk8hXzRUTyRkNFVPfk8hXjRZT35PdjRaT35QIy9zT2EkbXEhXSRtcSd6JG1xJ3ckbXEhWSRtcSFrJG1xdiRtcSFfJG1xJWkkbXEhZyRtcX5QITp0TyFZNF1PflAhJnpPIVM0Xk9+TyFRKk9PJ3kqUE8oeiVQT24naWEoeSdpYSFdJ2lhI2AnaWF+T2cnaWEkTydpYX5QJS1mTyFRKk9PJ3kqUE9uJ2thKHkna2EoeidrYSFdJ2thI2Ana2F+T2cna2EkTydrYX5QJS5YTyhyJFlPflAjL3NPIVlmWCFZJHpYIV1mWCFdJHpYIWclUlgjYGZYflAhMFNPcCVXTyhUPVdPflAhMXVPcDRiTyFTJWhPIVs0YU8hXyVpTyhUJWdPIV0nZVghaydlWH5PIV0vcE8haylPYX5PIV0vcE8hZyN2TyFrKU9hfk8hXS9wTyFnI3ZPKHIncE8haylPYX5PZyR8aSFdJHxpI2AkfGkkTyR8aX5QITFXTyFbNGpPIVknZ1ghXSdnWH5QITN0TyFdL3lPIVkpUGF+TyFdL3lPIVkpUGF+UCMvc09QXVhSXVhbXVhqXVhyXVghUV1YIVNdWCFZXVghXV1YIWxdWCFwXVgjUl1YI1NdWCNgXVgja2ZYI25dWCNvXVgjcF1YI3FdWCNyXVgjc11YI3RdWCN1XVgjdl1YI3hdWCN6XVgje11YJFFdWChhXVgocl1YKHldWCh6XVh+T2olWVghZyVZWH5QJTJPT2o0b08hZyN2T35PaCVWTyFnI3ZPIWwlZU9+T2glVk9yNHRPIWwlZU8ocidwT35PcjR5TyFnI3ZPKHIncE9+T3Mhbk8hUzR6TyhWVE8oWVVPKGUhbU9+Tyh5JH1PbiVhaSFRJWFpJ3klYWkoeiVhaSFdJWFpI2AlYWl+T2clYWkkTyVhaX5QJTVvTyh6JVBPbiVjaSFRJWNpJ3klY2koeSVjaSFdJWNpI2AlY2l+T2clY2kkTyVjaX5QJTZiT2coX2khXShfaX5QITFXTyNgNVFPZyhfaSFdKF9pflAhMVdPIWs1Vk9+T2Ekb3EhXSRvcSd6JG9xJ3ckb3EhWSRvcSFrJG9xdiRvcSFfJG9xJWkkb3EhZyRvcX5QITp0TyFZNVpPfk8hXTVbTyFfKVFYflAjL3NPYSR6WCFfJHpYJV5dWCd6JHpYIV0kelh+UCEwU08lXjVfT2FvWCFfb1gnem9YIV1vWH5QJCNPT3A1YE8oVCNuT35PJV41X09+T2I1Zk8lajVnTyhUK3FPKFZUTyhZVU8hXSd0WCFeJ3RYfk8hXTFUTyFeKVhhfk9bNWtPfk9gNWxPfk9bNXBPfk9hJW5PJ3olbk9+UCMvc08hXTV1TyNgNXdPIV4pVVh+TyFeNXhPfk9yNk9PcyFuTyFTKmlPIWIheU8hYyF2TyFkIXZPIXw8Vk8jVCFwTyNVIXBPI1YhcE8jVyFwTyNYIXBPI1s1fU8jXSF6TyhVIWxPKFZUTyhZVU8oZSFtTyhvIXNPfk8hXjV8T35QJTtlT242VE8hXzFvTyVpNlNPfk9oJVZPbjZUTyFfMW9PJWk2U09+T2I2W08oVCNuTyhWVE8oWVVPIV0nc1ghXidzWH5PIV0xek8hXilWYX5PKFZUTyhZVU8oZTZeT35PYDZiT35PajZlTyZbNmZPflBOWE8hazZnT35QJVtPYTZpT35PYTZpT35QJVtPYjJiTyFeNm5PJmoyYU9+UGBPIWc2cE9+TyFnNnJPaChqaSFdKGppIV4oamkhZyhqaSFsKGppcihqaShyKGppfk8hXSNoaSFeI2hpflAjQndPI2A2c08hXSNoaSFeI2hpfk8hXSFhaSFeIWFpflAjQndPYSVuTyNgNnxPJ3olbk9+T2Elbk8hZyN2TyNgNnxPJ3olbk9+TyFdKHRxIWsodHFhKHRxJ3oodHF+UCE6dE8hXShqTyFrKHNxfk8hUyVoTyFfJWlPI2o3VE8oVCVnT35PIV8nYE8laTdXT35PbjdbTyFfJ2BPJWk3V09+TyNrJ2lhUCdpYVInaWFbJ2lhYSdpYWonaWFyJ2lhIVMnaWEhbCdpYSFwJ2lhI1InaWEjbidpYSNvJ2lhI3AnaWEjcSdpYSNyJ2lhI3MnaWEjdCdpYSN1J2lhI3YnaWEjeCdpYSN6J2lhI3snaWEneidpYShhJ2lhKHInaWEhaydpYSFZJ2lhJ3cnaWF2J2lhIV8naWElaSdpYSFnJ2lhflAlLWZPI2sna2FQJ2thUidrYVsna2FhJ2thaidrYXIna2EhUydrYSFsJ2thIXAna2EjUidrYSNuJ2thI28na2EjcCdrYSNxJ2thI3Ina2EjcydrYSN0J2thI3Una2EjdidrYSN4J2thI3ona2EjeydrYSd6J2thKGEna2EocidrYSFrJ2thIVkna2EndydrYXYna2EhXydrYSVpJ2thIWcna2F+UCUuWE8jayR8aVAkfGlSJHxpWyR8aWEkfGlqJHxpciR8aSFTJHxpIV0kfGkhbCR8aSFwJHxpI1IkfGkjbiR8aSNvJHxpI3AkfGkjcSR8aSNyJHxpI3MkfGkjdCR8aSN1JHxpI3YkfGkjeCR8aSN6JHxpI3skfGkneiR8aShhJHxpKHIkfGkhayR8aSFZJHxpJ3ckfGkjYCR8aXYkfGkhXyR8aSVpJHxpIWckfGl+UCMvc08jayVhaVAlYWlSJWFpWyVhaWElYWlqJWFpciVhaSFTJWFpIWwlYWkhcCVhaSNSJWFpI24lYWkjbyVhaSNwJWFpI3ElYWkjciVhaSNzJWFpI3QlYWkjdSVhaSN2JWFpI3glYWkjeiVhaSN7JWFpJ3olYWkoYSVhaShyJWFpIWslYWkhWSVhaSd3JWFpdiVhaSFfJWFpJWklYWkhZyVhaX5QJTVvTyNrJWNpUCVjaVIlY2lbJWNpYSVjaWolY2lyJWNpIVMlY2khbCVjaSFwJWNpI1IlY2kjbiVjaSNvJWNpI3AlY2kjcSVjaSNyJWNpI3MlY2kjdCVjaSN1JWNpI3YlY2kjeCVjaSN6JWNpI3slY2kneiVjaShhJWNpKHIlY2khayVjaSFZJWNpJ3clY2l2JWNpIV8lY2klaSVjaSFnJWNpflAlNmJPIV0nWWEhaydZYX5QITp0TyFdLnRPIWsoa2l+TyRPI2NpIV0jY2khXiNjaX5QI0J3T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08oYVZPWyNtaWojbWlyI21pI1IjbWkjbyNtaSNwI21pI3EjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJE8jbWkociNtaSh5I21pKHojbWkhXSNtaSFeI21pfk8jbiNtaX5QJU5kTyNuPF9PflAlTmRPUCRbT1Ijek9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jbjxfTyNvPGBPI3A8YE8jcTxgTyhhVk9bI21paiNtaSNSI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkkTyNtaShyI21pKHkjbWkoeiNtaSFdI21pIV4jbWl+TyNyI21pflAmIWxPI3I8YU9+UCYhbE9QJFtPUiN6T1s8bU9qPGJPcjxrTyFRI3lPIVMje08hbCN4TyFwJFtPI1I8Yk8jbjxfTyNvPGBPI3A8YE8jcTxgTyNyPGFPI3M8Yk8jdDxiTyN1PGxPKGFWTyN4I21pI3ojbWkjeyNtaSRPI21pKHIjbWkoeSNtaSh6I21pIV0jbWkhXiNtaX5PI3YjbWl+UCYkdE9QJFtPUiN6T1s8bU9qPGJPcjxrTyFRI3lPIVMje08hbCN4TyFwJFtPI1I8Yk8jbjxfTyNvPGBPI3A8YE8jcTxgTyNyPGFPI3M8Yk8jdDxiTyN1PGxPI3Y8Y08oYVZPKHojfU8jeiNtaSN7I21pJE8jbWkociNtaSh5I21pIV0jbWkhXiNtaX5PI3g8ZU9+UCYmdU8jeCNtaX5QJiZ1TyN2PGNPflAmJHRPUCRbT1Ijek9bPG1PajxiT3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNSPGJPI248X08jbzxgTyNwPGBPI3E8YE8jcjxhTyNzPGJPI3Q8Yk8jdTxsTyN2PGNPI3g8ZU8oYVZPKHkjfE8oeiN9TyN7I21pJE8jbWkociNtaSFdI21pIV4jbWl+TyN6I21pflAmKVVPI3o8Z09+UCYpVU9hI3x5IV0jfHkneiN8eSd3I3x5IVkjfHkhayN8eXYjfHkhXyN8eSVpI3x5IWcjfHl+UCE6dE9bI21paiNtaXIjbWkjUiNtaSNyI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkkTyNtaShyI21pIV0jbWkhXiNtaX5PUCRbT1Ijek8hUSN5TyFTI3tPIWwjeE8hcCRbTyNuPF9PI288YE8jcDxgTyNxPGBPKGFWTyh5I21pKHojbWl+UCYsUU9uPl5PIVEqT08neSpQTyh5JH1PKHolUE9QI21pUiNtaSFTI21pIWwjbWkhcCNtaSNuI21pI28jbWkjcCNtaSNxI21pKGEjbWl+UCYsUU8jUyRkT1AoYFhSKGBYWyhgWGooYFhuKGBYcihgWCFRKGBYIVMoYFghbChgWCFwKGBYI1IoYFgjbihgWCNvKGBYI3AoYFgjcShgWCNyKGBYI3MoYFgjdChgWCN1KGBYI3YoYFgjeChgWCN6KGBYI3soYFgkTyhgWCd5KGBYKGEoYFgocihgWCh5KGBYKHooYFghXShgWCFeKGBYfk8kTyRQaSFdJFBpIV4kUGl+UCNCd08kTyFyaSFeIXJpflAkK29PZyddYSFdJ11hflAhMVdPIV43bk9+TyFdJ2RhIV4nZGF+UCNCd08hWTdvT35QIy9zTyFnI3ZPKHIncE8hXSdlYSFrJ2Vhfk8hXS9wTyFrKU9pfk8hXS9wTyFnI3ZPIWspT2l+T2ckfHEhXSR8cSNgJHxxJE8kfHF+UCExV08hWSdnYSFdJ2dhflAjL3NPIWc3dk9+TyFdL3lPIVkpUGl+UCMvc08hXS95TyFZKVBpfk8hWTd5T35PaCVWT3I4T08hbCVlTyhyJ3BPfk9qOFFPIWcjdk9+T3I4VE8hZyN2TyhyJ3BPfk8hUSpPTyd5KlBPKHolUE9uJ2phKHknamEhXSdqYSNgJ2phfk9nJ2phJE8namF+UCY1Uk8hUSpPTyd5KlBPbidsYSh5J2xhKHonbGEhXSdsYSNgJ2xhfk9nJ2xhJE8nbGF+UCY1dE9nKF9xIV0oX3F+UCExV08jYDhWT2coX3EhXShfcX5QITFXTyFZOFdPfk9nJU9xIV0lT3EjYCVPcSRPJU9xflAhMVdPYSRveSFdJG95J3okb3kndyRveSFZJG95IWskb3l2JG95IV8kb3klaSRveSFnJG95flAhOnRPIWc2ck9+TyFdNVtPIV8pUWF+TyFfJ2BPUCRUYVIkVGFbJFRhaiRUYXIkVGEhUSRUYSFTJFRhIV0kVGEhbCRUYSFwJFRhI1IkVGEjbiRUYSNvJFRhI3AkVGEjcSRUYSNyJFRhI3MkVGEjdCRUYSN1JFRhI3YkVGEjeCRUYSN6JFRhI3skVGEoYSRUYShyJFRhKHkkVGEoeiRUYX5PJWk3V09+UCY4Zk8lXjhbT2ElW2khXyVbaSd6JVtpIV0lW2l+T2EjY3khXSNjeSd6I2N5J3cjY3khWSNjeSFrI2N5diNjeSFfI2N5JWkjY3khZyNjeX5QITp0T1s4Xk9+T2I4YE8oVCtxTyhWVE8oWVVPfk8hXTFUTyFeKVhpfk9gOGRPfk8oZSh8TyFdJ3BYIV4ncFh+TyFdNXVPIV4pVWF+TyFeOG5PflAlO2VPKG8hc09+UCQmWU8jWzhvT35PIV8xb09+TyFfMW9PJWk4cU9+T244dE8hXzFvTyVpOHFPfk9bOHlPIV0nc2EhXidzYX5PIV0xek8hXilWaX5PIWs4fU9+TyFrOU9Pfk8hazlST35PIWs5Uk9+UCVbT2E5VE9+TyFnOVVPfk8hazlWT35PIV0od2khXih3aX5QI0J3T2Elbk8jYDlfTyd6JW5Pfk8hXSh0eSFrKHR5YSh0eSd6KHR5flAhOnRPIV0oak8hayhzeX5PJWk5Yk9+UCY4Zk8hXydgTyVpOWJPfk8jayR8cVAkfHFSJHxxWyR8cWEkfHFqJHxxciR8cSFTJHxxIV0kfHEhbCR8cSFwJHxxI1IkfHEjbiR8cSNvJHxxI3AkfHEjcSR8cSNyJHxxI3MkfHEjdCR8cSN1JHxxI3YkfHEjeCR8cSN6JHxxI3skfHEneiR8cShhJHxxKHIkfHEhayR8cSFZJHxxJ3ckfHEjYCR8cXYkfHEhXyR8cSVpJHxxIWckfHF+UCMvc08jaydqYVAnamFSJ2phWydqYWEnamFqJ2phcidqYSFTJ2phIWwnamEhcCdqYSNSJ2phI24namEjbydqYSNwJ2phI3EnamEjcidqYSNzJ2phI3QnamEjdSdqYSN2J2phI3gnamEjeidqYSN7J2phJ3onamEoYSdqYShyJ2phIWsnamEhWSdqYSd3J2phdidqYSFfJ2phJWknamEhZydqYX5QJjVSTyNrJ2xhUCdsYVInbGFbJ2xhYSdsYWonbGFyJ2xhIVMnbGEhbCdsYSFwJ2xhI1InbGEjbidsYSNvJ2xhI3AnbGEjcSdsYSNyJ2xhI3MnbGEjdCdsYSN1J2xhI3YnbGEjeCdsYSN6J2xhI3snbGEneidsYShhJ2xhKHInbGEhaydsYSFZJ2xhJ3cnbGF2J2xhIV8nbGElaSdsYSFnJ2xhflAmNXRPI2slT3FQJU9xUiVPcVslT3FhJU9xaiVPcXIlT3EhUyVPcSFdJU9xIWwlT3EhcCVPcSNSJU9xI24lT3EjbyVPcSNwJU9xI3ElT3EjciVPcSNzJU9xI3QlT3EjdSVPcSN2JU9xI3glT3EjeiVPcSN7JU9xJ3olT3EoYSVPcShyJU9xIWslT3EhWSVPcSd3JU9xI2AlT3F2JU9xIV8lT3ElaSVPcSFnJU9xflAjL3NPIV0nWWkhaydZaX5QITp0TyRPI2NxIV0jY3EhXiNjcX5QI0J3Tyh5JH1PUCVhYVIlYWFbJWFhaiVhYXIlYWEhUyVhYSFsJWFhIXAlYWEjUiVhYSNuJWFhI28lYWEjcCVhYSNxJWFhI3IlYWEjcyVhYSN0JWFhI3UlYWEjdiVhYSN4JWFhI3olYWEjeyVhYSRPJWFhKGElYWEociVhYSFdJWFhIV4lYWF+T24lYWEhUSVhYSd5JWFhKHolYWF+UCZJeU8oeiVQT1AlY2FSJWNhWyVjYWolY2FyJWNhIVMlY2EhbCVjYSFwJWNhI1IlY2EjbiVjYSNvJWNhI3AlY2EjcSVjYSNyJWNhI3MlY2EjdCVjYSN1JWNhI3YlY2EjeCVjYSN6JWNhI3slY2EkTyVjYShhJWNhKHIlY2EhXSVjYSFeJWNhfk9uJWNhIVElY2EneSVjYSh5JWNhflAmTFFPbj5eTyFRKk9PJ3kqUE8oeiVQT35QJkl5T24+Xk8hUSpPTyd5KlBPKHkkfU9+UCZMUU9SMGtPIVEwa08hUzBsTyNTJGRPUH1hW31han1hbn1hcn1hIWx9YSFwfWEjUn1hI259YSNvfWEjcH1hI3F9YSNyfWEjc31hI3R9YSN1fWEjdn1hI3h9YSN6fWEje31hJE99YSd5fWEoYX1hKHJ9YSh5fWEoen1hIV19YSFefWF+TyFRKk9PJ3kqUE9QJHNhUiRzYVskc2FqJHNhbiRzYXIkc2EhUyRzYSFsJHNhIXAkc2EjUiRzYSNuJHNhI28kc2EjcCRzYSNxJHNhI3Ikc2EjcyRzYSN0JHNhI3Ukc2EjdiRzYSN4JHNhI3okc2EjeyRzYSRPJHNhKGEkc2EociRzYSh5JHNhKHokc2EhXSRzYSFeJHNhfk8hUSpPTyd5KlBPUCR1YVIkdWFbJHVhaiR1YW4kdWFyJHVhIVMkdWEhbCR1YSFwJHVhI1IkdWEjbiR1YSNvJHVhI3AkdWEjcSR1YSNyJHVhI3MkdWEjdCR1YSN1JHVhI3YkdWEjeCR1YSN6JHVhI3skdWEkTyR1YShhJHVhKHIkdWEoeSR1YSh6JHVhIV0kdWEhXiR1YX5Pbj5eTyFRKk9PJ3kqUE8oeSR9Tyh6JVBPfk9QJVRhUiVUYVslVGFqJVRhciVUYSFTJVRhIWwlVGEhcCVUYSNSJVRhI24lVGEjbyVUYSNwJVRhI3ElVGEjciVUYSNzJVRhI3QlVGEjdSVUYSN2JVRhI3glVGEjeiVUYSN7JVRhJE8lVGEoYSVUYShyJVRhIV0lVGEhXiVUYX5QJydWTyRPJG1xIV0kbXEhXiRtcX5QI0J3TyRPJG9xIV0kb3EhXiRvcX5QI0J3TyFeOW9Pfk8kTzlwT35QITFXTyFnI3ZPIV0nZWkhaydlaX5PIWcjdk8ocidwTyFdJ2VpIWsnZWl+TyFdL3BPIWspT3F+TyFZJ2dpIV0nZ2l+UCMvc08hXS95TyFZKVBxfk9yOXdPIWcjdk8ocidwT35PWzl5TyFZOXhPflAjL3NPIVk5eE9+T2o6UE8hZyN2T35PZyhfeSFdKF95flAhMVdPIV0nbmEhXyduYX5QIy9zT2ElW3EhXyVbcSd6JVtxIV0lW3F+UCMvc09bOlVPfk8hXTFUTyFeKVhxfk9gOllPfk8jYDpaTyFdJ3BhIV4ncGF+TyFdNXVPIV4pVWl+UCNCd08hUzpdT35PIV8xb08laTpgT35PKFZUTyhZVU8oZTplT35PIV0xek8hXilWcX5PIWs6aE9+TyFrOmlPfk8hazpqT35PIWs6ak9+UCVbTyNgOm1PIV0jaHkhXiNoeX5PIV0jaHkhXiNoeX5QI0J3TyVpOnJPflAmOGZPIV8nYE8laTpyT35PJE8jfHkhXSN8eSFeI3x5flAjQndPUCR8aVIkfGlbJHxpaiR8aXIkfGkhUyR8aSFsJHxpIXAkfGkjUiR8aSNuJHxpI28kfGkjcCR8aSNxJHxpI3IkfGkjcyR8aSN0JHxpI3UkfGkjdiR8aSN4JHxpI3okfGkjeyR8aSRPJHxpKGEkfGkociR8aSFdJHxpIV4kfGl+UCcnVk8hUSpPTyd5KlBPKHolUE9QJ2lhUidpYVsnaWFqJ2lhbidpYXInaWEhUydpYSFsJ2lhIXAnaWEjUidpYSNuJ2lhI28naWEjcCdpYSNxJ2lhI3InaWEjcydpYSN0J2lhI3UnaWEjdidpYSN4J2lhI3onaWEjeydpYSRPJ2lhKGEnaWEocidpYSh5J2lhIV0naWEhXidpYX5PIVEqT08neSpQT1Ana2FSJ2thWydrYWona2FuJ2thcidrYSFTJ2thIWwna2EhcCdrYSNSJ2thI24na2EjbydrYSNwJ2thI3Ena2EjcidrYSNzJ2thI3Qna2EjdSdrYSN2J2thI3gna2EjeidrYSN7J2thJE8na2EoYSdrYShyJ2thKHkna2EoeidrYSFdJ2thIV4na2F+Tyh5JH1PUCVhaVIlYWlbJWFpaiVhaW4lYWlyJWFpIVElYWkhUyVhaSFsJWFpIXAlYWkjUiVhaSNuJWFpI28lYWkjcCVhaSNxJWFpI3IlYWkjcyVhaSN0JWFpI3UlYWkjdiVhaSN4JWFpI3olYWkjeyVhaSRPJWFpJ3klYWkoYSVhaShyJWFpKHolYWkhXSVhaSFeJWFpfk8oeiVQT1AlY2lSJWNpWyVjaWolY2luJWNpciVjaSFRJWNpIVMlY2khbCVjaSFwJWNpI1IlY2kjbiVjaSNvJWNpI3AlY2kjcSVjaSNyJWNpI3MlY2kjdCVjaSN1JWNpI3YlY2kjeCVjaSN6JWNpI3slY2kkTyVjaSd5JWNpKGElY2kociVjaSh5JWNpIV0lY2khXiVjaX5PJE8kb3khXSRveSFeJG95flAjQndPJE8jY3khXSNjeSFeI2N5flAjQndPIWcjdk8hXSdlcSFrJ2Vxfk8hXS9wTyFrKU95fk8hWSdncSFdJ2dxflAjL3NPcjp8TyFnI3ZPKHIncE9+T1s7UU8hWTtQT35QIy9zTyFZO1BPfk9nKF8hUiFdKF8hUn5QITFXT2ElW3khXyVbeSd6JVt5IV0lW3l+UCMvc08hXTFUTyFeKVh5fk8hXTV1TyFeKVVxfk8oVDtYT35PIV8xb08laTtbT35PIWs7X09+TyVpO2RPflAmOGZPUCR8cVIkfHFbJHxxaiR8cXIkfHEhUyR8cSFsJHxxIXAkfHEjUiR8cSNuJHxxI28kfHEjcCR8cSNxJHxxI3IkfHEjcyR8cSN0JHxxI3UkfHEjdiR8cSN4JHxxI3okfHEjeyR8cSRPJHxxKGEkfHEociR8cSFdJHxxIV4kfHF+UCcnVk8hUSpPTyd5KlBPKHolUE9QJ2phUidqYVsnamFqJ2phbidqYXInamEhUydqYSFsJ2phIXAnamEjUidqYSNuJ2phI28namEjcCdqYSNxJ2phI3InamEjcydqYSN0J2phI3UnamEjdidqYSN4J2phI3onamEjeydqYSRPJ2phKGEnamEocidqYSh5J2phIV0namEhXidqYX5PIVEqT08neSpQT1AnbGFSJ2xhWydsYWonbGFuJ2xhcidsYSFTJ2xhIWwnbGEhcCdsYSNSJ2xhI24nbGEjbydsYSNwJ2xhI3EnbGEjcidsYSNzJ2xhI3QnbGEjdSdsYSN2J2xhI3gnbGEjeidsYSN7J2xhJE8nbGEoYSdsYShyJ2xhKHknbGEoeidsYSFdJ2xhIV4nbGF+T1AlT3FSJU9xWyVPcWolT3FyJU9xIVMlT3EhbCVPcSFwJU9xI1IlT3EjbiVPcSNvJU9xI3AlT3EjcSVPcSNyJU9xI3MlT3EjdCVPcSN1JU9xI3YlT3EjeCVPcSN6JU9xI3slT3EkTyVPcShhJU9xKHIlT3EhXSVPcSFeJU9xflAnJ1ZPZyVlIVohXSVlIVojYCVlIVokTyVlIVp+UCExV08hWTtoT35QIy9zT3I7aU8hZyN2TyhyJ3BPfk9bO2tPIVk7aE9+UCMvc08hXSdwcSFeJ3BxflAjQndPIV0jaCFaIV4jaCFaflAjQndPI2slZSFaUCVlIVpSJWUhWlslZSFaYSVlIVpqJWUhWnIlZSFaIVMlZSFaIV0lZSFaIWwlZSFaIXAlZSFaI1IlZSFaI24lZSFaI28lZSFaI3AlZSFaI3ElZSFaI3IlZSFaI3MlZSFaI3QlZSFaI3UlZSFaI3YlZSFaI3glZSFaI3olZSFaI3slZSFaJ3olZSFaKGElZSFaKHIlZSFaIWslZSFaIVklZSFaJ3clZSFaI2AlZSFadiVlIVohXyVlIVolaSVlIVohZyVlIVp+UCMvc09yO3RPIWcjdk8ocidwT35PIVk7dU9+UCMvc09yO3xPIWcjdk8ocidwT35PIVk7fU9+UCMvc09QJWUhWlIlZSFaWyVlIVpqJWUhWnIlZSFaIVMlZSFaIWwlZSFaIXAlZSFaI1IlZSFaI24lZSFaI28lZSFaI3AlZSFaI3ElZSFaI3IlZSFaI3MlZSFaI3QlZSFaI3UlZSFaI3YlZSFaI3glZSFaI3olZSFaI3slZSFaJE8lZSFaKGElZSFaKHIlZSFaIV0lZSFaIV4lZSFaflAnJ1ZPcjxRTyFnI3ZPKHIncE9+T3YoZlh+UDFxTyFRJXJPflAhKVtPKFUhbE9+UCEpW08hWWZYIV1mWCNgZlh+UCUyT09QXVhSXVhbXVhqXVhyXVghUV1YIVNdWCFdXVghXWZYIWxdWCFwXVgjUl1YI1NdWCNgXVgjYGZYI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgoYV1YKHJdWCh5XVgoel1Yfk8hZ2ZYIWtdWCFrZlgocmZYflAnTFRPUDxVT1E8VU9TZk9kPlJPZSFpT3BrT3I8VU9za090a096a098PFVPIU88VU8hU1dPIVdrTyFYa08hX1hPIWk8WE8hbFpPIW88VU8hcDxVTyFxPFVPIXM8WU8hdTxdTyF4IWhPJFcha08kbj5QTyhUKV1PKFZUTyhZVU8oYVZPKG9bT35PIV08aU8hXiRxYX5PaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPPHRPIVMke08hXyR8TyFpPldPIWwkeE8jajx6TyRXJWBPJHQ8dk8kdjx4TyR5JWFPKFQodk8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PbClkT35QKCF5T3IhZVgociFlWH5QIyFpT3IoalgocihqWH5QIyNbTyFeXVghXmZYflAnTFRPIVlmWCFZJHpYIV1mWCFdJHpYI2BmWH5QITBTTyNrPF5Pfk8hZyN2TyNrPF5Pfk8jYDxuT35PajxiT35PI2A9T08hXSh3WCFeKHdYfk8jYDxuTyFdKHVYIV4odVh+TyNrPVBPfk9nPVJPflAhMVdPI2s9WE9+TyNrPVlPfk9nPVJPKFQmWk9+TyFnI3ZPI2s9Wk9+TyFnI3ZPI2s9UE9+TyRPPVtPflAjQndPI2s9XU9+TyNrPV5Pfk8jaz1jT35PI2s9ZE9+TyNrPWVPfk8jaz1mT35PJE89Z09+UCExV08kTz1oT35QITFXT2w9c09+UDdlT2sjUyNUI1UjVyNYI1sjaSNqI3UkbiR0JHYkeSVdJV4laCVpJWolcSVzJXYldyV5JXt+KE9UI28hWCd8KFUjcHMjbiNxciFRJ30kXSd9KFQkXyhlflwiLFxuICBnb3RvOiBcIiQ5WSldUFBQUFBQKV5QUClhUClyUCtXL11QUFBQNm1QUDdUUFA9UVBQUEB0UEFeUEFeUFBQQV5QQ2ZQQV5QQV5QQV5QQ2pQQ29QRF5QSVdQUFBJW1BQUFBJW0xfUFBQTGVNVlBJW1BJW1BQISBlSVtQUFBJW1BJW1AhI2xJW1AhJ1MhKFghKGJQISlVISlZISlVISxnUFBQUFBQUCEtVyEoWFBQIS1oIS9ZUCEyaUlbSVshMm4hNXohOmghOmghPmdQUFAhPm9JW1BQUFBQUFBQUCFCT1AhQ11QUElbIURuUElbUElbSVtJW0lbSVtQSVshRlFQIUlbUCFMYlAhTGYhTHAhTHQhTHRQIUlYUCFMeCFMeFAjIU9QIyFTSVtQSVsjIVkjJV9DakFeUEFeUEFeQV5QIyZsQV5BXiMpT0FeIyt2QV4jLlNBXkFeIy5yIzFXIzFXIzFdIzFmIzFXIzFxUFAjMVdQQV4jMlpBXiM2WUFeQV42bVBQUCM6X1BQUCM6eCM6eFAjOnhQIztgIzp4UFAjO2ZQIztdUCM7XSM7eSM7XSM8ZSM8ayM8bilhUCM8cSlhUCM8eiM8eiM8elApYVApYVApYVApYVBQKWFQIz1RIz1UUCM9VClhUCM9WFAjPVtQKWFQKWFQKWFQKWFQKWFQKWEpYVBQIz1iIz1oIz1zIz15Iz5QIz5WIz5dIz5rIz5xIz57Iz9SIz9dIz9jIz9zIz95I0BrI0B9I0FUI0FaI0FpI0JPI0NzI0RSI0RZI0V0I0ZTI0d0I0hTI0hZI0hgI0hmI0hwI0h2I0h8I0lXI0lqI0lwUFBQUFBQUFBQUFAjSXZQUFBQUFBQI0prI014JCBiJCBpJCBxUFBQJCddUCQnZiQqXyQweCQweyQxTyQxfSQyUSQyWCQyYVAkMmckMmpQJDNXJDNbJDRTJDViJDVnJDV9UFAkNlMkNlkkNl4kNmEkNmUkNmkkN2UkN3wkOGUkOGkkOGwkOG8kOHkkOHwkOVEkOVVSIXxSb3FPWHN0IVojZCVtJnImdCZ1Jncscyx4MlsyX1khdlEnYC1lMW81e1EldHZRJXx5USZUfFEmaiFWUydXIWUtXVEnZiFpUydsIXIheVUqayR8Kloqb1ErbyV9Uyt8JlYmV1EsZCZkUS1jJ19RLW0nZ1EtdSdtUTBbKnFRMWIsT1ExeSxlUjx7PFklU2RPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdLHAscyx4LWktcS5QLlYudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2w0ejZUNmU2ZjZpNnw4dDlUOV9TI3FdPFYhcilfJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNVK1AlXTxzPHRRK3QmUFEsZiZnUSxtJm9RMHgrZ1EwfStpUTFZK3VRMlIsa1EzYC5nUTVgMHxRNWYxVFE2WzF6UTdZM2RROGA1Z1I5ZTdbJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TIVMhblEhciF2IXkheiR8J1cnXydgJ2wnbSduKmsqbypxKnItXS1jLWUtdTBbMF8xbzV7NX0lWyR0aSN2JGIkYyRkJHgkeyVPJVElXiVfJWMpeSpSKlQqVipZKmEqZyp3KngrZitpLFMsVi5mL1AvZC9tL3gveS97MGAwYjBpMGowbzFmMWkxcTNjNF40XzRqNG81UTVbNV82UzdXN3Y4UThWOFs4cTliOXA5eTpQOmA6cjtRO1s7ZDtrPGw8bTxvPHA8cTxyPHU8djx3PHg8eTx6PVM9VD1VPVY9WD1ZPV09Xj1fPWA9YT1iPWM9ZD1nPWg+UD5YPlk+XT5eUSZYfFEnVSFlUydbJWktYFErdCZQUSxQJldRLGYmZ1EwbitTUTFZK3VRMV8re1EyUSxqUTJSLGtRNWYxVFE1bzFhUTZbMXpRNl8xfFE2YDJQUThgNWdROGM1bFE4fDZiUTpYOGRROmY4eVE7VjpZUjx9Klpybk9Yc3QhViFaI2QlbSZpJnImdCZ1Jncscyx4MlsyX1IsaCZrJnpeT1BYWXN0dXZ3eiFaIWAhZyFqIW8jUyNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnYidyKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlI+U1sjXVdaI1cjWidYKFQhYiVqbSNoI2kjbCR4JWUlaCheKGgoaShqKlkqXipiK1orWyteLG8tVi5ULlouWy5dLl8vbS9wMmQzWzNdNGE2cjdUUSV3eFEle3lXJlF8JlYmVyxPUSZfIVRRJ2MhaFEnZSFpUShxI3NTK24lfCV9UStyJlBRLF8mYlEsYyZkUy1sJ2YnZ1EuaShyUTFSK29RMVgrdVExWit2UTFeK3pRMXQsYFMxeCxkLGVRMnwtbVE1ZTFUUTVpMVdRNW4xYFE2WjF5UThfNWdROGI1a1E4ZjVwUTpUOF5SO1Q6VSFVJHppJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPlkhXiV5eSFpIXUleyV8JX0nVidlJ2YnZydrJ3UqaituK28tWS1sLW0tdDBSMFUxUjJ1MnwzVDRyNHM0djd9OXtRK2gld1EsVCZbUSxXJl1RLGImZFEuaChxUTFzLF9VMXcsYyxkLGVRM2UuaVE2VTF0UzZZMXgxeVE4eDZaI2Y+VCN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm8+VTxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aFclVGklVip5PlBTJlshUSZpUSZdIVJRJl4hU1UqfSVbJWQ9c1IsUiZZJV0lU2kjdiRiJGMkZCR4JHslTyVRJV4lXyVjKXkqUipUKlYqWSphKmcqdyp4K2YraSxTLFYuZi9QL2QvbS94L3kvezBgMGIwaTBqMG8xZjFpMXEzYzReNF80ajRvNVE1WzVfNlM3Vzd2OFE4VjhbOHE5YjlwOXk6UDpgOnI7UTtbO2Q7azxsPG08bzxwPHE8cjx1PHY8dzx4PHk8ej1TPVQ9VT1WPVg9WT1dPV49Xz1gPWE9Yj1jPWQ9Zz1oPlA+WD5ZPl0+XlQpeiR1KXtWK1AlXTxzPHRXJ1shZSVpKlotYFMofSN5I3pRK2MlclEreSZTUy5iKG0oblExaixYUTVUMGtSOGk1dSdRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+UyRpJF5jI1kjZSVxJXMldShTKFkodCh5KVIpUylUKVUpVilXKVgpWSlaKVspXilgKWIpZylxK2QreC1aLXgtfS5TLlUucy52LnoufC59L08vYjBwMmsybjNPM1YzazNwM3EzcjNzM3QzdTN2M3czeDN5M3ozezN8NFA0UTRYNVg1YzZ1Nns3UTdhN2I3azdsOGs5WDldOWc5bTluOm87VztgPFc9dlQjVFYjVSdSa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1EnWSFlUjJxLV0hVyFuUSFlIXIhdiF5IXokfCdXJ18nYCdsJ20nbipaKmsqbypxKnItXS1jLWUtdTBbMF8xbzV7NX1SMWwsWm5xT1hzdCFaI2QlbSZyJnQmdSZ3LHMseDJbMl9RJnkhXlEndiF4UyhzI3U8XlErbCV6USxdJl9RLF4mYVEtaidkUS13J29TLnIoeD1QUzBxK1g9WlExUCttUTFuLFtRMmMselEyZSx7UTJtLVdRMnota1EyfS1vUzVZMHI9ZVE1YTFRUzVkMVM9ZlE2dDJvUTZ4MntRNn0zU1E4XTViUTlZNnZROVo2eVE5XjdPUjpsOVYkZCRdYyNZI2UlcyV1KFMoWSh0KHkpUilTKVQpVSlWKVcpWClZKVopWyleKWApYilnKXErZCt4LVoteC19LlMuVS5zLnYuei59L08vYjBwMmsybjNPM1YzazNwM3EzcjNzM3QzdTN2M3czeDN5M3ozezN8NFA0UTRYNVg1YzZ1Nns3UTdhN2I3azdsOGs5WDldOWc5bTluOm87VztgPFc9dlMobyNwJ2lRKVAjelMrYiVxLnxTLmMobihwUjNeLmQnUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNTI3FdPFZRJnQhWFEmdSFZUSZ3IVtRJnghXVIyWix2USdhIWhRK2Uld1EtaCdjUy5lKHEraFEyeC1nVzNiLmguaTB3MHlRNncyeVc3VTNfM2EzZTVeVTlhN1Y3WDdaVTpxOWM5ZDlmUztiOnA6c1E7cDtjUjt4O3FVIXdRJ2AtZVQ1eTFvNXshUV9PWFpgc3QhViFaI2QjaCVlJW0maSZrJnImdCZ1JncoaixzLHguWzJbMl9dIXBRIXInYC1lMW81e1QjcV08ViVee09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXStnLHAscyx4LWktcS5QLlYuZy50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czZDNsNHo2VDZlNmY2aTZ8N1s4dDlUOV9TKH0jeSN6Uy5iKG0obiFzPWwkWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1UkZmQpXyxtUyhwI3AnaVUqdiVSKHc0T1UwbStPLm43Z1E1XjB4UTdWM2BROWQ3WVI6czllbSF0USFyIXYheSF6J2AnbCdtJ24tZS11MW81ezV9USd0IXVTKGYjZzJVUy1zJ2snd1EvcypdUTBSKmpRM1UtdlE0Zi90UTRyMFRRNHMwVVE0eDBeUTdyNGBTN300dDR2UzhSNHk0e1E5cjdzUTl2N3lROXs4T1E6UThUUzp7OXc5eFM7Zzp8O1BTO3M7aDtpUzt7O3Q7dVM8UDt8O31SPFM8UVEjd2JRJ3MhdVMoZSNnMlVTKGcjbStXUStZJWZRK2oleFErcCZPVS1yJ2sndCd3US5XKGZVL3IqXSpgL3dRMFMqalEwVipsUTFPK2tRMXUsYVMzUi1zLXZRM1ouYFM0ZS9zL3RRNG4wUFM0cTBSMF5RNHUwV1E2VzF2UTdQM1VTN3E0YDRiUTd1NGZVN3w0cjR4NHtROFA0d1E4djZYUzlxN3I3c1E5dTd5UTl9OFJROk84U1E6Yzh3UTp5OXJTOno5djl4UTtTOlFRO146ZFM7Zjp7O1BTO3I7ZztoUzt6O3M7dVM8Tzt7O31RPFI8UFE8VDxTUT1vPWpRPXs9dFI9fD11ViF3USdgLWUlXmFPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfUyN3eiFqIXI9aSRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUj1vPlIlXmJPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfUSVmaiFeJXh5IWkhdSV7JXwlfSdWJ2UnZidnJ2sndSpqK24rby1ZLWwtbS10MFIwVTFSMnUyfDNUNHI0czR2N305e1MmT3ohalErayV5USxhJmRXMXYsYixjLGQsZVU2WDF3MXgxeVM4dzZZNlpROmQ4eCFyPWokWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1E9dD5RUj11PlIlUWVPUFhZc3R1dnchWiFgIWchbyNTI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZyJnQmdSZ3JnsnVCdiJ3IoVihdKGQoeCh6KU8pfSppK1grXStnLHAscyx4LWktcS5QLlYuZy50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czZDNsNHo2VDZlNmY2aTZ8N1s4dDlUOV9ZI2JXWiNXI1ooVCFiJWptI2gjaSNsJHglZSVoKF4oaChpKGoqWSpeKmIrWitbK14sby1WLlQuWi5bLl0uXy9tL3AyZDNbM100YTZyN1RRLG4mbyFwPWskWiRuKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNSPW4nWFUnXSFlJWkqWlIycy1gJVNkT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXSxwLHMseC1pLXEuUC5WLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNsNHo2VDZlNmY2aTZ8OHQ5VDlfIXIpXyRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUSxtJm9RMHgrZ1EzYC5nUTdZM2RSOWU3WyFiJFRjI1klcShTKFkodCh5KVopWylgKWcreC14LX0uUy5VLnMudi9iMHAzTzNWM2szezVYNWM2ezdRN2E5XTpvPFchUDxkKV4pcS1aLnwyazJuM3AzeTN6NFA0WDZ1N2I3azdsOGs5WDlnOW05bjtXO2A9diFmJFZjI1klcShTKFkodCh5KVcpWClaKVspYClnK3gteC19LlMuVS5zLnYvYjBwM08zVjNrM3s1WDVjNns3UTdhOV06bzxXIVQ8ZileKXEtWi58MmsybjNwM3YzdzN5M3o0UDRYNnU3YjdrN2w4azlYOWc5bTluO1c7YD12IV4kWmMjWSVxKFMoWSh0KHkpYClnK3gteC19LlMuVS5zLnYvYjBwM08zVjNrM3s1WDVjNns3UTdhOV06bzxXUTRfL2t6PlMpXilxLVoufDJrMm4zcDRQNFg2dTdiN2s3bDhrOVg5ZzltOW47VztgPXZRPlg+WlI+WT5bJ1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUyRvaCRwUjRVL1UnWGdPUFdYWVpoc3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4kcCVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1UvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1Qka2YkcVEkaWZTKWokbCluUil2JHFUJGpmJHFUKWwkbCluJ1hoT1BXWFlaaHN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJHAlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9VL1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNUJG9oJHBRJHJoUil1JHAlXmpPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10rZyxwLHMseC1pLXEuUC5WLmcudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2QzbDR6NlQ2ZTZmNmk2fDdbOHQ5VDlfIXM+USRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TI2dsT1BYWnN0IVohYCFvI1MjZCNvI3skbiVtJmsmbiZvJnImdCZ1JncmeydUJ2IpTylzKmkrXStnLHAscyx4LWkuZy9WL24wXTBsMXIyUzJUMlYyWDJbMl8yYTNkNFQ0ejZUNmU2ZjZpN1s4dDlUIVUlUmkkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WSNmKHcjdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5RK1QlYVEvYypPbzRPPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1oIVUkeWkkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WVEqYyR6VSpsJHwqWipvUStVJWJRMFcqbSNmPXEjdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5uPXI8bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWhRPXc+VFE9eD5VUT15PlZSPXo+VyFVJVJpJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPlkjZih3I3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5ebzRPPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1obm9PWHN0IVojZCVtJnImdCZ1Jncscyx4MlsyX1MqZiR7KllRLVInT1EtUydRUjRpL3klWyVTaSN2JGIkYyRkJHgkeyVPJVElXiVfJWMpeSpSKlQqVipZKmEqZyp3KngrZitpLFMsVi5mL1AvZC9tL3gveS97MGAwYjBpMGowbzFmMWkxcTNjNF40XzRqNG81UTVbNV82UzdXN3Y4UThWOFs4cTliOXA5eTpQOmA6cjtRO1s7ZDtrPGw8bTxvPHA8cTxyPHU8djx3PHg8eTx6PVM9VD1VPVY9WD1ZPV09Xj1fPWA9YT1iPWM9ZD1nPWg+UD5YPlk+XT5eUSxVJl1RMWgsV1E1czFnUjhoNXRWKm4kfCpaKm9VKm4kfCpaKm9UNXoxbzV7UzBQKmkvblE0dzBdVDhTNHo6XVEraiV4UTBWKmxRMU8ra1ExdSxhUTZXMXZROHY2WFE6Yzh3UjteOmQhVSVPaSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZeCpSJHYpZSpTKnUrVi92MGQwZTRSNGc1UjVTNVc3cDhVOlI6eD1wPX0+T1MwYCp0MGEjZjxvI3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5ebjxwPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1oIWQ9Uyh1KWMqWyplLmoubS5xL18vay98MHYxZTNoNFs0aDRsNXI3XTdgN3c3ejhYOFo5dDl8OlM6fTtSO2U7ajt2Plo+W2A9VDN9N2M3ZjdqOWg6dDp3O3lTPV8ubDNpVD1gN2U5ayFVJVFpJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPll8KlQkdillKlUqdCtWL2cvdjBkMGU0UjRnNHw1UjVTNVc3cDhVOlI6eD1wPX0+T1MwYip1MGMjZjxxI3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5ebjxyPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1oIWg9VSh1KWMqWyplLmsubC5xL18vay98MHYxZTNmM2g0WzRoNGw1cjddN143YDd3N3o4WDhaOXQ5fDpTOn07UjtlO2o7dj5aPltkPVYzfTdkN2U3ajloOWk6dDp1Onc7eVM9YS5tM2pUPWI3Zjlscm5PWHN0IVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9RJmYhVVIscCZvcm5PWHN0IVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9SJmYhVVEsWSZeUjFkLFJzbk9Yc3QhViFaI2QlbSZpJnImdCZ1Jncscyx4MlsyX1ExcCxfUzZSMXMxdFU4cDZQNlE2VVM6XzhyOHNTO1k6XjphUTttO1pSO3c7blEmbSFWUixpJmlSNl8xfFI6Zjh5VyZRfCZWJlcsT1IxWit2USZyIVdSLHMmc1IseSZ4VDJdLHgyX1IsfSZ5USx8JnlSMmYsfVEneSF7Ui15J3lTc090USNkWFQlcHMjZFEjT1RSJ3sjT1EjUlVSJ30jUlEpeyR1Ui9gKXtRI1VWUihRI1VRI1hXVShXI1goWC5RUShYI1lSLlEoWVEtXidZUjJyLV5RLnUoeVMzbS51M25SM24udlEtZSdgUjJ2LWVZIXJRJ2AtZTFvNXtSJ2ohclEvUSllUjRTL1FVI19XJWgqWVUoXyNfKGAuUlEoYCNgUi5SKFpRLWEnXVIydC1hdGBPWHN0IVYhWiNkJW0maSZrJnImdCZ1Jncscyx4MlsyX1MjaFolZVUjcmAjaC5bUi5bKGpRKGsjalEuWChnVy5hKGsuWDNYN1JRM1guWVI3UjNZUSluJGxSL1cpblEkcGhSKXQkcFEkYGNVKWEkYC18PGpRLXw8V1I8ailxUS9xKl1XNGMvcTRkN3Q5c1U0ZC9yL3MvdFM3dDRlNGZSOXM3dSRlKlEkdih1KWMpZSpbKmUqdCp1K1ErUitWLmwubS5vLnAucS9fL2cvaS9rL3YvfDBkMGUwdjFlM2YzZzNoM300UjRbNGc0aDRsNHw1TzVSNVM1VzVyN103XjdfN2A3ZTdmN2g3aTdqN3A3dzd6OFU4WDhaOWg5aTlqOXQ5fDpSOlM6dDp1OnY6dzp4On07UjtlO2o7djt5PXA9fT5PPlo+W1EveiplVTRrL3o0bTd4UTRtL3xSN3g0bFMqbyR8KlpSMFkqb3gqUyR2KWUqdCp1K1YvdjBkMGU0UjRnNVI1UzVXN3A4VTpSOng9cD19Pk8hZC5qKHUpYypbKmUubC5tLnEvXy9rL3wwdjFlM2g0WzRoNGw1cjddN2A3dzd6OFg4Wjl0OXw6Uzp9O1I7ZTtqO3Y+Wj5bVS9oKlMuajdjYTdjM303ZTdmN2o5aDp0Onc7eVEwYSp0UTNpLmxVNH0wYTNpOWtSOWs3ZXwqVSR2KWUqdCp1K1YvZy92MGQwZTRSNGc0fDVSNVM1VzdwOFU6Ujp4PXA9fT5PIWguayh1KWMqWyplLmwubS5xL18vay98MHYxZTNmM2g0WzRoNGw1cjddN143YDd3N3o4WDhaOXQ5fDpTOn07UjtlO2o7dj5aPltVL2oqVS5rN2RlN2QzfTdlN2Y3ajloOWk6dDp1Onc7eVEwYyp1UTNqLm1VNVAwYzNqOWxSOWw3ZlEqeiVVUjBnKnpRNV0wdlI4WTVdUStfJWtSMHUrX1E1djFqUzhqNXY6W1I6WzhrUSxbJl9SMW0sW1E1ezFvUjhtNXtRMXssZlM2XTF7OHpSOHo2X1ExVStyVzVoMVU1ajhhOlZRNWoxWFE4YTVpUjpWOGJRK3cmUVIxWyt3UTJfLHhSNm0yX1lyT1hzdCNkUSZ2IVpRK2ElbVEsciZyUSx0JnRRLHUmdVEsdyZ3UTJZLHNTMl0seDJfUjZsMltRJW9wUSZ6IV9RJn0hYVEnUCFiUSdSIWNRJ3EhdVErYCVsUStsJXpRLFEmWFEsaCZtUS1QJnxXLXAnaydzJ3Qnd1EtdydvUTBYKm5RMVArbVExYyxQUzJPLGksbFEyZy1PUTJoLVJRMmktU1EyfS1vVzNQLXItcy12LXhRNWExUVE1bTFfUTVxMWVRNlYxdVE2YTJRUTZrMlpVNnozTzNSM1VRNn0zU1E4XTViUThlNW9ROGc1clE4bDV6UTh1NldROHs2YFM5WzZ7N1BROV43T1E6VzhjUTpiOHZROmc4fFE6bjldUTtVOlhRO106Y1E7YTpvUTtsO1ZSO287XlElenlRJ2QhaVEnbyF1VSttJXslfCV9US1XJ1ZVLWsnZSdmJ2dTLW8nayd1UTBRKmpTMVErbitvUTJvLVlTMnstbC1tUTNTLXRTNHAwUjBVUTViMVJRNnYydVE2eTJ8UTdPM1RVN3s0cjRzNHZROXo3fVI7Tzl7UyR3aT5QUip7JVZVJVVpJVY+UFIwZip5USR2aVModSN2K2lTKWMkYiRjUSllJGRRKlskeFMqZSR7KllRKnQlT1EqdSVRUStRJV5RK1IlX1ErViVjUS5sPG9RLm08cVEubzx1US5wPHdRLnE8eVEvXyl5US9nKlJRL2kqVFEvaypWUS92KmFTL3wqZy9tUTBkKndRMGUqeGwwditmLFYuZjFpMXEzYzZTN1c4cTliOmA6cjtbO2RRMWUsU1EzZj1TUTNnPVVRM2g9WFMzfTxsPG1RNFIvUFM0Wy9kNF5RNGcveFE0aC95UTRsL3tRNHwwYFE1TzBiUTVSMGlRNVMwalE1VzBvUTVyMWZRN109XVE3Xj1fUTdfPWFRN2A9Y1E3ZTxwUTdmPHJRN2g8dlE3aTx4UTdqPHpRN3A0X1E3dzRqUTd6NG9ROFU1UVE4WDVbUThaNV9ROWg9WVE5aT1UUTlqPVZROXQ3dlE5fDhRUTpSOFZROlM4W1E6dD1eUTp1PWBROnY9YlE6dz1kUTp4OXBROn05eVE7UjpQUTtlPWdRO2o7UVE7djtrUTt5PWhRPXA+UFE9fT5YUT5PPllRPlo+XVI+Wz5eUStPJV1RLm48c1I3Zzx0bnBPWHN0IVojZCVtJnImdCZ1Jncscyx4MlsyX1EhZlBTI2ZaI29RJnwhYFcnaCFvKmkwXTR6UShQI1NRKVEje1EpciRuUyxsJmsmblEscSZvUS1PJntTLVQnVC9uUS1nJ2JRLngpT1EvWylzUTBzK11RMHkrZ1EyVyxwUTJ5LWlRM2EuZ1E0Vy9WUTVVMGxRNlExclE2YzJTUTZkMlRRNmgyVlE2ajJYUTZvMmFRN1ozZFE3bTRUUThzNlRROVA2ZVE5UTZmUTlTNmlROWY3W1E6YTh0UjprOVQjW2NPUFhac3QhWiFgIW8jZCNvI3slbSZrJm4mbyZyJnQmdSZ3JnsnVCdiKU8qaStdK2cscCxzLHgtaS5nL24wXTBsMXIyUzJUMlYyWDJbMl8yYTNkNHo2VDZlNmY2aTdbOHQ5VFEjWVdRI2VZUSVxdVElc3ZTJXV3IWdTKFMjVyhWUShZI1pRKHQjdVEoeSN4USlSJE9RKVMkUFEpVCRRUSlVJFJRKVYkU1EpVyRUUSlYJFVRKVkkVlEpWiRXUSlbJFhRKV4kWlEpYCRfUSliJGFRKWckZVcpcSRuKXMvVjRUUStkJXRRK3gmUlMtWidYMnBRLXgnclMtfShULlBRLlMoXVEuVShkUS5zKHhRLnYoelEuejxVUS58PFhRLn08WVEvTzxdUS9iKX1RMHArWFEyay1VUTJuLVhRM08tcVEzVi5WUTNrLnRRM3A8XlEzcTxfUTNyPGBRM3M8YVEzdDxiUTN1PGNRM3Y8ZFEzdzxlUTN4PGZRM3k8Z1EzejxoUTN7LntRM3w8a1E0UDxuUTRRPHtRNFg8aVE1WDByUTVjMVNRNnU9T1E2ezNRUTdRM1dRN2EzbFE3Yj1QUTdrPVJRN2w9WlE4azV3UTlYNnNROV02fFE5Zz1bUTltPWVROW49ZlE6bzlfUTtXOlpRO2A6bVE8VyNTUj12PlNSI1tXUidaIWVsIXRRIXIhdiF5IXonYCdsJ20nbi1lLXUxbzV7NX1TJ1YhZS1dVSpqJHwqWipvUy1ZJ1cnX1MwVSprKnFRMF4qclEydS1jUTR2MFtSNHswX1IoeyN4USFmUVQtZCdgLWVdIXFRIXInYC1lMW81e1EjcF1SJ2k8VlIpZiRkWSF1USdgLWUxbzV7USdrIXJTJ3UhdiF5Uyd3IXo1fVMtdCdsJ21RLXYnblIzVC11VCNrWiVlUyNqWiVlUyVrbSxvVShnI2gjaSNsUy5ZKGgoaVEuXihqUTB0K15RM1kuWlUzWi5bLl0uX1M3UzNbM11SOWA3VGQjXlcjVyNaJWgoVCheKlkrWi5UL21yI2dabSNoI2kjbCVlKGgoaShqK14uWi5bLl0uXzNbM103VFMqXSR4KmJRL3QqXlEyVSxvUTJsLVZRNGAvcFE2cTJkUTdzNGFROVc2clQ9bSdYK1tWI2FXJWgqWVUjYFclaCpZUyhVI1coXlUoWiNaK1ovbVMtWydYK1tULk8oVC5UVideIWUlaSpaUSRsZlIpeCRxVCltJGwpblI0Vi9VVCpfJHgqYlQqaCR7KllRMHcrZlExZyxWUTNfLmZRNXQxaVE2UDFxUTdYM2NROHI2U1E5YzdXUTpeOHFROnA5YlE7WjpgUTtjOnJRO247W1I7cTtkbnFPWHN0IVojZCVtJnImdCZ1Jncscyx4MlsyX1EmbCFWUixoJml0bU9Yc3QhVSFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUixvJm9UJWxtLG9SMWssWFIsZyZnUSZVfFMrfSZWJldSMV4sT1IrcyZQVCZwIVcmc1QmcSFXJnNUMl4seDJfXCIsXG4gIG5vZGVOYW1lczogXCLimqAgQXJpdGhPcCBBcml0aE9wID8uIEpTWFN0YXJ0VGFnIExpbmVDb21tZW50IEJsb2NrQ29tbWVudCBTY3JpcHQgSGFzaGJhbmcgRXhwb3J0RGVjbGFyYXRpb24gZXhwb3J0IFN0YXIgYXMgVmFyaWFibGVOYW1lIFN0cmluZyBFc2NhcGUgZnJvbSA7IGRlZmF1bHQgRnVuY3Rpb25EZWNsYXJhdGlvbiBhc3luYyBmdW5jdGlvbiBWYXJpYWJsZURlZmluaXRpb24gPiA8IFR5cGVQYXJhbUxpc3QgaW4gb3V0IGNvbnN0IFR5cGVEZWZpbml0aW9uIGV4dGVuZHMgVGhpc1R5cGUgdGhpcyBMaXRlcmFsVHlwZSBBcml0aE9wIE51bWJlciBCb29sZWFuTGl0ZXJhbCBUZW1wbGF0ZVR5cGUgSW50ZXJwb2xhdGlvbkVuZCBJbnRlcnBvbGF0aW9uIEludGVycG9sYXRpb25TdGFydCBOdWxsVHlwZSBudWxsIFZvaWRUeXBlIHZvaWQgVHlwZW9mVHlwZSB0eXBlb2YgTWVtYmVyRXhwcmVzc2lvbiAuIFByb3BlcnR5TmFtZSBbIFRlbXBsYXRlU3RyaW5nIEVzY2FwZSBJbnRlcnBvbGF0aW9uIHN1cGVyIFJlZ0V4cCBdIEFycmF5RXhwcmVzc2lvbiBTcHJlYWQgLCB9IHsgT2JqZWN0RXhwcmVzc2lvbiBQcm9wZXJ0eSBhc3luYyBnZXQgc2V0IFByb3BlcnR5RGVmaW5pdGlvbiBCbG9jayA6IE5ld1RhcmdldCBuZXcgTmV3RXhwcmVzc2lvbiApICggQXJnTGlzdCBVbmFyeUV4cHJlc3Npb24gZGVsZXRlIExvZ2ljT3AgQml0T3AgWWllbGRFeHByZXNzaW9uIHlpZWxkIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBDbGFzc0V4cHJlc3Npb24gY2xhc3MgQ2xhc3NCb2R5IE1ldGhvZERlY2xhcmF0aW9uIERlY29yYXRvciBAIE1lbWJlckV4cHJlc3Npb24gUHJpdmF0ZVByb3BlcnR5TmFtZSBDYWxsRXhwcmVzc2lvbiBUeXBlQXJnTGlzdCBDb21wYXJlT3AgPCBkZWNsYXJlIFByaXZhY3kgc3RhdGljIGFic3RyYWN0IG92ZXJyaWRlIFByaXZhdGVQcm9wZXJ0eURlZmluaXRpb24gUHJvcGVydHlEZWNsYXJhdGlvbiByZWFkb25seSBhY2Nlc3NvciBPcHRpb25hbCBUeXBlQW5ub3RhdGlvbiBFcXVhbHMgU3RhdGljQmxvY2sgRnVuY3Rpb25FeHByZXNzaW9uIEFycm93RnVuY3Rpb24gUGFyYW1MaXN0IFBhcmFtTGlzdCBBcnJheVBhdHRlcm4gT2JqZWN0UGF0dGVybiBQYXR0ZXJuUHJvcGVydHkgUHJpdmFjeSByZWFkb25seSBBcnJvdyBNZW1iZXJFeHByZXNzaW9uIEJpbmFyeUV4cHJlc3Npb24gQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQXJpdGhPcCBCaXRPcCBDb21wYXJlT3AgaW5zdGFuY2VvZiBzYXRpc2ZpZXMgQ29tcGFyZU9wIEJpdE9wIEJpdE9wIEJpdE9wIExvZ2ljT3AgTG9naWNPcCBDb25kaXRpb25hbEV4cHJlc3Npb24gTG9naWNPcCBMb2dpY09wIEFzc2lnbm1lbnRFeHByZXNzaW9uIFVwZGF0ZU9wIFBvc3RmaXhFeHByZXNzaW9uIENhbGxFeHByZXNzaW9uIEluc3RhbnRpYXRpb25FeHByZXNzaW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiBEeW5hbWljSW1wb3J0IGltcG9ydCBJbXBvcnRNZXRhIEpTWEVsZW1lbnQgSlNYU2VsZkNsb3NlRW5kVGFnIEpTWFNlbGZDbG9zaW5nVGFnIEpTWElkZW50aWZpZXIgSlNYQnVpbHRpbiBKU1hJZGVudGlmaWVyIEpTWE5hbWVzcGFjZWROYW1lIEpTWE1lbWJlckV4cHJlc3Npb24gSlNYU3ByZWFkQXR0cmlidXRlIEpTWEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGVWYWx1ZSBKU1hFc2NhcGUgSlNYRW5kVGFnIEpTWE9wZW5UYWcgSlNYRnJhZ21lbnRUYWcgSlNYVGV4dCBKU1hFc2NhcGUgSlNYU3RhcnRDbG9zZVRhZyBKU1hDbG9zZVRhZyBQcmVmaXhDYXN0IDwgQXJyb3dGdW5jdGlvbiBUeXBlUGFyYW1MaXN0IFNlcXVlbmNlRXhwcmVzc2lvbiBJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiBLZXlvZlR5cGUga2V5b2YgVW5pcXVlVHlwZSB1bmlxdWUgSW1wb3J0VHlwZSBJbmZlcnJlZFR5cGUgaW5mZXIgVHlwZU5hbWUgUGFyZW50aGVzaXplZFR5cGUgRnVuY3Rpb25TaWduYXR1cmUgUGFyYW1MaXN0IE5ld1NpZ25hdHVyZSBJbmRleGVkVHlwZSBUdXBsZVR5cGUgTGFiZWwgQXJyYXlUeXBlIFJlYWRvbmx5VHlwZSBPYmplY3RUeXBlIE1ldGhvZFR5cGUgUHJvcGVydHlUeXBlIEluZGV4U2lnbmF0dXJlIFByb3BlcnR5RGVmaW5pdGlvbiBDYWxsU2lnbmF0dXJlIFR5cGVQcmVkaWNhdGUgYXNzZXJ0cyBpcyBOZXdTaWduYXR1cmUgbmV3IFVuaW9uVHlwZSBMb2dpY09wIEludGVyc2VjdGlvblR5cGUgTG9naWNPcCBDb25kaXRpb25hbFR5cGUgUGFyYW1ldGVyaXplZFR5cGUgQ2xhc3NEZWNsYXJhdGlvbiBhYnN0cmFjdCBpbXBsZW1lbnRzIHR5cGUgVmFyaWFibGVEZWNsYXJhdGlvbiBsZXQgdmFyIHVzaW5nIFR5cGVBbGlhc0RlY2xhcmF0aW9uIEludGVyZmFjZURlY2xhcmF0aW9uIGludGVyZmFjZSBFbnVtRGVjbGFyYXRpb24gZW51bSBFbnVtQm9keSBOYW1lc3BhY2VEZWNsYXJhdGlvbiBuYW1lc3BhY2UgbW9kdWxlIEFtYmllbnREZWNsYXJhdGlvbiBkZWNsYXJlIEdsb2JhbERlY2xhcmF0aW9uIGdsb2JhbCBDbGFzc0RlY2xhcmF0aW9uIENsYXNzQm9keSBBbWJpZW50RnVuY3Rpb25EZWNsYXJhdGlvbiBFeHBvcnRHcm91cCBWYXJpYWJsZU5hbWUgVmFyaWFibGVOYW1lIEltcG9ydERlY2xhcmF0aW9uIGRlZmVyIEltcG9ydEdyb3VwIEZvclN0YXRlbWVudCBmb3IgRm9yU3BlYyBGb3JJblNwZWMgRm9yT2ZTcGVjIG9mIFdoaWxlU3RhdGVtZW50IHdoaWxlIFdpdGhTdGF0ZW1lbnQgd2l0aCBEb1N0YXRlbWVudCBkbyBJZlN0YXRlbWVudCBpZiBlbHNlIFN3aXRjaFN0YXRlbWVudCBzd2l0Y2ggU3dpdGNoQm9keSBDYXNlTGFiZWwgY2FzZSBEZWZhdWx0TGFiZWwgVHJ5U3RhdGVtZW50IHRyeSBDYXRjaENsYXVzZSBjYXRjaCBGaW5hbGx5Q2xhdXNlIGZpbmFsbHkgUmV0dXJuU3RhdGVtZW50IHJldHVybiBUaHJvd1N0YXRlbWVudCB0aHJvdyBCcmVha1N0YXRlbWVudCBicmVhayBDb250aW51ZVN0YXRlbWVudCBjb250aW51ZSBEZWJ1Z2dlclN0YXRlbWVudCBkZWJ1Z2dlciBMYWJlbGVkU3RhdGVtZW50IEV4cHJlc3Npb25TdGF0ZW1lbnQgU2luZ2xlRXhwcmVzc2lvbiBTaW5nbGVDbGFzc0l0ZW1cIixcbiAgbWF4VGVybTogMzgwLFxuICBjb250ZXh0OiB0cmFja05ld2xpbmUsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImlzb2xhdGVcIiwgLTgsNSw2LDE0LDM3LDM5LDUxLDUzLDU1LFwiXCJdLFxuICAgIFtcImdyb3VwXCIsIC0yNiw5LDE3LDE5LDY4LDIwNywyMTEsMjE1LDIxNiwyMTgsMjIxLDIyNCwyMzQsMjM3LDI0MywyNDUsMjQ3LDI0OSwyNTIsMjU4LDI2NCwyNjYsMjY4LDI3MCwyNzIsMjc0LDI3NSxcIlN0YXRlbWVudFwiLC0zNCwxMywxNCwzMiwzNSwzNiw0Miw1MSw1NCw1NSw1Nyw2Miw3MCw3Miw3Niw4MCw4Miw4NCw4NSwxMTAsMTExLDEyMCwxMjEsMTM2LDEzOSwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NywxNDgsMTY3LDE2OSwxNzEsXCJFeHByZXNzaW9uXCIsLTIzLDMxLDMzLDM3LDQxLDQzLDQ1LDE3MywxNzUsMTc3LDE3OCwxODAsMTgxLDE4MiwxODQsMTg1LDE4NiwxODgsMTg5LDE5MCwyMDEsMjAzLDIwNSwyMDYsXCJUeXBlXCIsLTMsODgsMTAzLDEwOSxcIkNsYXNzSXRlbVwiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCAyMyxcIjxcIiwzOCxcIkludGVycG9sYXRpb25TdGFydFwiLDU2LFwiW1wiLDYwLFwie1wiLDczLFwiKFwiLDE2MCxcIkpTWFN0YXJ0Q2xvc2VUYWdcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgLTIsMjQsMTY4LFwiPlwiLDQwLFwiSW50ZXJwb2xhdGlvbkVuZFwiLDUwLFwiXVwiLDYxLFwifVwiLDc0LFwiKVwiLDE2NSxcIkpTWEVuZFRhZ1wiXVxuICBdLFxuICBwcm9wU291cmNlczogW2pzSGlnaGxpZ2h0XSxcbiAgc2tpcHBlZE5vZGVzOiBbMCw1LDYsMjc4XSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAzNyxcbiAgdG9rZW5EYXRhOiBcIiRGcTA3W1IhYk9YJVpYWStnWVoteVpbK2dbXSVaXV4uY15wJVpwcStncXIvbXJzM2NzdDpfdHVFcnV2SlN2d0xrd3ghIFl4eSEnaXl6IShzenshKX17fCEscXx9IS5PfSFPISxxIU8hUCEvWSFQIVEhOWohUSFSIzpPIVIhWyM8XyFbIV0jSV8hXSFeI0prIV4hXyNLdSFfIWAkIVshYCFhJCR2IWEhYiQqVCFiIWMkLHIhYyF9RXIhfSNPJC18I08jUCQvVyNQI1EkNG8jUSNSJDV5I1IjU0VyI1MjVCQ3VyNUI28kOGIjbyNwJDxyI3AjcSQ9aCNxI3IkPngjciNzJEBVI3MkZiVaJGYkZytnJGcjQllFciNCWSNCWiRBYCNCWiRJU0VyJElTJElfJEFgJElfJEl8RXIkSXwkSX0kRGskSX0kSk8kRGskSk8kSlRFciRKVCRKVSRBYCRKVSRLVkVyJEtWJEtXJEFgJEtXJkZVRXImRlUmRlYkQWAmRlY7J1NFcjsnUzs9YEl8PCVsP0hURXI/SFQ/SFUkQWA/SFVPRXIobiVkXyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomaiZoVCRpJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyZqJnpQOz1gPCVsJmMnfCdVXSRpJmooWiFiT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9IWIoU1UoWiFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFiKGlQOz1gPCVsJ30nfChvUDs9YDwlbCZ9J1soeV0kaSZqKFdwT1kocllaJmNacihycnMmY3MhXihyIV4hXylyIV8jTyhyI08jUCZjI1AjbyhyI28jcClyI3A7J1MocjsnUzs9YCphPCVsTyhycCl3VShXcE9ZKXJacilycyNPKXIjUDsnUylyOydTOz1gKlo8JWxPKXJwKl5QOz1gPCVsKXInWypkUDs9YDwlbChyI1MqblgoV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyNTK15QOz1gPCVsKmcobitkUDs9YDwlbCVaMDdbK3JxJGkmaihXcChaIWInfDAvbE9YJVpYWStnWVomY1pbK2dbcCVacHErZ3FyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwJGYlWiRmJGcrZyRnI0JZJVojQlkjQlorZyNCWiRJUyVaJElTJElfK2ckSV8kSlQlWiRKVCRKVStnJEpVJEtWJVokS1YkS1crZyRLVyZGVSVaJkZVJkZWK2cmRlY7J1MlWjsnUzs9YCthPCVsP0hUJVo/SFQ/SFUrZz9IVU8lWjA3Wy5TVChYI1MkaSZqJ30wL2xPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYzA3Wy5uXyRpJmooV3AoWiFiJ30wL2xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWikzcC94YCRpJmohcCksUShXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVzFWYCN2KENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAyWCFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVzJkXyN2KENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBdDNsXyhWJzpmJGkmaihaIWJPWTRrWVo1cVpyNGtyczduc3c0a3d4NXF4IV40ayFeIV84cCFfI080ayNPI1A1cSNQI280ayNvI3A4cCNwOydTNGs7J1M7PWA6WDwlbE80ayheNHJfJGkmaihaIWJPWTRrWVo1cVpyNGtyczduc3c0a3d4NXF4IV40ayFeIV84cCFfI080ayNPI1A1cSNQI280ayNvI3A4cCNwOydTNGs7J1M7PWA6WDwlbE80ayZ6NXZYJGkmak9yNXFyczZjcyFeNXEhXiFfNnkhXyNvNXEjbyNwNnkjcDsnUzVxOydTOz1gN2g8JWxPNXEmejZqVCRkYCRpJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mY2A2fFRPcjZ5cnM3XXM7J1M2eTsnUzs9YDdiPCVsTzZ5YDdiTyRkYGA3ZVA7PWA8JWw2eSZ6N2tQOz1gPCVsNXEoXjd3XSRkYCRpJmooWiFiT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9IXI4dVooWiFiT1k4cFlaNnlacjhwcnM5aHN3OHB3eDZ5eCNPOHAjTyNQNnkjUDsnUzhwOydTOz1gOlI8JWxPOHAhcjlvVSRkYChaIWJPWSd9WncnfXgjTyd9I1A7J1MnfTsnUzs9YChmPCVsTyd9IXI6VVA7PWA8JWw4cCheOltQOz1gPCVsNGslOVs6aGgkaSZqKFdwKFohYk9ZJVpZWiZjWnElWnFyPFNycyZ9c3QlWnR1Q3J1dyVad3gocnghXiVaIV4hXypnIV8hYyVaIWMhfUNyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0NyI1MjVCVaI1Qjb0NyI28jcCpnI3AkZyVaJGc7J1NDcjsnUzs9YEVsPCVsT0NyKHI8X19XUyRpJmooV3AoWiFiT1k8U1laJmNacjxTcnM9XnN3PFN3eEBueCFePFMhXiFfQm0hXyNPPFMjTyNQPmAjUCNvPFMjbyNwQm0jcDsnUzxTOydTOz1gQ2w8JWxPPFMoUT1nXVdTJGkmaihaIWJPWT1eWVomY1p3PV53eD5geCFePV4hXiFfP3EhXyNPPV4jTyNQPmAjUCNvPV4jbyNwP3EjcDsnUz1eOydTOz1gQGg8JWxPPV4mbj5nWFdTJGkmak9ZPmBZWiZjWiFePmAhXiFfP1MhXyNvPmAjbyNwP1MjcDsnUz5gOydTOz1gP2s8JWxPPmBTP1hTV1NPWT9TWjsnUz9TOydTOz1gP2U8JWxPP1NTP2hQOz1gPCVsP1Mmbj9uUDs9YDwlbD5gIWY/eFdXUyhaIWJPWT9xWnc/cXd4P1N4I08/cSNPI1A/UyNQOydTP3E7J1M7PWBAYjwlbE8/cSFmQGVQOz1gPCVsP3EoUUBrUDs9YDwlbD1eJ2BAd11XUyRpJmooV3BPWUBuWVomY1pyQG5ycz5gcyFeQG4hXiFfQXAhXyNPQG4jTyNQPmAjUCNvQG4jbyNwQXAjcDsnU0BuOydTOz1gQmc8JWxPQG50QXdXV1MoV3BPWUFwWnJBcHJzP1NzI09BcCNPI1A/UyNQOydTQXA7J1M7PWBCYTwlbE9BcHRCZFA7PWA8JWxBcCdgQmpQOz1gPCVsQG4jV0J2WVdTKFdwKFohYk9ZQm1ackJtcnM/cXN3Qm13eEFweCNPQm0jTyNQP1MjUDsnU0JtOydTOz1gQ2Y8JWxPQm0jV0NpUDs9YDwlbEJtKHJDb1A7PWA8JWw8UyU5W0N9aSRpJmoobyUxbChXcChaIWJPWSVaWVomY1pyJVpycyZ9c3QlWnR1Q3J1dyVad3gocnghUSVaIVEhW0NyIVshXiVaIV4hXypnIV8hYyVaIWMhfUNyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0NyI1MjVCVaI1Qjb0NyI28jcCpnI3AkZyVaJGc7J1NDcjsnUzs9YEVsPCVsT0NyJTlbRW9QOz1gPCVsQ3IwN1tGUmskaSZqKFdwKFohYiRdI3QoVCwyaihlJElbT1klWllaJmNaciVacnMmfXN0JVp0dUVydXclWnd4KHJ4fSVafSFPR3YhTyFRJVohUSFbRXIhWyFeJVohXiFfKmchXyFjJVohYyF9RXIhfSNPJVojTyNQJmMjUCNSJVojUiNTRXIjUyNUJVojVCNvRXIjbyNwKmcjcCRnJVokZzsnU0VyOydTOz1gSXw8JWxPRXIrZEhSayRpJmooV3AoWiFiJF0jdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHVHdnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0d2IVshXiVaIV4hXypnIV8hYyVaIWMhfUd2IX0jTyVaI08jUCZjI1AjUiVaI1IjU0d2I1MjVCVaI1Qjb0d2I28jcCpnI3AkZyVaJGc7J1NHdjsnUzs9YEl2PCVsT0d2K2RJeVA7PWA8JWxHdjA3W0pQUDs9YDwlbEVyKEtXSl9gJGkmaihXcChaIWIjcChDaE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXS2xfJGkmaiRRKENoKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaLCN4THZhKHorSlkkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdiVadndNe3d4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLV05XYCRpJmojeihDaChXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBdCEgY18oWSc7VyRpJmooV3BPWSEhYllaISNoWnIhIWJycyEjaHN3ISFid3ghJHh4IV4hIWIhXiFfISV6IV8jTyEhYiNPI1AhI2gjUCNvISFiI28jcCEleiNwOydTISFiOydTOz1gISdjPCVsTyEhYidsISFpXyRpJmooV3BPWSEhYllaISNoWnIhIWJycyEjaHN3ISFid3ghJHh4IV4hIWIhXiFfISV6IV8jTyEhYiNPI1AhI2gjUCNvISFiI28jcCEleiNwOydTISFiOydTOz1gISdjPCVsTyEhYiZ6ISNtWCRpJmpPdyEjaHd4NmN4IV4hI2ghXiFfISRZIV8jbyEjaCNvI3AhJFkjcDsnUyEjaDsnUzs9YCEkcjwlbE8hI2hgISRdVE93ISRZd3g3XXg7J1MhJFk7J1M7PWAhJGw8JWxPISRZYCEkb1A7PWA8JWwhJFkmeiEkdVA7PWA8JWwhI2gnbCElUl0kZGAkaSZqKFdwT1kocllaJmNacihycnMmY3MhXihyIV4hXylyIV8jTyhyI08jUCZjI1AjbyhyI28jcClyI3A7J1MocjsnUzs9YCphPCVsTyhyIVEhJlBaKFdwT1khJXpZWiEkWVpyISV6cnMhJFlzdyElend4ISZyeCNPISV6I08jUCEkWSNQOydTISV6OydTOz1gISddPCVsTyEleiFRISZ5VSRkYChXcE9ZKXJacilycyNPKXIjUDsnUylyOydTOz1gKlo8JWxPKXIhUSEnYFA7PWA8JWwhJXonbCEnZlA7PWA8JWwhIWIvNXwhJ3RfIWwvLl4kaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyZVISlPXyFrIUxmJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWi0hbiEqW2IkaSZqKFdwKFohYihVJSZmI3EoQ2hPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4eiVaenshK2R7IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyErb2AkaSZqKFdwKFohYiNuKENoT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVorO3ghLHxgJGkmaihXcChaIWJyKzRZT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVosJFUhLlpfIV0rSmYkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbIS9lYyRpJmooV3AoWiFiIVEuMl5PWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhMHAhUCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyV8ITB5YSRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFPJVohTyFQITJPIVAhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyV8ITJaXyFbIUxeJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCEzZWckaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshM1khWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyEzWSNTI1glWiNYI1khNHwjWSNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhNVZnJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4eyVae3whNm58fSVafSFPITZuIU8hUSVaIVEhWyE4UyFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MhOFMjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhNndjJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkIThfYyRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyE4UyFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MhOFMjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1shOXVmJGkmaihXcChaIWIjbyhDaE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeHohO1p6eyMtfXshUCE7WiFQIVEjL2QhUSFeITtaIV4hXyMoaSFfIWAjN1MhYCFhIzhpIWEhfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1o/TyE7ZmIkaSZqKFdwKFohYiFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaPl4hPHdgJGkmaihaIWIhWDdgT1khPG5ZWiZjWnchPG53eCE9eXghUCE8biFQIVEhRXEhUSFeITxuIV4hXyFHciFfIX0hPG4hfSNPIUtTI08jUCFEeSNQI28hPG4jbyNwIUdyI3A7J1MhPG47J1M7PWAhTF08JWxPITxuPHohPlFeJGkmaiFYN2BPWSE9eVlaJmNaIVAhPXkhUCFRIT58IVEhXiE9eSFeIV8hQGMhXyF9IT15IX0jTyFDVyNPI1AhRHkjUCNvIT15I28jcCFAYyNwOydTIT15OydTOz1gIUVrPCVsTyE9eTx6IT9UZCRpJmohWDdgTyFeJmMhXyNXJmMjVyNYIT58I1gjWiZjI1ojWyE+fCNbI10mYyNdI14hPnwjXiNhJmMjYSNiIT58I2IjZyZjI2cjaCE+fCNoI2kmYyNpI2ohPnwjaiNrIT58I2sjbSZjI20jbiE+fCNuI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYzdgIUBoWCFYN2BPWSFAY1ohUCFAYyFQIVEhQVQhUSF9IUBjIX0jTyFBciNPI1AhQnEjUDsnUyFAYzsnUzs9YCFDUTwlbE8hQGM3YCFBWVchWDdgI1cjWCFBVCNaI1shQVQjXSNeIUFUI2EjYiFBVCNnI2ghQVQjaSNqIUFUI2ojayFBVCNtI24hQVQ3YCFBdVZPWSFBclojTyFBciNPI1AhQlsjUCNRIUBjI1E7J1MhQXI7J1M7PWAhQms8JWxPIUFyN2AhQl9TT1khQXJaOydTIUFyOydTOz1gIUJrPCVsTyFBcjdgIUJuUDs9YDwlbCFBcjdgIUJ0U09ZIUBjWjsnUyFAYzsnUzs9YCFDUTwlbE8hQGM3YCFDVFA7PWA8JWwhQGM8eiFDXVskaSZqT1khQ1dZWiZjWiFeIUNXIV4hXyFBciFfI08hQ1cjTyNQIURSI1AjUSE9eSNRI28hQ1cjbyNwIUFyI3A7J1MhQ1c7J1M7PWAhRHM8JWxPIUNXPHohRFdYJGkmak9ZIUNXWVomY1ohXiFDVyFeIV8hQXIhXyNvIUNXI28jcCFBciNwOydTIUNXOydTOz1gIURzPCVsTyFDVzx6IUR2UDs9YDwlbCFDVzx6IUVPWCRpJmpPWSE9eVlaJmNaIV4hPXkhXiFfIUBjIV8jbyE9eSNvI3AhQGMjcDsnUyE9eTsnUzs9YCFFazwlbE8hPXk8eiFFblA7PWA8JWwhPXk+XiFFemwkaSZqKFohYiFYN2BPWSZ9WVomY1p3Jn13eCZjeCFeJn0hXiFfJ30hXyNPJn0jTyNQJmMjUCNXJn0jVyNYIUVxI1gjWiZ9I1ojWyFFcSNbI10mfSNdI14hRXEjXiNhJn0jYSNiIUVxI2IjZyZ9I2cjaCFFcSNoI2kmfSNpI2ohRXEjaiNrIUVxI2sjbSZ9I20jbiFFcSNuI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfThyIUd5WihaIWIhWDdgT1khR3JadyFHcnd4IUBjeCFQIUdyIVAhUSFIbCFRIX0hR3IhfSNPIUpVI08jUCFCcSNQOydTIUdyOydTOz1gIUp8PCVsTyFHcjhyIUhzZShaIWIhWDdgT1knfVp3J314I08nfSNQI1cnfSNXI1ghSGwjWCNaJ30jWiNbIUhsI1sjXSd9I10jXiFIbCNeI2EnfSNhI2IhSGwjYiNnJ30jZyNoIUhsI2gjaSd9I2kjaiFIbCNqI2shSGwjayNtJ30jbSNuIUhsI247J1MnfTsnUzs9YChmPCVsTyd9OHIhSlpYKFohYk9ZIUpVWnchSlV3eCFBcngjTyFKVSNPI1AhQlsjUCNRIUdyI1E7J1MhSlU7J1M7PWAhSnY8JWxPIUpVOHIhSnlQOz1gPCVsIUpVOHIhS1BQOz1gPCVsIUdyPl4hS1peJGkmaihaIWJPWSFLU1laJmNadyFLU3d4IUNXeCFeIUtTIV4hXyFKVSFfI08hS1MjTyNQIURSI1AjUSE8biNRI28hS1MjbyNwIUpVI3A7J1MhS1M7J1M7PWAhTFY8JWxPIUtTPl4hTFlQOz1gPCVsIUtTPl4hTGBQOz1gPCVsITxuPWwhTGxgJGkmaihXcCFYN2BPWSFMY1laJmNaciFMY3JzIT15cyFQIUxjIVAhUSFNbiFRIV4hTGMhXiFfIyBvIV8hfSFMYyF9I08jJVAjTyNQIUR5I1AjbyFMYyNvI3AjIG8jcDsnUyFMYzsnUzs9YCMmWTwlbE8hTGM9bCFNd2wkaSZqKFdwIVg3YE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI1cociNXI1ghTW4jWCNaKHIjWiNbIU1uI1sjXShyI10jXiFNbiNeI2EociNhI2IhTW4jYiNnKHIjZyNoIU1uI2gjaShyI2kjaiFNbiNqI2shTW4jayNtKHIjbSNuIU1uI24jbyhyI28jcClyI3A7J1MocjsnUzs9YCphPCVsTyhyOFEjIHZaKFdwIVg3YE9ZIyBvWnIjIG9ycyFAY3MhUCMgbyFQIVEjIWkhUSF9IyBvIX0jTyMkUiNPI1AhQnEjUDsnUyMgbzsnUzs9YCMkeTwlbE8jIG84USMhcGUoV3AhWDdgT1kpclpyKXJzI08pciNQI1cpciNXI1gjIWkjWCNaKXIjWiNbIyFpI1sjXSlyI10jXiMhaSNeI2EpciNhI2IjIWkjYiNnKXIjZyNoIyFpI2gjaSlyI2kjaiMhaSNqI2sjIWkjayNtKXIjbSNuIyFpI247J1MpcjsnUzs9YCpaPCVsTylyOFEjJFdYKFdwT1kjJFJaciMkUnJzIUFycyNPIyRSI08jUCFCWyNQI1EjIG8jUTsnUyMkUjsnUzs9YCMkczwlbE8jJFI4USMkdlA7PWA8JWwjJFI4USMkfFA7PWA8JWwjIG89bCMlV14kaSZqKFdwT1kjJVBZWiZjWnIjJVBycyFDV3MhXiMlUCFeIV8jJFIhXyNPIyVQI08jUCFEUiNQI1EhTGMjUSNvIyVQI28jcCMkUiNwOydTIyVQOydTOz1gIyZTPCVsTyMlUD1sIyZWUDs9YDwlbCMlUD1sIyZdUDs9YDwlbCFMYz9PIyZrbiRpJmooV3AoWiFiIVg3YE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjVyVaI1cjWCMmYCNYI1olWiNaI1sjJmAjWyNdJVojXSNeIyZgI14jYSVaI2EjYiMmYCNiI2clWiNnI2gjJmAjaCNpJVojaSNqIyZgI2ojayMmYCNrI20lWiNtI24jJmAjbiNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVo5ZCMocl0oV3AoWiFiIVg3YE9ZIyhpWnIjKGlycyFHcnN3Iyhpd3gjIG94IVAjKGkhUCFRIylrIVEhfSMoaSF9I08jK2AjTyNQIUJxI1A7J1MjKGk7J1M7PWAjLGA8JWxPIyhpOWQjKXRoKFdwKFohYiFYN2BPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1AjVypnI1cjWCMpayNYI1oqZyNaI1sjKWsjWyNdKmcjXSNeIylrI14jYSpnI2EjYiMpayNiI2cqZyNnI2gjKWsjaCNpKmcjaSNqIylrI2ojayMpayNrI20qZyNtI24jKWsjbjsnUypnOydTOz1gK1o8JWxPKmc5ZCMrZ1ooV3AoWiFiT1kjK2BaciMrYHJzIUpVc3cjK2B3eCMkUngjTyMrYCNPI1AhQlsjUCNRIyhpI1E7J1MjK2A7J1M7PWAjLFk8JWxPIytgOWQjLF1QOz1gPCVsIytgOWQjLGNQOz1gPCVsIyhpP08jLG9gJGkmaihXcChaIWJPWSMsZllaJmNaciMsZnJzIUtTc3cjLGZ3eCMlUHghXiMsZiFeIV8jK2AhXyNPIyxmI08jUCFEUiNQI1EhO1ojUSNvIyxmI28jcCMrYCNwOydTIyxmOydTOz1gIy1xPCVsTyMsZj9PIy10UDs9YDwlbCMsZj9PIy16UDs9YDwlbCE7WjA3WyMuW2IkaSZqKFdwKFohYihPMC9sIVg3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1owN1sjL29fJGkmaihXcChaIWJUMC9sT1kjL2RZWiZjWnIjL2RycyMwbnN3Iy9kd3gjNE94IV4jL2QhXiFfIzV9IV8jTyMvZCNPI1AjMXAjUCNvIy9kI28jcCM1fSNwOydTIy9kOydTOz1gIzZ8PCVsTyMvZDA2aiMwd10kaSZqKFohYlQwL2xPWSMwbllaJmNadyMwbnd4IzFweCFeIzBuIV4hXyMzUiFfI08jMG4jTyNQIzFwI1AjbyMwbiNvI3AjM1IjcDsnUyMwbjsnUzs9YCMzeDwlbE8jMG4wNVcjMXdYJGkmalQwL2xPWSMxcFlaJmNaIV4jMXAhXiFfIzJkIV8jbyMxcCNvI3AjMmQjcDsnUyMxcDsnUzs9YCMyezwlbE8jMXAwL2wjMmlTVDAvbE9ZIzJkWjsnUyMyZDsnUzs9YCMydTwlbE8jMmQwL2wjMnhQOz1gPCVsIzJkMDVXIzNPUDs9YDwlbCMxcDAxTyMzWVcoWiFiVDAvbE9ZIzNSWncjM1J3eCMyZHgjTyMzUiNPI1AjMmQjUDsnUyMzUjsnUzs9YCMzcjwlbE8jM1IwMU8jM3VQOz1gPCVsIzNSMDZqIzN7UDs9YDwlbCMwbjA1eCM0WF0kaSZqKFdwVDAvbE9ZIzRPWVomY1pyIzRPcnMjMXBzIV4jNE8hXiFfIzVRIV8jTyM0TyNPI1AjMXAjUCNvIzRPI28jcCM1USNwOydTIzRPOydTOz1gIzV3PCVsTyM0TzAwXiM1WFcoV3BUMC9sT1kjNVFaciM1UXJzIzJkcyNPIzVRI08jUCMyZCNQOydTIzVROydTOz1gIzVxPCVsTyM1UTAwXiM1dFA7PWA8JWwjNVEwNXgjNXpQOz1gPCVsIzRPMDFwIzZXWShXcChaIWJUMC9sT1kjNX1aciM1fXJzIzNSc3cjNX13eCM1UXgjTyM1fSNPI1AjMmQjUDsnUyM1fTsnUzs9YCM2djwlbE8jNX0wMXAjNnlQOz1gPCVsIzV9MDdbIzdQUDs9YDwlbCMvZCkzaCM3YWIkaSZqJFEoQ2goV3AoWiFiIVg3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1pBdCM4dmIkWiN0JGkmaihXcChaIWIhWDdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7WidBZCM6WnAkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhM1khUCFRJVohUSFbIzxfIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MjPF8jUyNVJVojVSNWIz9pI1YjWCVaI1gjWSE0fCNZI2IlWiNiI2MjPl8jYyNkI0JxI2QjbCVaI2wjbSNFcyNtI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCM8amskaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhM1khUCFRJVohUSFbIzxfIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MjPF8jUyNYJVojWCNZITR8I1kjYiVaI2IjYyM+XyNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCM+al8kaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCM/cmQkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhUiNBUSFSIVMjQVEhUyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0FRI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0FdZiRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhUiNBUSFSIVMjQVEhUyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0FRI1MjYiVaI2IjYyM+XyNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNCemMkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWSNEViFZIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjRFYjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjRGJlJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFZI0RWIVkhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNEViNTI2IlWiNiI2MjPl8jYyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjRXxnJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVsjR2UhWyFeJVohXiFfKmchXyFjJVohYyFpI0dlIWkjTyVaI08jUCZjI1AjUiVaI1IjUyNHZSNTI1QlWiNUI1ojR2UjWiNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjR3BpJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbI0dlIVshXiVaIV4hXypnIV8hYyVaIWMhaSNHZSFpI08lWiNPI1AmYyNQI1IlWiNSI1MjR2UjUyNUJVojVCNaI0dlI1ojYiVaI2IjYyM+XyNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiopeCNJbF8hZyRiJGkmaiRPKUx2KFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKVsjSnZfYWwkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDRmI0xTXmgjKWAjUi08VShXcChaIWIkbjdgT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IVAqZyFQIVEjTU8hUSFeKmchXiFfI010IV8hYCQgZiFgI08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhuI01YWCRrJmooV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhFbCNNfVojcihDaChXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcnghXypnIV8hYCNOcCFgI08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyhFbCNOeVgkUShDaChXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKEVsJCBvWCNzKENoKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcqKXgkIWdhI2AqIVkkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYDB6IWAhYSQjbCFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLWyQjd18jayhDbCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoqKXgkJVZhZyEqciNzKENoJGYjfCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgJCZbIWAhYSQnZiFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQmZ18jcyhDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckJ3FhI3IoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAhYSQodiFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQpUmAjcihDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS2QkKmBhKHIoQ3QkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYSVaIWEhYiQrZSFiI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQrcGAkaSZqI3soQ2goV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI2AkLH1fIXwkSXAkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDRmJC5YXyFTMCx2JGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihuJC9dWiRpJmpPIV4kME8hXiFfJDBmIV8jaSQwTyNpI2okMGsjaiNsJDBPI2wjbSQyXiNtI28kME8jbyNwJDBmI3A7J1MkME87J1M7PWAkNGk8JWxPJDBPKG4kMFZUXyNTJGkmak8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjI1MkMGtPXyNTKG4kMHBbJGkmak8hUSZjIVEhWyQxZiFbIV4mYyFfIWMmYyFjIWkkMWYhaSNUJmMjVCNaJDFmI1ojbyZjI28jcCQzfCNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJDFrWiRpJmpPIVEmYyFRIVskMl4hWyFeJmMhXyFjJmMhYyFpJDJeIWkjVCZjI1QjWiQyXiNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJDJjWiRpJmpPIVEmYyFRIVskM1UhWyFeJmMhXyFjJmMhYyFpJDNVIWkjVCZjI1QjWiQzVSNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyhuJDNaWiRpJmpPIVEmYyFRIVskME8hWyFeJmMhXyFjJmMhYyFpJDBPIWkjVCZjI1QjWiQwTyNaI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDRQUiFRIVskNFkhYyFpJDRZI1QjWiQ0WSNTJDRdUyFRIVskNFkhYyFpJDRZI1QjWiQ0WSNxI3IkMGYobiQ0bFA7PWA8JWwkME8jMVskNHpfIVkjKWwkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJDZVYCN4KENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWis7cCQ3Y18kaSZqKFdwKFohYihhKzRRT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1skOHFrJGkmaihXcChaIWIoVCwyaiRfI3QoZSRJW09ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOGJ1dyVad3gocnh9JVp9IU8kOmYhTyFRJVohUSFbJDhiIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ4YiF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOGIjUyNUJVojVCNvJDhiI28jcCpnI3AkZyVaJGc7J1MkOGI7J1M7PWAkPGw8JWxPJDhiK2QkOnFrJGkmaihXcChaIWIkXyN0T1klWllaJmNaciVacnMmfXN0JVp0dSQ6ZnV3JVp3eChyeH0lWn0hTyQ6ZiFPIVElWiFRIVskOmYhWyFeJVohXiFfKmchXyFjJVohYyF9JDpmIX0jTyVaI08jUCZjI1AjUiVaI1IjUyQ6ZiNTI1QlWiNUI28kOmYjbyNwKmcjcCRnJVokZzsnUyQ6ZjsnUzs9YCQ8ZjwlbE8kOmYrZCQ8aVA7PWA8JWwkOmYwN1skPG9QOz1gPCVsJDhiI0pmJDx7WCFfI0hiKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcsI3gkPXNhKHkrSlkkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3AjcSQrZSNxOydTJVo7J1M7PWArYTwlbE8lWik+diQ/Vl8hXihDZHZCciRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVo/TyRAYV8hcTdgJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyRBcXwkaSZqKFdwKFohYid8MC9sJF0jdChULDJqKGUkSVtPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN0JVp0dUVydXclWnd4KHJ4fSVafSFPR3YhTyFRJVohUSFbRXIhWyFeJVohXiFfKmchXyFjJVohYyF9RXIhfSNPJVojTyNQJmMjUCNSJVojUiNTRXIjUyNUJVojVCNvRXIjbyNwKmcjcCRmJVokZiRnK2ckZyNCWUVyI0JZI0JaJEFgI0JaJElTRXIkSVMkSV8kQWAkSV8kSlRFciRKVCRKVSRBYCRKVSRLVkVyJEtWJEtXJEFgJEtXJkZVRXImRlUmRlYkQWAmRlY7J1NFcjsnUzs9YEl8PCVsP0hURXI/SFQ/SFUkQWA/SFVPRXIwN1skRHxrJGkmaihXcChaIWInfTAvbCRdI3QoVCwyaihlJElbT1klWllaJmNaciVacnMmfXN0JVp0dUVydXclWnd4KHJ4fSVafSFPR3YhTyFRJVohUSFbRXIhWyFeJVohXiFfKmchXyFjJVohYyF9RXIhfSNPJVojTyNQJmMjUCNSJVojUiNTRXIjUyNUJVojVCNvRXIjbyNwKmcjcCRnJVokZzsnU0VyOydTOz1gSXw8JWxPRXJcIixcbiAgdG9rZW5pemVyczogW25vU2VtaWNvbG9uLCBub1NlbWljb2xvblR5cGUsIG9wZXJhdG9yVG9rZW4sIGpzeCwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCBpbnNlcnRTZW1pY29sb24sIG5ldyBMb2NhbFRva2VuR3JvdXAoXCIkU35SUnR1WyNPI1BnI1MjVCN8fl9QI28jcGJ+Z094fn5qVk8jaSFQI2kjaiFVI2ojbCFQI2wjbSFxI207J1MhUDsnUzs9YCN2PCVsTyFQfiFVTyFVfn4hWFMhUSFbIWUhYyFpIWUjVCNaIWUjbyNwI1p+IWhSIVEhWyFxIWMhaSFxI1QjWiFxfiF0UiFRIVshfSFjIWkhfSNUI1ohfX4jUVIhUSFbIVAhYyFpIVAjVCNaIVB+I15SIVEhWyNnIWMhaSNnI1QjWiNnfiNqUyFRIVsjZyFjIWkjZyNUI1ojZyNxI3IhUH4jeVA7PWA8JWwhUH4kUk8oY35+XCIsIDE0MSwgMzQwKSwgbmV3IExvY2FsVG9rZW5Hcm91cChcImp+UlFZWlh6e15+Xk8oUX5+YVAhUCFRZH5pTyhSfn5cIiwgMjUsIDMyMyldLFxuICB0b3BSdWxlczoge1wiU2NyaXB0XCI6WzAsN10sXCJTaW5nbGVFeHByZXNzaW9uXCI6WzEsMjc2XSxcIlNpbmdsZUNsYXNzSXRlbVwiOlsyLDI3N119LFxuICBkaWFsZWN0czoge2pzeDogMCwgdHM6IDE1MTc1fSxcbiAgZHluYW1pY1ByZWNlZGVuY2VzOiB7XCI4MFwiOjEsXCI4MlwiOjEsXCI5NFwiOjEsXCIxNjlcIjoxLFwiMTk5XCI6MX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDMyNywgZ2V0OiAodmFsdWUpID0+IHNwZWNfaWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAzNDMsIGdldDogKHZhbHVlKSA9PiBzcGVjX3dvcmRbdmFsdWVdIHx8IC0xfSx7dGVybTogOTUsIGdldDogKHZhbHVlKSA9PiBzcGVjX0xlc3NUaGFuW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDE1MjAxXG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parse that this stack is part of @internal\n    */\n    p, \n    /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */\n    stack, \n    /**\n    The current parse state @internal\n    */\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */\n    reducePos, \n    /**\n    The input position up to which this stack has parsed.\n    */\n    pos, \n    /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */\n    bufferBase, \n    /**\n    @internal\n    */\n    curContext, \n    /**\n    @internal\n    */\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */;\n        if (lookaheadRecord)\n            this.setLookAhead(this.pos);\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */\n    storeNode(term, start, end, size = 4, mustSink = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!mustSink || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && (this.buffer[index - 4] != 0 /* Term.Err */ || this.buffer[index - 1] < 0)) {\n                let mustMove = false;\n                for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {\n                    if (this.buffer[scan - 1] >= 0) {\n                        mustMove = true;\n                        break;\n                    }\n                }\n                if (mustMove)\n                    while (index > 0 && this.buffer[index - 2] > end) {\n                        // Move this record forward\n                        this.buffer[index] = this.buffer[index - 4];\n                        this.buffer[index + 1] = this.buffer[index - 3];\n                        this.buffer[index + 2] = this.buffer[index - 2];\n                        this.buffer[index + 3] = this.buffer[index - 1];\n                        index -= 4;\n                        if (size > 4)\n                            size -= 4;\n                    }\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */\n    shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */\n    apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */\n    restart() {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */\n    get parser() { return this.p.parser; }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    input, \n    /**\n    @internal\n    */\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */\n        this.chunk = \"\";\n        /**\n        @internal\n        */\n        this.chunkOff = 0;\n        /**\n        Backup chunk\n        */\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */\n        this.next = -1;\n        /**\n        @internal\n        */\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsingâ€”when looking forwardâ€”or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */\n    acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (!atEof)\n                skipped++;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */)\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; j < 10 /* Rec.ForceReduceLimit */ && force.forceReduce(); j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n    /**\n    Define a context tracker.\n    */\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */\n    constructor(spec) {\n        super();\n        /**\n        @internal\n        */\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /**\n    @internal\n    */\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /**\n    @internal\n    */\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /**\n    @internal\n    */\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */\n    get eofTerm() { return this.maxNode + 1; }\n    /**\n    The type of top node produced by the parser.\n    */\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /**\n    @internal\n    */\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUEyRCxJQUFJLFNBQVMsRUFBRSxtQ0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5Q0FBeUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFD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Y3QtbGVhcm5pbmctcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcz8wMDFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlciwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBUcmVlLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xucGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG50aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YWNrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHAsIFxuICAgIC8qKlxuICAgIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFjaywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZVBvcywgXG4gICAgLyoqXG4gICAgVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICB0cmFja2VyLlxuICAgICovXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGxvb2thaGVhZFJlY29yZCA9IHRoaXMucmVkdWNlUG9zIDwgdGhpcy5wb3MgLSAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovO1xuICAgICAgICBpZiAobG9va2FoZWFkUmVjb3JkKVxuICAgICAgICAgICAgdGhpcy5zZXRMb29rQWhlYWQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCBsb29rYWhlYWRSZWNvcmQgPyA4IDogNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMl0gOiB0aGlzLnAucmFuZ2VzWzBdLmZyb20sIHNpemUgPSB0aGlzLnJlZHVjZVBvcyAtIHN0YXJ0O1xuICAgICAgICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIHRyeSBhbmQgZGV0ZWN0IG92ZXJseSBkZWVwIGxlZnQtYXNzb2NpYXRpdmVcbiAgICAgICAgLy8gdHJlZXMsIHdoaWNoIHdpbGwgbm90IGluY3JlYXNlIHRoZSBwYXJzZSBzdGFjayBkZXB0aCBhbmQgdGh1c1xuICAgICAgICAvLyB3b24ndCBiZSBjYXVnaHQgYnkgdGhlIHJlZ3VsYXIgc3RhY2stZGVwdGggbGltaXQgY2hlY2suXG4gICAgICAgIGlmIChzaXplID49IDIwMDAgLyogUmVjb3Zlci5NaW5CaWdSZWR1Y3Rpb24gKi8gJiYgISgoX2EgPSB0aGlzLnAucGFyc2VyLm5vZGVTZXQudHlwZXNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Fub255bW91cykpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDFdIDogMCwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLlJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgbXVzdFNpbmsgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIFRlcm0uRXJyICovICYmXG4gICAgICAgICAgICAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMuYnVmZmVyQmFzZSkpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIFRlcm0uRXJyICovICYmIGN1ci5idWZmZXJbdG9wIC0gMV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJ1ZmZlclt0b3AgLSAyXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuYnVmZmVyW3RvcCAtIDJdID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbXVzdFNpbmsgfHwgdGhpcy5wb3MgPT0gZW5kKSB7IC8vIFNpbXBsZSBjYXNlLCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0ZXJtLCBzdGFydCwgZW5kLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVGhlcmUgbWF5IGJlIHNraXBwZWQgbm9kZXMgdGhhdCBoYXZlIHRvIGJlIG1vdmVkIGZvcndhcmRcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgKHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBUZXJtLkVyciAqLyB8fCB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdIDwgMCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPiAwICYmIHRoaXMuYnVmZmVyW3NjYW4gLSAyXSA+IGVuZDsgc2NhbiAtPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlcltzY2FuIC0gMV0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVzdE1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG11c3RNb3ZlKVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gMl0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IC09IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0ZXJtO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaGlmdChhY3Rpb24sIHR5cGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uR290b0ZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRoaXMucG9zIHx8IHR5cGUgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0eXBlIDw9IHBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godHlwZSwgc3RhcnQsIGVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFNoaWZ0LWFuZC1zdGF5LCB3aGljaCBtZWFucyB0aGlzIGlzIGEgc2tpcHBlZCB0b2tlblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAodHlwZSA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0eXBlLCBzdGFydCwgZW5kLCA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhbiBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dFN0YXJ0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0U3RhcnQsIG5leHRFbmQpO1xuICAgIH1cbiAgICAvLyBBZGQgYSBwcmVidWlsdCAocmV1c2VkKSBub2RlIGludG8gdGhlIGJ1ZmZlci5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5wLCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCB0aGlzLmN1ckNvbnRleHQsIHRoaXMubG9va0FoZWFkLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDE5MCAvKiBSZWNvdmVyLkRlbGV0ZSAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgKi9cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogUmVjb3Zlci5NYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHM7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzID0gbmV4dFN0YXRlc1tpICsgMV0pICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBSZWNvdmVyLk1heE5leHQgKi87IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBSZWNvdmVyLkluc2VydCAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IHJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBQYXJzZVN0YXRlLkZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHJlZHVjZSA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSBkZXB0aCAqIDM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IDwgMCB8fCBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFja3VwID0gdGhpcy5maW5kRm9yY2VkUmVkdWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2t1cCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVkdWNlID0gYmFja3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlY292ZXIuUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gc2NhbiB0aHJvdWdoIHRoZSBhdXRvbWF0b24gdG8gZmluZCBzb21lIGtpbmQgb2YgcmVkdWN0aW9uXG4gICAgdGhhdCBjYW4gYmUgYXBwbGllZC4gVXNlZCB3aGVuIHRoZSByZWd1bGFyIEZvcmNlZFJlZHVjZSBmaWVsZFxuICAgIGlzbid0IGEgdmFsaWQgYWN0aW9uLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmRGb3JjZWRSZWR1Y3Rpb24oKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wLCBzZWVuID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHN0YXRlLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5jbHVkZXMoc3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlZW4ucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLmFsbEFjdGlvbnMoc3RhdGUsIChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICYgKDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gfCAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByRGVwdGggPSAoYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKSAtIGRlcHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAockRlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIHJEZXB0aCAqIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID49IDAgJiYgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJEZXB0aCA8PCAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgfCA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLyB8IHRlcm07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGV4cGxvcmUoYWN0aW9uLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4cGxvcmUodGhpcy5zdGF0ZSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wLnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgaGFzIG5vIGZ1cnRoZXIgYWN0aW9ucyAoYXNzdW1lZCB0byBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZVxuICAgIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICBzb21laG93KS4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZGVhZEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9IDMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICByZXR1cm4gcGFyc2VyLmRhdGFbcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8gJiZcbiAgICAgICAgICAgICFwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICAgIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIHN0YXRlKS4gQGludGVybmFsXG4gICAgKi9cbiAgICByZXN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1swXTtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcGFyc2VyIHVzZWQgYnkgdGhpcyBzdGFjay5cbiAgICAqL1xuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLnAucGFyc2VyOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgICovXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLnAucGFyc2VyLmRpYWxlY3QuZmxhZ3NbZGlhbGVjdElEXTsgfVxuICAgIHNoaWZ0Q29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnNoaWZ0KHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICByZWR1Y2VDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVtaXRDb250ZXh0KCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtMylcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5jdXJDb250ZXh0Lmhhc2gsIHRoaXMucG9zLCB0aGlzLnBvcywgLTMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldExvb2tBaGVhZChsb29rQWhlYWQpIHtcbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IHRoaXMubG9va0FoZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQgJiYgdGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0KVxuICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5sb29rQWhlYWQgPiAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2tDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRyYWNrZXIuc3RyaWN0ID8gdHJhY2tlci5oYXNoKGNvbnRleHQpIDogMDtcbiAgICB9XG59XG4vLyBVc2VkIHRvIGNoZWFwbHkgcnVuIHNvbWUgcmVkdWN0aW9ucyB0byBzY2FuIGFoZWFkIHdpdGhvdXQgbXV0YXRpbmdcbi8vIGFuIGVudGlyZSBzdGFja1xuY2xhc3MgU2ltdWxhdGVkU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhcnQuc3RhY2s7XG4gICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG4vLyBTZWUgbGV6ZXItZ2VuZXJhdG9yL3NyYy9lbmNvZGUudHMgZm9yIGNvbW1lbnRzIGFib3V0IHRoZSBlbmNvZGluZ1xuLy8gdXNlZCBoZXJlXG5mdW5jdGlvbiBkZWNvZGVBcnJheShpbnB1dCwgVHlwZSA9IFVpbnQxNkFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgbGV0IGFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBvdXQgPSAwOyBwb3MgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyksIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IDEyNiAvKiBFbmNvZGUuQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogRW5jb2RlLkJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEVuY29kZS5HYXAyICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGlmIChuZXh0ID49IDM0IC8qIEVuY29kZS5HYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBFbmNvZGUuU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogRW5jb2RlLkJhc2UgKi8pIHtcbiAgICAgICAgICAgICAgICBkaWdpdCAtPSA0NiAvKiBFbmNvZGUuQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBFbmNvZGUuQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuY2xhc3MgQ2FjaGVkVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IDA7XG4gICAgICAgIHRoaXMubWFzayA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IDA7XG4gICAgfVxufVxuY29uc3QgbnVsbFRva2VuID0gbmV3IENhY2hlZFRva2VuO1xuLyoqXG5bVG9rZW5pemVyc10oI2xyLkV4dGVybmFsVG9rZW5pemVyKSBpbnRlcmFjdCB3aXRoIHRoZSBpbnB1dFxudGhyb3VnaCB0aGlzIGludGVyZmFjZS4gSXQgcHJlc2VudHMgdGhlIGlucHV0IGFzIGEgc3RyZWFtIG9mXG5jaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuW3Jhbmdlc10oI2NvbW1vbi5QYXJzZXIucGFyc2VecmFuZ2VzKSBmcm9tIHRva2VuaXplciBjb2RlLlxuKi9cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBCYWNrdXAgY2h1bmtcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgd2hlbiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5lbmQgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU9mZnNldChvZmZzZXQsIGFzc29jKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMucmFuZ2UsIGluZGV4ID0gdGhpcy5yYW5nZUluZGV4O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChwb3MgPCByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1stLWluZGV4XTtcbiAgICAgICAgICAgIHBvcyAtPSByYW5nZS5mcm9tIC0gbmV4dC50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXNzb2MgPCAwID8gcG9zID4gcmFuZ2UudG8gOiBwb3MgPj0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1srK2luZGV4XTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0LmZyb20gLSByYW5nZS50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsaXBQb3MocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5yYW5nZS5mcm9tICYmIHBvcyA8IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0aGlzLnJhbmdlcylcbiAgICAgICAgICAgIGlmIChyYW5nZS50byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocG9zLCByYW5nZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICBgLm5leHRgLCBgLnBlZWsoLTEpYCBnaXZlcyB5b3UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciwgYW5kIHNvXG4gICAgb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgb24gcG90ZW50aWFsbHkgZmFyLWF3YXkgY29udGVudCwgd2hpY2ggbWF5IHJlZHVjZSB0aGVcbiAgICBlZmZlY3RpdmVuZXNzIGluY3JlbWVudGFsIHBhcnNpbmfigJR3aGVuIGxvb2tpbmcgZm9yd2FyZOKAlG9yIGV2ZW5cbiAgICBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIHVuaXRzLCBzaW5jZSB0aGUgbGlicmFyeSBkb2VzIG5vdCB0cmFjayBsb29rYmVoaW5kLlxuICAgICovXG4gICAgcGVlayhvZmZzZXQpIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuY2h1bmtPZmYgKyBvZmZzZXQsIHBvcywgcmVzdWx0O1xuICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHBvcyA9IHJlc29sdmVkO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiBwb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQocG9zIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnJhbmdlSW5kZXgsIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFuZ2UudG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2VzWysraV07XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMuY2h1bmsyUG9zID0gcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgdGhpcy5jaHVuazIubGVuZ3RoID4gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuazIuc2xpY2UoMCwgcmFuZ2UudG8gLSBwb3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiwgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXQgKHJlbGF0aXZlIHRvXG4gICAgdGhlIHN0cmVhbSBwb3NpdGlvbikgdG8gY2hhbmdlIHRoYXQuXG4gICAgKi9cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWNjZXB0IGEgdG9rZW4gZW5kaW5nIGF0IGEgc3BlY2lmaWMgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBhY2NlcHRUb2tlblRvKHRva2VuLCBlbmRQb3MpIHtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZFBvcztcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgICB0aGUgbmV3IHZhbHVlIG9mIFtgbmV4dGBdKCNsci5JbnB1dFN0cmVhbS5uZXh0KS5cbiAgICAqL1xuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldChwb3MsIHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdG9rZW4uc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB0b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5leHRlbmRlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgIT0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIGlmIChwb3MgPT0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLnJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWy0tdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPj0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rUG9zICYmIHBvcyA8IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSBwb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rUG9zICYmIHRvIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rUG9zLCB0byAtIHRoaXMuY2h1bmtQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rMlBvcyAmJiB0byA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShmcm9tIC0gdGhpcy5jaHVuazJQb3MsIHRvIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLnJhbmdlLmZyb20gJiYgdG8gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbnB1dC5yZWFkKE1hdGgubWF4KHIuZnJvbSwgZnJvbSksIE1hdGgubWluKHIudG8sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkLCBwYXJzZXIuZGF0YSwgcGFyc2VyLnRva2VuUHJlY1RhYmxlKTtcbiAgICB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8qKlxuQGhpZGVcbiovXG5jbGFzcyBMb2NhbFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHByZWNUYWJsZSwgZWxzZVRva2VuKSB7XG4gICAgICAgIHRoaXMucHJlY1RhYmxlID0gcHJlY1RhYmxlO1xuICAgICAgICB0aGlzLmVsc2VUb2tlbiA9IGVsc2VUb2tlbjtcbiAgICAgICAgdGhpcy5kYXRhID0gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiA/IGRlY29kZUFycmF5KGRhdGEpIDogZGF0YTtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGlucHV0LnBvcywgc2tpcHBlZCA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEVvZiA9IGlucHV0Lm5leHQgPCAwLCBuZXh0UG9zID0gaW5wdXQucmVzb2x2ZU9mZnNldCgxLCAxKTtcbiAgICAgICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgMCwgdGhpcy5kYXRhLCB0aGlzLnByZWNUYWJsZSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQudG9rZW4udmFsdWUgPiAtMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmVsc2VUb2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghYXRFb2YpXG4gICAgICAgICAgICAgICAgc2tpcHBlZCsrO1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KG5leHRQb3MsIGlucHV0LnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgaW5wdXQucmVzZXQoc3RhcnQsIGlucHV0LnRva2VuKTtcbiAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRoaXMuZWxzZVRva2VuLCBza2lwcGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkxvY2FsVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbmBAZXh0ZXJuYWwgdG9rZW5zYCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdyYW1tYXIgc2hvdWxkIHJlc29sdmUgdG9cbmFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIGdpdmVuIGFuIGlucHV0IHN0cmVhbSwgc2NhbnMgZm9yIHRoZSB0eXBlcyBvZiB0b2tlbnMgaXRcbiAgICByZWNvZ25pemVzIGF0IHRoZSBzdHJlYW0ncyBwb3NpdGlvbiwgYW5kIGNhbGxzXG4gICAgW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIG9uZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYGlucHV0LnRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgc3RhY2ssIGdyb3VwLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpIHtcbiAgICBsZXQgc3RhdGUgPSAwLCBncm91cE1hc2sgPSAxIDw8IGdyb3VwLCB7IGRpYWxlY3QgfSA9IHN0YWNrLnAucGFyc2VyO1xuICAgIHNjYW46IGZvciAoOzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC50b2tlbi52YWx1ZSA9PSAtMSB8fCBpbnB1dC50b2tlbi52YWx1ZSA9PSB0ZXJtIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXModGVybSwgaW5wdXQudG9rZW4udmFsdWUsIHByZWNUYWJsZSwgcHJlY09mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gaW5wdXQubmV4dCwgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBFT0ZcbiAgICAgICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIGhpZ2ggPiBsb3cgJiYgZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDNdID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgIHN0YXRlID0gZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDFdO1xuICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yICg7IGxvdyA8IGhpZ2g7KSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBhY2NFbmQgKyBtaWQgKyAobWlkIDw8IDEpO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkYXRhW2luZGV4XSwgdG8gPSBkYXRhW2luZGV4ICsgMV0gfHwgMHgxMDAwMDtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlcyh0b2tlbiwgcHJldiwgdGFibGVEYXRhLCB0YWJsZU9mZnNldCkge1xuICAgIGxldCBpUHJldiA9IGZpbmRPZmZzZXQodGFibGVEYXRhLCB0YWJsZU9mZnNldCwgcHJldik7XG4gICAgcmV0dXJuIGlQcmV2IDwgMCB8fCBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHRva2VuKSA8IGlQcmV2O1xufVxuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgY29uc29sZSBvdXRwdXRcbmNvbnN0IHZlcmJvc2UgPSB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIC9cXGJwYXJzZVxcYi8udGVzdChwcm9jZXNzLmVudi5MT0cpO1xubGV0IHN0YWNrSURzID0gbnVsbDtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTtcbiAgICBjdXJzb3IubW92ZVRvKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8IHBvcyA6IGN1cnNvci5mcm9tID4gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3Vyc29yLnRvIC0gMSwgcG9zIC0gMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gMCA6IHRyZWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIG5vZGVTZXQpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhZmVGcm9tID0gLTE7XG4gICAgICAgIHRoaXMuc2FmZVRvID0gLTE7XG4gICAgICAgIHRoaXMudHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgbGV0IGZyID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyBudWxsIDogdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdO1xuICAgICAgICBpZiAoZnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUZyb20gPSBmci5vcGVuU3RhcnQgPyBjdXRBdChmci50cmVlLCBmci5mcm9tICsgZnIub2Zmc2V0LCAxKSAtIGZyLm9mZnNldCA6IGZyLmZyb207XG4gICAgICAgICAgICB0aGlzLnNhZmVUbyA9IGZyLm9wZW5FbmQgPyBjdXRBdChmci50cmVlLCBmci50byArIGZyLm9mZnNldCwgLTEpIC0gZnIub2Zmc2V0IDogZnIudG87XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50cmVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChmci50cmVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaCgtZnIub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gdGhpcy5zYWZlRnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMWU5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGBwb3NgIG11c3QgYmUgPj0gYW55IHByZXZpb3VzbHkgZ2l2ZW4gYHBvc2AgZm9yIHRoaXMgY3Vyc29yXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5uZXh0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gcG9zKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSB7IC8vIEVuZCBvZiB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRyZWVzW2xhc3RdLCBpbmRleCA9IHRoaXMuaW5kZXhbbGFzdF07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdG9wLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydFtsYXN0XSArIHRvcC5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rQWhlYWQgfHwgZW5kICsgbG9va0FoZWFkIDwgdGhpcy5mcmFnbWVudC50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gTWF0aC5tYXgodGhpcy5zYWZlRnJvbSwgcG9zKSkgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2spIHtcbiAgICAgICAgbGV0IGFjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1haW4gPSBudWxsO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogUGFyc2VTdGF0ZS5Ub2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IE1hdGgubWF4KHRva2VuLmxvb2tBaGVhZCwgbG9va0FoZWFkKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIFRlcm0uRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgIHJldHVybiBtYWluO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbih0aGlzLnN0cmVhbS5yZXNldChzdGFydCwgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmV4dGVuZGVkID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgIHRva2VuLmVuZCA9IHRoaXMuc3RyZWFtLmNsaXBQb3Moc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBQYXJzZVN0YXRlLlNraXAgKi8gOiAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDIpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEJpZ1JlZHVjdGlvblNpemUgPSAwO1xuICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0oaW5wdXQsIHJhbmdlcyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyLCB0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIGxldCB7IGZyb20gfSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgZnJvbSldO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGggJiYgdGhpcy5zdHJlYW0uZW5kIC0gZnJvbSA+IHBhcnNlci5idWZmZXJMZW5ndGggKiA0XG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIHBhcnNlci5ub2RlU2V0KSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN0YWNrUG9zO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLm1pblN0YWNrUG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIC8vIElmIGEgbGFyZ2UgYW1vdW50IG9mIHJlZHVjdGlvbnMgaGFwcGVuZWQgd2l0aCB0aGUgc2FtZSBzdGFydFxuICAgICAgICAvLyBwb3NpdGlvbiwgZm9yY2UgdGhlIHN0YWNrIG91dCBvZiB0aGF0IHByb2R1Y3Rpb24gaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gYXZvaWQgY3JlYXRpbmcgYSB0cmVlIHRvbyBkZWVwIHRvIHJlY3Vyc2UgdGhyb3VnaC5cbiAgICAgICAgLy8gKFRoaXMgaXMgYW4gdWdseSBrbHVkZ2UsIGJlY2F1c2UgdW5mb3J0dW5hdGVseSB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdHJhaWdodGZvcndhcmQsIGNoZWFwIHdheSB0byBjaGVjayBmb3IgdGhpcyBoYXBwZW5pbmcsIGR1ZSB0b1xuICAgICAgICAvLyB0aGUgaGlzdG9yeSBvZiByZWR1Y3Rpb25zIG9ubHkgYmVpbmcgYXZhaWxhYmxlIGluIGFuXG4gICAgICAgIC8vIGV4cGVuc2l2ZS10by1hY2Nlc3MgZm9ybWF0IGluIHRoZSBzdGFjayBidWZmZXJzLilcbiAgICAgICAgaWYgKHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPiAzMDAgLyogUmVjLk1heExlZnRBc3NvY2lhdGl2ZVJlZHVjdGlvbkNvdW50ICovICYmIHN0YWNrcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IFtzXSA9IHN0YWNrcztcbiAgICAgICAgICAgIHdoaWxlIChzLmZvcmNlUmVkdWNlKCkgJiYgcy5zdGFjay5sZW5ndGggJiYgcy5zdGFja1tzLnN0YWNrLmxlbmd0aCAtIDJdID49IHRoaXMubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7IH1cbiAgICAgICAgICAgIHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2ggd2l0aCBcIiArIHRoaXMuc3RhY2tJRChmaW5pc2hlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIFJlYy5EaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvcmNlLWZpbmlzaCBcIiArIHRoaXMuc3RhY2tJRChmaW5pc2hlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkLmZvcmNlQWxsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXhSZW1haW5pbmcgPSB0aGlzLnJlY292ZXJpbmcgPT0gMSA/IDEgOiB0aGlzLnJlY292ZXJpbmcgKiAzIC8qIFJlYy5NYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gNTAwIC8qIFJlYy5NaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIFJlYy5NaW5CdWZmZXJMZW5ndGhQcnVuZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoc3RhY2suc2NvcmUgLSBvdGhlci5zY29yZSkgfHwgKHN0YWNrLmJ1ZmZlci5sZW5ndGggLSBvdGhlci5idWZmZXIubGVuZ3RoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLylcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovLCBuZXdTdGFja3MubGVuZ3RoIC0gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5taW5TdGFja1BvcylcbiAgICAgICAgICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzW2ldLnBvcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgdGhpcy5zdG9wcGVkQXQgPCBwb3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IG1vdmUgc3RvcHBlZEF0IGZvcndhcmRcIik7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RhY2ssIG9yIG51bGwgaWYgdGhlXG4gICAgLy8gc3RhY2sgY2FuJ3QgYWR2YW5jZSBub3JtYWxseS4gV2hlbiBgc3BsaXRgIGFuZCBgc3RhY2tzYCBhcmVcbiAgICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAgIC8vIGBzcGxpdGAsIG9yIGFkZGVkIHRvIGBzdGFja3NgIGlmIHRoZXkgbW92ZSBgcG9zYCBmb3J3YXJkLlxuICAgIGFkdmFuY2VTdGFjayhzdGFjaywgc3RhY2tzLCBzcGxpdCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGFjay5wb3MsIHsgcGFyc2VyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdGFydCA+IHRoaXMuc3RvcHBlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmZvcmNlUmVkdWNlKCkgPyBzdGFjayA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgbGV0IHN0cmljdEN4ID0gc3RhY2suY3VyQ29udGV4dCAmJiBzdGFjay5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0LCBjeEhhc2ggPSBzdHJpY3RDeCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZWQgPSB0aGlzLmZyYWdtZW50cy5ub2RlQXQoc3RhcnQpOyBjYWNoZWQ7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tjYWNoZWQudHlwZS5pZF0gPT0gY2FjaGVkLnR5cGUgPyBwYXJzZXIuZ2V0R290byhzdGFjay5zdGF0ZSwgY2FjaGVkLnR5cGUuaWQpIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID4gLTEgJiYgY2FjaGVkLmxlbmd0aCAmJiAoIXN0cmljdEN4IHx8IChjYWNoZWQucHJvcChOb2RlUHJvcC5jb250ZXh0SGFzaCkgfHwgMCkgPT0gY3hIYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2VOb2RlKGNhY2hlZCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJldXNlIG9mICR7cGFyc2VyLmdldE5hbWUoY2FjaGVkLnR5cGUuaWQpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIFRyZWUpIHx8IGNhY2hlZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBjYWNoZWQucG9zaXRpb25zWzBdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2FjaGVkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lciBpbnN0YW5jZW9mIFRyZWUgJiYgY2FjaGVkLnBvc2l0aW9uc1swXSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0UmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLyl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLnN0YWNrLmxlbmd0aCA+PSA4NDAwIC8qIFJlYy5DdXREZXB0aCAqLykge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLnN0YWNrLmxlbmd0aCA+IDYwMDAgLyogUmVjLkN1dFRvICovICYmIHN0YWNrLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjayk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1tpKytdLCB0ZXJtID0gYWN0aW9uc1tpKytdLCBlbmQgPSBhY3Rpb25zW2krK107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gYWN0aW9ucy5sZW5ndGggfHwgIXNwbGl0O1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhY2sgPSBsYXN0ID8gc3RhY2sgOiBzdGFjay5zcGxpdCgpO1xuICAgICAgICAgICAgbGV0IG1haW4gPSB0aGlzLnRva2Vucy5tYWluVG9rZW47XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgbWFpbiA/IG1haW4uc3RhcnQgOiBsb2NhbFN0YWNrLnBvcywgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDEwIC8qIFJlYy5Gb3JjZVJlZHVjZUxpbWl0ICovICYmIGZvcmNlLmZvcmNlUmVkdWNlKCk7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0uZW5kID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8qKlxuQ29udGV4dCB0cmFja2VycyBhcmUgdXNlZCB0byB0cmFjayBzdGF0ZWZ1bCBjb250ZXh0IChzdWNoIGFzXG5pbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG5ncmFtbWFyKSBuZWVkZWQgYnkgZXh0ZXJuYWwgdG9rZW5pemVycy4gWW91IGRlY2xhcmUgdGhlbSBpbiBhXG5ncmFtbWFyIGZpbGUgYXMgYEBjb250ZXh0IGV4cG9ydE5hbWUgZnJvbSBcIm1vZHVsZVwiYC5cblxuQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbm9uIHNoaWZ0IG9yIHJlZHVjZSBhY3Rpb25zLlxuXG5UaGUgZXhwb3J0IHVzZWQgaW4gYSBgQGNvbnRleHRgIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBvZiB0aGlzXG50eXBlLlxuKi9cbmNsYXNzIENvbnRleHRUcmFja2VyIHtcbiAgICAvKipcbiAgICBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzcGVjLnN0YXJ0O1xuICAgICAgICB0aGlzLnNoaWZ0ID0gc3BlYy5zaGlmdCB8fCBpZDtcbiAgICAgICAgdGhpcy5yZWR1Y2UgPSBzcGVjLnJlZHVjZSB8fCBpZDtcbiAgICAgICAgdGhpcy5yZXVzZSA9IHNwZWMucmV1c2UgfHwgaWQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHNwZWMuaGFzaCB8fCAoKCkgPT4gMCk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gc3BlYy5zdHJpY3QgIT09IGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuSG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWQgYnlcbmBsZXplci1nZW5lcmF0b3JgLCBhbmQgcHJvdmlkZXMgW21ldGhvZHNdKCNjb21tb24uUGFyc2VyKSB0byBwYXJzZVxuY29udGVudCB3aXRoLlxuKi9cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTQgLyogRmlsZS5WZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezE0IC8qIEZpbGUuVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gTm9kZVByb3BbcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBOb2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcFNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLnNwZWMucHJvcFNvdXJjZXMpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJTcGVjcyA9IHNwZWMuc3BlY2lhbGl6ZWQgfHwgW107XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjc1tpXS50ZXJtO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoZ2V0U3BlY2lhbGl6ZXIpO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0R290byhzdGF0ZSwgdGVybSwgbG9vc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG87XG4gICAgICAgIGlmICh0ZXJtID49IHRhYmxlWzBdKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCBsYXN0ID0gZ3JvdXBUYWcgJiAxO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxvb3NlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBQYXJzZVN0YXRlLlNraXAgKi8gOiAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogVGVybS5FcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogUGFyc2VTdGF0ZS5TaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIFBhcnNlU3RhdGUuRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hbGxBY3Rpb25zKHN0YXRlLCBhID0+IGEgPT0gYWN0aW9uID8gdHJ1ZSA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFsbEFjdGlvbnMoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBsZXQgZGVmbHQgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZGVmbHQgPyBhY3Rpb24oZGVmbHQpIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTsgcmVzdWx0ID09IG51bGw7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGFjdGlvbihwYWlyKHRoaXMuZGF0YSwgaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gICAgZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25maWd1cmUgdGhlIHBhcnNlci4gUmV0dXJucyBhIG5ldyBwYXJzZXIgaW5zdGFuY2UgdGhhdCBoYXMgdGhlXG4gICAgZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgLy8gSGlkZW91cyByZWZsZWN0aW9uLWJhc2VkIGtsdWRnZSB0byBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIGFcbiAgICAgICAgLy8gc2xpZ2h0bHkgbW9kaWZpZWQgY29weSBvZiBhIHBhcnNlci5cbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoTFJQYXJzZXIucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcHMpXG4gICAgICAgICAgICBjb3B5Lm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChjb25maWcudG9wKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMudG9wUnVsZXNbY29uZmlnLnRvcF07XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2NvbmZpZy50b3B9YCk7XG4gICAgICAgICAgICBjb3B5LnRvcCA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbml6ZXJzKVxuICAgICAgICAgICAgY29weS50b2tlbml6ZXJzID0gdGhpcy50b2tlbml6ZXJzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcudG9rZW5pemVycy5maW5kKHIgPT4gci5mcm9tID09IHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IGZvdW5kLnRvIDogdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnNwZWNpYWxpemVycykge1xuICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVycy5zbGljZSgpO1xuICAgICAgICAgICAgY29weS5zcGVjaWFsaXplclNwZWNzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcCgocywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy5zcGVjaWFsaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSBzLmV4dGVybmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICBsZXQgc3BlYyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcyksIHsgZXh0ZXJuYWw6IGZvdW5kLnRvIH0pO1xuICAgICAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzW2ldID0gZ2V0U3BlY2lhbGl6ZXIoc3BlYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNvbnRleHRUcmFja2VyKVxuICAgICAgICAgICAgY29weS5jb250ZXh0ID0gY29uZmlnLmNvbnRleHRUcmFja2VyO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3QpXG4gICAgICAgICAgICBjb3B5LmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChjb25maWcuZGlhbGVjdCk7XG4gICAgICAgIGlmIChjb25maWcuc3RyaWN0ICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LnN0cmljdCA9IGNvbmZpZy5zdHJpY3Q7XG4gICAgICAgIGlmIChjb25maWcud3JhcClcbiAgICAgICAgICAgIGNvcHkud3JhcHBlcnMgPSBjb3B5LndyYXBwZXJzLmNvbmNhdChjb25maWcud3JhcCk7XG4gICAgICAgIGlmIChjb25maWcuYnVmZmVyTGVuZ3RoICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LmJ1ZmZlckxlbmd0aCA9IGNvbmZpZy5idWZmZXJMZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciBhbnkgW3BhcnNlIHdyYXBwZXJzXSgjbHIuUGFyc2VyQ29uZmlnLndyYXApXG4gICAgYXJlIHJlZ2lzdGVyZWQgZm9yIHRoaXMgcGFyc2VyLlxuICAgICovXG4gICAgaGFzV3JhcHBlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICBgLS1uYW1lc2Agb3B0aW9uLiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBuYW1lcyBvZiB0YWdnZWQgdGVybXMgYXJlXG4gICAgc3RvcmVkLlxuICAgICovXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW9mIHRlcm0gaWQgaXMgYWx3YXlzIGFsbG9jYXRlZCBkaXJlY3RseSBhZnRlciB0aGUgbm9kZVxuICAgIHR5cGVzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRvcCBub2RlIHByb2R1Y2VkIGJ5IHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGR5bmFtaWNQcmVjZWRlbmNlKHRlcm0pIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICAgICAgcmV0dXJuIHByZWMgPT0gbnVsbCA/IDAgOiBwcmVjW3Rlcm1dIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvci4gTm90IGF2YWlsYWJsZSB0b1xuICAgIHVzZXIgY29kZS4gQGhpZGVcbiAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWFsaXplcihzcGVjKSB7XG4gICAgaWYgKHNwZWMuZXh0ZXJuYWwpIHtcbiAgICAgICAgbGV0IG1hc2sgPSBzcGVjLmV4dGVuZCA/IDEgLyogU3BlY2lhbGl6ZS5FeHRlbmQgKi8gOiAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLztcbiAgICAgICAgcmV0dXJuICh2YWx1ZSwgc3RhY2spID0+IChzcGVjLmV4dGVybmFsKHZhbHVlLCBzdGFjaykgPDwgMSkgfCBtYXNrO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYy5nZXQ7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBMb2NhbFRva2VuR3JvdXAsIFN0YWNrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ })

};
;