# 5.2 Project structure tips

Large projects evolve quickly. Establish conventions so everyone knows where to add new code without creating chaos.

<br />

## Layered approach
- **app/** â€“ routing and server-rendered entry points
- **modules/** â€“ domain-specific features (auth, billing, lessons)
- **components/** â€“ shared UI primitives
- **lib/** â€“ cross-cutting utilities (fetchers, analytics, feature flags)
- **types/** â€“ TypeScript declarations shared across modules

<br />

## Feature modules example
```
src/modules/lessons/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ getLessons.ts
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ LessonList.tsx
â”‚   â””â”€â”€ LessonFilters.tsx
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useLessonFilters.ts
â””â”€â”€ index.ts
```

Expose only what other modules need via `index.ts`.

<br />

## Documentation
- Maintain an architecture README describing folder responsibilities
- Use code owners to auto-request reviews for sensitive areas
- Automate lint rules (import order, path aliases) to enforce structure

<br />

## Workshop
- Refactor one domain into a dedicated module folder with its own entry point
- Add path aliases (`@/modules/lessons`) to simplify imports
- Document naming conventions (component suffixes, hook prefixes) in CONTRIBUTING.md

> ðŸ’¡ Use the playground on the right to experiment with the code and reset any time.
